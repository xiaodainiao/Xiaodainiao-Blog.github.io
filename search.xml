<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>c ++ primer 函数</title>
      <link href="/2022/07/06/post20/"/>
      <url>/2022/07/06/post20/</url>
      
        <content type="html"><![CDATA[<h2 id="🎯6-1-函数基础"><a href="#🎯6-1-函数基础" class="headerlink" title="🎯6.1 函数基础"></a>🎯6.1 函数基础</h2><ul><li>通过调用<code>运算符 ()</code>来执行函数。</li></ul><p><strong>函数调用完成俩项工作：</strong></p><ul><li><code>用实参初始化函数对应的形参。</code></li><li><code>将控制器转移给被调用函数。</code></li></ul><p><strong>此时主调函数被中断，被调函数开始执行。</strong></p><p><strong>函数执行的第一步：隐式地定义并初始化它的形参。实参是形参的初始值，第一个实参初始化第一个形参。</strong></p><p><strong>return 语句完成俩项工作:</strong></p><ul><li><code>返回return 语句中的值</code></li><li><code>将控制权从被调函数转移回主调函数</code></li></ul><p><strong>形参</strong></p><ul><li>实参是形参的初始值。</li><li>实参的类型与形参类型匹配，或者可以转换成形参类型。</li><li>可以没有形参名，但是函数无法使用未命名的形参，即使形参未命名，也要传入实参。</li></ul><p><strong>返回类型</strong></p><ul><li>函数返回类型不能是<code>数组类型</code>或者<code>函数类型</code>.</li><li>但是可以是<code>数组指针</code>或<code>函数指针</code><h3 id="🎨6-1-1-局部对象"><a href="#🎨6-1-1-局部对象" class="headerlink" title="🎨6.1.1 局部对象"></a>🎨6.1.1 局部对象</h3></li><li><code>名字有作用域，对象有生命周期</code></li><li>形参和函数体<code>内部定义</code>的变量统称为<code>局部变量</code></li></ul><p><strong>形参属于自动对象</strong>：</p><ul><li>函数开始时为形参<code>申请存储空间</code>，因为形参定义在函数体作用域之内，<code>函数终止，形参被销毁</code></li><li>在所有函数外定义的对象存在于程序的整个执行过程中</li></ul><p><strong>局部静态变量</strong></p><ul><li>在程序的执行路径第一次经过对象定义语句时初始化，直到程序终止被销毁。</li><li>只存在于<code>块执行期间的对象</code>。当块的执行结束后，它的值就变成未定义的了。</li><li>如果想要局部变量声明周期在<code>整个程序结束</code>，可以将局部变量定义成<code>static类型</code></li><li>如果局部静态变量没有显式的初始值，将执行值初始化。</li></ul><h3 id="🎨6-1-2-函数声明"><a href="#🎨6-1-2-函数声明" class="headerlink" title="🎨6.1.2 函数声明"></a>🎨6.1.2 函数声明</h3><ul><li>函数的声明和定义唯一的区别是<code>声明无需函数体，用一个分号替代。</code></li><li>函数声明主要用于<code>描述函数的接口</code>，也称函数原型。</li><li><code>函数的声明无需形参的名字</code>（因为声明不包含函数体）。</li><li>函数的三要素：<code>返回类型</code>、<code>函数名</code>、<code>形参类型</code>。</li><li>建议在头文件中声明函数，在源文件中定义函数。<h3 id="🎨6-1-3-分离式编译"><a href="#🎨6-1-3-分离式编译" class="headerlink" title="🎨6.1.3 分离式编译"></a>🎨6.1.3 分离式编译</h3>分离式编译允许把程序分割到几个文件中，每个文件独立编译。</li></ul><h2 id="🎯6-2-参数传递"><a href="#🎯6-2-参数传递" class="headerlink" title="🎯6.2 参数传递"></a>🎯6.2 参数传递</h2><ul><li><strong>引用传递</strong>：又称传引用调用，指形参是<code>引用类型</code>，引用形参是它对应的实参的别名。</li><li><strong>值传递</strong>：又称传值调用，指实参的值是通过<code>拷贝</code>传递给形参。</li><li>形参初始化的机理和变量初始化一样。</li></ul><h3 id="🎨6-2-1-传值参数"><a href="#🎨6-2-1-传值参数" class="headerlink" title="🎨6.2.1 传值参数"></a>🎨6.2.1 传值参数</h3><ul><li>当初始化一个非引用类型的变量时，初始值被<code>拷贝</code>给变量。</li><li>函数对形参做的所有操作都<code>不会影响实参</code>。</li><li><strong>指针形参</strong>：C++建议使用<code>引用类型的形参代替指针</code>。</li></ul><h3 id="🎨6-2-2-传引用参数"><a href="#🎨6-2-2-传引用参数" class="headerlink" title="🎨6.2.2  传引用参数"></a>🎨6.2.2  传引用参数</h3><ul><li>通过使用引用形参，允许函数改变一个或多个实参的值。</li><li>通过引用可以避免拷贝(如果对象太长，可以使用引用来避免拷贝，拷贝太浪费内存了)</li><li><code>如果无需改变引用形参的值，最好将其声明为常量引用</code>。</li><li>引用形参直接关联到绑定的对象，而非对象的副本。</li><li><code>使用引用形参可以用于返回额外的信息。</code><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//既返回位置也返回次数，此时可以给函数传入一个额外的引用实参，令其保存字符出现的次数</span></span><br><span class="line"><span class="built_in">string</span>::size_type <span class="title function_">find_char</span><span class="params">(<span class="type">const</span> <span class="built_in">string</span> &amp;s, <span class="type">char</span> c, <span class="built_in">string</span>::size_type &amp;occurs)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">auto</span> size = s.size();</span><br><span class="line">occurs = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i != s.size(); i ++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (s[i] == c)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (ret == s.size()) ret = i;</span><br><span class="line">++ occurs;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ret;            <span class="comment">//出现次数通过occurs隐式地返回</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="🎨6-2-3-const-形参和实参"><a href="#🎨6-2-3-const-形参和实参" class="headerlink" title="🎨6.2.3 const 形参和实参"></a>🎨6.2.3 const 形参和实参</h3></li><li><code>实参初始化形参时以及进行拷贝时，都会忽略掉顶层const</code>,因此导致<code>void func (const int i)</code>;调用既可以传入<code>const int</code>也可以传入<code>int</code></li></ul><p><strong>加深理解</strong>：引用是没有顶层 const 的，因此顶层 const 适用于指针及其他类型，对于传值来说传递的是实参的副本，无论如何都不会改变实参，因此形参加不加顶层 const 都是一样的。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">fcn</span><span class="params">(<span class="type">const</span> <span class="type">int</span> i )</span>&#123; &#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">fcn</span><span class="params">(<span class="type">int</span> i )</span>&#123; &#125;         <span class="comment">//错误:重复定义了fcn(int)</span></span><br></pre></td></tr></table></figure><br><strong>指针或引用形参与const</strong></p><ul><li>使用非常量初始化一个底层const对象，但是反过来不行。</li><li>普通引用必须用同类型的对象初始化。</li></ul><p><strong>加深理解</strong>：不能把普通引用绑定到const 对象上，不能把普通的引用绑定在字面值上。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">reset</span><span class="params">(<span class="type">int</span> &amp;r)</span> &#123; &#125;;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> i = <span class="number">10</span>; </span><br><span class="line">reset(i);    <span class="comment">//错误：不能把普通引用绑定到const 对象上</span></span><br><span class="line">reset(<span class="number">42</span>);   <span class="comment">//错误：不能把普通的引用绑定在字面值上</span></span><br></pre></td></tr></table></figure><p><strong>尽量使用常量引用</strong></p><ul><li><code>尽量使用常量引用做形参</code>（注意常量引用的 const 是底层 const。）</li><li>可以用字面值初始化常量引用</li></ul><p><strong>使用常量引用的优点</strong>：</p><ol><li><code>想要调用引用版本的reset，只能使用int 类型对象。而不能使用字面值、求值结果为int 的表达式、需要转换的对象或者const int 类型的对象。</code></li><li>想要调用指针班的reset 只能使用 int *</li></ol><p><code>不能把 const 对象、字面值或需要类型转换的对象传递给普通的引用形参。但是可以传递给常量引用形参。</code></p><p><strong>注意</strong>: 如果函数 a 把形参定义为了常量引用，函数 b 形参是普通引用，那么不能在 a 中使用 b 调用该常量引用形参。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span>  <span class="title function_">is_sentence</span><span class="params">(<span class="type">const</span> <span class="built_in">string</span> &amp;s)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//如果在s的末尾有且只有一个句号，则s是一个句子</span></span><br><span class="line"><span class="built_in">string</span> :: size_type ctr = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> find_char(s, <span class="string">&#x27;.&#x27;</span>, ctr) == s.size() - <span class="number">1</span> &amp;&amp; ctr == <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">错误因为is_sentence是<span class="type">const</span>对象而find_char是普通对象</span><br></pre></td></tr></table></figure></p><h3 id="🎨6-2-4-数组形参"><a href="#🎨6-2-4-数组形参" class="headerlink" title="🎨6.2.4 数组形参"></a>🎨6.2.4 数组形参</h3><p>数组的两个特殊性质：<code>不允许拷贝数组、使用数组时常会将其转换成指针</code></p><ul><li>因为数组不能进行拷贝，所以无法使用值传递的方式使用数组参数。因为数组会被转换成指针，所实际上传递的是指向数组的首元素指针。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">print</span><span class="params">(<span class="type">const</span> <span class="type">int</span>*)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">print</span><span class="params">(<span class="type">const</span> <span class="type">int</span>[])</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">print</span><span class="params">(<span class="type">const</span> <span class="type">int</span>[<span class="number">10</span>])</span>;<span class="comment">//三种声明等价，数字 10 没有什么实际影响</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> i= <span class="number">0</span>, j[<span class="number">2</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>&#125;;</span><br><span class="line"><span class="built_in">printf</span>(&amp;i);               <span class="comment">//正确：&amp;i的类型是int *</span></span><br><span class="line"><span class="built_in">printf</span>(j);                <span class="comment">//正确：j转换成int * 并指向j[0]</span></span><br><span class="line">                       <span class="comment">//传入的是一个数组，那么实参会自动转换成指向数组首元素的指针</span></span><br></pre></td></tr></table></figure><p><strong>使用数组做形参确保数组访问不越界的方法：</strong></p><ul><li>使用一个结束标记指定数组已结束，典型代表为 C 风格字符串</li><li><code>传递指向数组首元素和尾后元素的指针</code></li><li><code>显示传递一个表示数组大小的形参</code></li></ul><p><strong>数组引用形参</strong></p><ul><li><code>可以定义数组的引用，但是没有引用数组，因为引用不是一个对象。注意数组的大小是构成数组类型的一部分</code></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">func(<span class="type">int</span> &amp;arr[<span class="number">10</span>]);  <span class="comment">//错误：arr 是引用的数组</span></span><br><span class="line">func(<span class="type">int</span> (&amp;arr)[<span class="number">10</span>]);<span class="comment">//正确：array 是包含 10 个整数的整型数组的引用</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> *arr[<span class="number">10</span>];        <span class="comment">//指针的数组</span></span><br><span class="line"><span class="type">int</span> (*arr)[<span class="number">10</span>];      <span class="comment">//指向数组的指针</span></span><br></pre></td></tr></table></figure><h3 id="🎨6-2-5-main-处理命令行选项"><a href="#🎨6-2-5-main-处理命令行选项" class="headerlink" title="🎨6.2.5 main:处理命令行选项"></a>🎨6.2.5 main:处理命令行选项</h3><ul><li><code>int main(int argc, char *argv[])&#123;...&#125;</code></li><li>第一个形参代表<code>数组中字符串的数量</code>；第二个形参argv是一个数组，<code>它的元素是指向C风格字符串的指针</code>。</li></ul><h3 id="🎨6-2-6-含有可变形参的函数"><a href="#🎨6-2-6-含有可变形参的函数" class="headerlink" title="🎨6.2.6 含有可变形参的函数"></a>🎨6.2.6 含有可变形参的函数</h3><p>无法预知应该向函数传递几个实参，处理不同数量实参的主要方法有俩种：</p><ul><li><code>如果所有实参类型相同，传递一个 initializer_list 类型</code></li><li><code>使用省略符形参，它可以传递可变数量的实参，注意它一般仅用于与 C 函数交互的接口程序</code></li></ul><p><strong>initializer_list 形参特点</strong></p><ul><li><code>initializer_list</code> 也是一种模板类型，定义在同名的头文件中。</li><li><code>initializer_list</code> 与 vector 容器大致相同，但是它的元素都是<code>常量值</code>。</li><li><code>initializer_list</code>对象<code>只能使用花括号初始化</code>。</li><li>C++ 里的 vector 等各类容器使用列表初始化时本质上都是通过一个采用了 initializer_list 形参的构造函数进行初始化的。</li></ul><div class="table-container"><table><thead><tr><th>操作</th><th>解释</th></tr></thead><tbody><tr><td><code>initializer_list&lt;T&gt; lst;</code></td><td>默认初始化；<code>T</code>类型元素的空列表</td></tr><tr><td><code>initializer_list&lt;T&gt; lst&#123;a,b,c...&#125;;</code></td><td><code>lst</code>的元素数量和初始值一样多；<code>lst</code>的元素是对应初始值的副本；列表中的元素是<code>const</code>。</td></tr><tr><td><code>lst2(lst)</code></td><td>拷贝或赋值一个<code>initializer_list</code>对象不会拷贝列表中的元素；拷贝后，原始列表和副本共享元素。</td></tr><tr><td><code>lst2 = lst</code></td><td>同上</td></tr><tr><td><code>lst.size()</code></td><td>列表中的元素数量</td></tr><tr><td><code>lst.begin()</code></td><td>返回指向<code>lst</code>中首元素的指针</td></tr><tr><td><code>lst.end()</code></td><td>返回指向<code>lst</code>中微元素下一位置的指针</td></tr></tbody></table></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">err_msg</span><span class="params">(ErrCode e, <span class="built_in">initializer_list</span>&lt;<span class="built_in">string</span>&gt; il)</span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; e.msg &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> bed = il.begin(); beg != il.end(); ++ beg)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *beg &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">err_msg(ErrCode(<span class="number">404</span>), &#123;<span class="string">&quot;functionX&quot;</span>, <span class="string">&quot;okay&#125;);</span></span><br></pre></td></tr></table></figure><p>如果向 initailizer_list 形参中传递一个值的序列，必须把序列放在花括号里。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">func</span><span class="params">(<span class="built_in">initializer_list</span>&lt;<span class="type">int</span>&gt; il)</span></span><br><span class="line"><span class="title function_">func</span><span class="params">(&#123;<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">2</span>&#125;)</span>;</span><br></pre></td></tr></table></figure></p><p><strong>省略符形参</strong></p><ul><li>省略符形参仅用于 C 和 C++ 通用的类型，大多数类类型的对象传递给省略符形参都无法正确拷贝。</li><li>省略符形参只能出现于形参列表的最后一个位置<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">func</span><span class="params">(parm_list,...)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">func</span><span class="params">(...)</span>;</span><br></pre></td></tr></table></figure></li></ul><h2 id="🎯6-3-返回类型和-return-语句"><a href="#🎯6-3-返回类型和-return-语句" class="headerlink" title="🎯6.3 返回类型和 return 语句"></a>🎯6.3 返回类型和 return 语句</h2><ul><li><code>与参数传递一样，不能返回数组，只能返回指向数组的指针或数组的引用</code></li></ul><p><strong>return 俩个作用：</strong></p><ul><li>返回 return 语句中的值</li><li>终止当前正在执行的函数，将控制权返回到调用该函数的地方</li></ul><h3 id="🎨6-3-1-无返回值函数"><a href="#🎨6-3-1-无返回值函数" class="headerlink" title="🎨6.3.1 无返回值函数"></a>🎨6.3.1 无返回值函数</h3><ul><li>没有返回值的 return语句只能用在返回类型是 void的函数中</li><li><code>返回 void的函数不要求非得有 return语句。因为它会在最后一句后面隐式地执行 return。</code></li></ul><h3 id="🎨6-3-2-有返回值函数"><a href="#🎨6-3-2-有返回值函数" class="headerlink" title="🎨6.3.2 有返回值函数"></a>🎨6.3.2 有返回值函数</h3><ul><li>return语句的返回值的类型<code>必须和函数的返回类型相同</code>，或者能够<code>隐式地转换成函数的返回类型</code>。</li><li><code>在含有 return 语句的循环和条件后面也应该有一条 return 语句</code>。</li><li>返回一个值和初始化一个变量或形参的方式一样，返回的值用于初始化调用点的变量。</li><li><code>不要返回局部对象的引用和指针</code></li></ul><p><strong>因为局部对象在函数调用完成后，他所占用的存储空间被释放，此时函数终止意味着局部变量的引用将指向不再有效的内存区域</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="built_in">string</span>&amp; <span class="title function_">func</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">string</span> s;</span><br><span class="line">s = <span class="string">&quot;xiaodainiao&quot;</span></span><br><span class="line">    <span class="keyword">return</span> s;          <span class="comment">//错误，字符串字面值转换成一个局部临时变量，不能返回局部对象的引用</span></span><br><span class="line">&#125;      </span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">str_cmp</span><span class="params">(<span class="type">const</span> <span class="built_in">string</span> &amp;str1, <span class="type">const</span> <span class="built_in">string</span> &amp;str2)</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i ++)</span><br><span class="line">   &#123;</span><br><span class="line">   <span class="keyword">if</span> (str[<span class="number">1</span>] != str[<span class="number">2</span>])</span><br><span class="line">   <span class="keyword">return</span>;               <span class="comment">//错误</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="literal">true</span>;              <span class="comment">//这个往往会被忽略，在含有 return 语句的循环和条件后面也应该有一条 return 语句</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>引用返回左值</strong></p><ul><li><code>返回引用的函数返回的是左值，其他返回类型得到右值</code>。</li><li><code>可以为返回类型是非常量引用的函数的结果赋值</code>。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> &amp;<span class="title function_">get_val</span><span class="params">(<span class="built_in">string</span> &amp;str, <span class="built_in">string</span>::size_type ix)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> str[ix];</span><br><span class="line">&#125;</span><br><span class="line">get_val(s,<span class="number">0</span>) = <span class="string">&#x27;A&#x27;</span>;</span><br></pre></td></tr></table></figure><p><strong>列表初始化返回值</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title function_">process</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">string</span> s;</span><br><span class="line">    <span class="keyword">if</span>(expected.empty())</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;<span class="comment">// 返回一个空 vector 对象</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(expected == actual)</span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="string">&quot;funcitonX&quot;</span>,<span class="string">&quot;okay&quot;</span>&#125;;<span class="comment">//返回一个列表初始化的 vector 对象    </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><strong>main 的返回值</strong></p><ul><li>如果结尾没有return，编译器将<code>隐式地插入一条返回0的return语句</code>。</li><li>返回0代表执行成功,返回其它值代表失败。</li><li><code>cstdlib</code>头文件定义了两个预处理变量来表示成功与失败<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> EXIT_FAILURE;<span class="comment">//失败</span></span><br><span class="line"><span class="keyword">return</span> EXIT_SUCCESS;<span class="comment">//成功</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="🎨6-3-3-返回数组指针"><a href="#🎨6-3-3-返回数组指针" class="headerlink" title="🎨6.3.3 返回数组指针"></a>🎨6.3.3 返回数组指针</h3><ul><li>函数不能返回数组，但是可以返回数组的指针或引用</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *p[<span class="number">10</span>];   <span class="comment">// 错误，指针的数组，p是一个含有10个指针的数组</span></span><br><span class="line"><span class="type">int</span> (*p)[<span class="number">10</span>]; <span class="comment">// 正确，数组的指针，p是一个指针，指向含有10个整数的数组</span></span><br><span class="line"><span class="type">int</span> &amp;p[<span class="number">10</span>];   <span class="comment">//错误，引用数组，引用不是对象，没有引用的数组，有数组的引用</span></span><br><span class="line"><span class="type">int</span> (&amp;p) [<span class="number">10</span>]; <span class="comment">// 正确，数组引用</span></span><br></pre></td></tr></table></figure><p><code>int（*function（int i ）[10]）;</code></p><ul><li><code>func(int i )</code>表示调用func函数需要传递一个int 实参</li><li><code>(*func(int i ))</code> 对函数调用的结果执行解引用</li><li><code>(*function(int i )[10])</code>表示解引用结果是一个大小为10的数组</li><li><code>int（*function（int i ）[10]）</code>表示数组中的元素是int 类型</li></ul><p><strong>有三种方法简化返回数组指针或引用。</strong></p><ul><li><code>使用类型别名</code></li><li><code>使用尾置返回类型</code></li><li><code>使用 decltype</code></li></ul><p><strong>使用类型别名</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> arrT[<span class="number">10</span>]; <span class="comment">// arrT 表示含有 10 个整数的数组</span></span><br><span class="line">using arrT = <span class="type">int</span>[<span class="number">10</span>]; <span class="comment">//等价声明</span></span><br><span class="line">arrT* <span class="title function_">func</span><span class="params">(<span class="type">int</span> i)</span>; <span class="comment">// 函数 func 返回一个指向含有 10 个整数的数组的指针</span></span><br></pre></td></tr></table></figure></p><p><strong>使用尾置返回类型</strong></p><ul><li>任何函数的定义都可以使用尾置返回，适用于返回类型<code>复杂的函数</code><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> <span class="title function_">func</span><span class="params">(<span class="type">int</span> i)</span> -&gt; <span class="title function_">int</span><span class="params">(*)</span>[10];</span><br><span class="line"><span class="comment">//func接受一个int 类型的实参，返回一个指针，该指针指向含有10个整数的数组</span></span><br></pre></td></tr></table></figure><strong>使用 decltype</strong></li><li>如果已知函数返回的指针将指向哪个数组，可以使用 decltype</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> odd[]=&#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">9</span>&#125;;</span><br><span class="line">decltype(odd)* func(<span class="type">int</span> i);<span class="comment">//返回一个数组指针</span></span><br></pre></td></tr></table></figure><p><strong>注意 decltype 的结果是一个数组，要想表示func返回指针还必须在函数声明时加一个<code>*</code>号。</strong></p><h2 id="🎯6-4-函数的重载"><a href="#🎯6-4-函数的重载" class="headerlink" title="🎯6.4 函数的重载"></a>🎯6.4 函数的重载</h2><ul><li>main 函数不能重载</li><li>函数<code>名字相同</code>，但是<code>形参数量</code>和<code>形参类型</code>不同，此时发生重载。</li><li>函数<code>返回值类型不同</code>，不是函数重载</li></ul><p><strong>重载和const形参</strong></p><ul><li>函数重载<code>无法区分顶层 const 形参和非顶层 const 形参</code>，但是可以区分底层 <code>const 形参与普通形参</code><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">func</span><span class="params">(<span class="type">int</span> i)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">func</span><span class="params">(<span class="type">const</span> <span class="type">int</span> i)</span>;<span class="comment">//顶层const，无法区分，相当于重复声明</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">func</span><span class="params">(<span class="type">int</span>* p)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">func</span><span class="params">(<span class="type">int</span>* <span class="type">const</span> p)</span>;<span class="comment">//顶层const，无法区分，相当于重复声明</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">func</span><span class="params">(<span class="type">int</span>* p)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">func</span><span class="params">(<span class="type">const</span> <span class="type">int</span>* p)</span>;<span class="comment">//底层const，可以区分，一个普通指针，一个常量指针</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">func</span><span class="params">(<span class="type">int</span>&amp; i)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">func</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp; i)</span>;<span class="comment">//底层const，可以区分，一个普通引用，一个常量引用</span></span><br></pre></td></tr></table></figure></li></ul><p><strong>const_cast</strong></p><ul><li>强制类型转化，可以将常量引用转换为非常量引用，也可以将非常量引用转换为常量引用</li><li>当要重载常量引用与非常量引用的版本时，<code>在非常量引用的版本中可以通过 const_cast 将参数和返回值从常量引用转换为非常量引用，以实现对常量引用版本的调用。</code></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span>&amp; s;</span><br><span class="line">const_cast &lt;<span class="type">const</span> <span class="built_in">string</span>&amp;&gt; (s);<span class="comment">// 将 s 转换为常量引用</span></span><br><span class="line">const_cast &lt;<span class="built_in">string</span>&amp;&gt; (s);<span class="comment">// 将 s 转换回非常量引用</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="built_in">string</span> &amp;<span class="title function_">str</span><span class="params">(<span class="type">const</span> <span class="built_in">string</span> &amp;s1, <span class="type">const</span> <span class="built_in">string</span> &amp;s2)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> s1.size() &gt; s2.size();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="built_in">string</span> &amp;<span class="title function_">str</span><span class="params">( <span class="built_in">string</span> &amp;s1,  <span class="built_in">string</span> &amp;s2)</span></span><br><span class="line"> &#123;</span><br><span class="line"> <span class="keyword">auto</span> &amp;r = str(const_cast&lt;<span class="type">const</span> <span class="built_in">string</span>&amp;&gt; (s1), const_cast&lt;<span class="type">const</span> <span class="built_in">string</span>&amp;&gt; (s2))</span><br><span class="line"> <span class="keyword">return</span> const_cast&lt;<span class="built_in">string</span>&amp;&gt; (r);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><ol><li>将实参转换为const的引用，然后调用str的const版本。</li><li>当返回时，因为返回类型是非常量引用，所以需要再次转换一下。</li></ol><h3 id="6-4-1-重载与作用域"><a href="#6-4-1-重载与作用域" class="headerlink" title="6.4.1 重载与作用域"></a>6.4.1 重载与作用域</h3><ul><li>不同的重载版本要定义在同一作用域中（一般都是全局）</li></ul><h2 id="🎯6-5-特殊用途语言特性"><a href="#🎯6-5-特殊用途语言特性" class="headerlink" title="🎯6.5 特殊用途语言特性"></a>🎯6.5 特殊用途语言特性</h2><h3 id="🎨6-5-1-默认实参"><a href="#🎨6-5-1-默认实参" class="headerlink" title="🎨6.5.1 默认实参"></a>🎨6.5.1 默认实参</h3><ul><li>一旦某个形参被赋予了默认值，那么它之后的形参都必须要有默认值。(反过来就是设置默认值的形参必须都放在没有默认值的形参后面。)<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> <span class="title function_">screen</span><span class="params">(sz ht = <span class="number">24</span>, sz wid = <span class="number">80</span>, <span class="type">char</span> backgrnd = <span class="string">&#x27; &#x27;</span>)</span>;</span><br></pre></td></tr></table></figure></li><li><code>如果想使用默认值实参时，只要在调用该函数的时候省略该实参就可以（默认实参负责填补函数调用时缺少的尾部实参。）</code></li><li><code>局部变量不能作为默认实参，全局变量和字面值都可以。</code></li><li>如果函数有默认实参，则调用函数时传入的实参数量可能少于它实际使用的实参数量</li><li><code>通常应该在函数声明中指定默认实参，并将该声明放在合适的头文件中</code>。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> <span class="title function_">screen</span><span class="params">(sz, sz, <span class="type">char</span> = <span class="string">&#x27; &#x27;</span>)</span>;</span><br><span class="line"><span class="built_in">string</span> <span class="title function_">screen</span><span class="params">(sz, sz ,<span class="type">char</span> = <span class="string">&#x27;*&#x27;</span>)</span>;   <span class="comment">//错误重复声明，不能修改已经存在的默认值</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="🎨6-5-2-内联函数和constexpr函数"><a href="#🎨6-5-2-内联函数和constexpr函数" class="headerlink" title="🎨6.5.2 内联函数和constexpr函数"></a>🎨6.5.2 内联函数和constexpr函数</h3><ul><li><code>内联函数可避免函数调用时的开销</code></li><li>内联函数适合于规模小、流程直接、频繁调用的函数。</li></ul><p><strong>使用函数的缺点</strong></p><ul><li><code>调用函数更慢</code>,调用前要先保存寄存器（保护现场），并在返回时恢复：可能需要拷贝实参；程序转向一个新的位置继续执行。</li></ul><p><strong>在函数前用 inline 声明一下即表明是内联函数</strong></p><h4 id="🎨constexpr函数"><a href="#🎨constexpr函数" class="headerlink" title="🎨constexpr函数"></a>🎨constexpr函数</h4><ul><li><code>只能用于常量表达式的函数。</code>但是 constexpr 函数不一定返回常量表达式。</li><li>constexpr int new_sz() {return 42;}</li><li><code>constexpr 函数的返回类型及所有的形参类型都必须是字面值类型，函数体中必须有且只有一条 return 语句</code></li><li><p>constexpr函数应该在头文件中定义。</p></li><li><p>应该把内联函数和constexpr函数的定义放到头文件里。</p><h2 id="🎯6-6-函数匹配"><a href="#🎯6-6-函数匹配" class="headerlink" title="🎯6.6 函数匹配"></a>🎯6.6 函数匹配</h2></li><li>重载函数匹配的三个步骤：<code>1.候选函数；2.可行函数；3.寻找最佳匹配。</code></li><li><strong>候选函数</strong>：选定本次调用对应的重载函数集，集合中的函数称为候选函数（candidate function）。</li><li><strong>可行函数</strong>：考察本次调用提供的实参，选出可以被这组实参调用的函数，新选出的函数称为可行函数</li><li><strong>寻找最佳匹配</strong>：基本思想：实参类型和形参类型越接近，它们匹配地越好。</li></ul><p><strong>调用重载函数应尽量避免强制类型转换。</strong></p><h3 id="🎨6-6-1-实参类型转换"><a href="#🎨6-6-1-实参类型转换" class="headerlink" title="🎨6.6.1 实参类型转换"></a>🎨6.6.1 实参类型转换</h3><p><strong>实参类型到形参类型的转换分为几个等级，具体排序如下：</strong></p><ol><li><strong>精确匹配</strong><br> 实参类型和形参类型相同<br> 从数组类型或函数类型转化为对应的指针类型<br> 向实参中添加顶层const或删除顶层const</li><li><strong>通过const转换实现的匹配。</strong></li><li><strong>通过类型提升实现的匹配</strong></li><li><strong>通过算术类型转换或指针转换实现的匹配</strong></li><li><strong>通过类类型转换实现的匹配</strong></li></ol><p>注意：所有算数类型转换的级别都一样。</p><h2 id="🎯6-7-函数指针"><a href="#🎯6-7-函数指针" class="headerlink" title="🎯6.7 函数指针"></a>🎯6.7 函数指针</h2><ul><li>函数指针指向的是函数而非对象</li><li><code>一种函数指针只能指向一种特定的函数类型：</code><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">Compare</span><span class="params">(<span class="type">const</span> <span class="built_in">string</span>&amp;, <span class="type">const</span> <span class="built_in">string</span>&amp;)</span>;  <span class="comment">// 此函数的类型是 bool(const string&amp;, const string&amp;);</span></span><br><span class="line"><span class="type">bool</span> (*pf)(<span class="type">const</span> <span class="built_in">string</span>&amp;, <span class="type">const</span> <span class="built_in">string</span>&amp;);    <span class="comment">// 声明了一个指向 bool(const string&amp;, const string&amp;) 类型函数的指针，注意括号不能少；</span></span><br><span class="line">pf = Compare;                                <span class="comment">// 给指针赋值，指向 Compare 函数</span></span><br><span class="line">pf = &amp;Compare;                               <span class="comment">// 这两种赋值语句完全等价</span></span><br><span class="line"><span class="type">bool</span> b1 = pf(<span class="string">&quot;hello&quot;</span>,<span class="string">&quot;goodbye&quot;</span>);             <span class="comment">// 可以直接使用指针替代函数名调用函数。</span></span><br><span class="line"><span class="type">bool</span> b2 = (*pf)(<span class="string">&quot;hello&quot;</span>,<span class="string">&quot;goodbye&quot;</span>);          <span class="comment">// 与上面的等价</span></span><br><span class="line"><span class="type">bool</span> b3 = Compare(<span class="string">&quot;hello&quot;</span>,<span class="string">&quot;goodbye&quot;</span>)         <span class="comment">//与上面等价</span></span><br></pre></td></tr></table></figure></li><li><code>当把函数名作为一个值使用时，函数自动地转换成指针</code>。</li><li>不同函数类型的指针间不能相互转换。函数指针也可以指向 <code>nullptr 或 0</code>。</li><li>对于重载函数，指针类型必须与重载函数中的某一个精确比配。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span>::size_type <span class="title function_">str</span><span class="params">(cosnt <span class="built_in">string</span>&amp;,<span class="type">const</span> strint&amp;)</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">str1</span><span class="params">(<span class="type">const</span> <span class="type">char</span>*, <span class="type">const</span> <span class="type">char</span>*)</span></span><br><span class="line">pf = <span class="number">0</span>;</span><br><span class="line">pf = str;      <span class="comment">//错误，返回类型不匹配</span></span><br><span class="line">pf = str1;     <span class="comment">//错误，形参类型不匹配</span></span><br><span class="line">pf = Compare;  <span class="comment">//正确，函数和指针类型精确匹配</span></span><br></pre></td></tr></table></figure><p><strong>函数指针形参</strong></p><ul><li><code>函数不能作形参，但是函数指针可以做形参，之后在调用时可以直接传入函数名作实参</code></li><li><code>函数名做形参也会自动的转换为指针。</code></li></ul><p><strong>类似于数组不能做形参，但是数组指针可以做形参</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">GetBigger</span><span class="params">(<span class="type">const</span> <span class="built_in">string</span>&amp; s1, <span class="type">const</span> <span class="built_in">string</span>&amp; s2, <span class="type">bool</span>(*comp)(<span class="type">const</span> <span class="built_in">string</span>&amp;, <span class="type">const</span> <span class="built_in">string</span>&amp;))</span>;  <span class="comment">// 函数指针做形参</span></span><br><span class="line">GetBigger(s1, s2, Compare);   <span class="comment">// 实参直接传入函数名 Compare </span></span><br></pre></td></tr></table></figure><p><strong>返回函数指针</strong></p><ul><li><code>不能返回一个函数，但是可以返回函数指针（注意这时函数名不会自动转换为函数指针）</code>。</li></ul><p><strong>类似于返回数组，数组不能返回，只能返回指向数组的指针</strong></p><ul><li>声明一个返回函数指针的函数有几种方法，其中直接声明最麻烦，使用尾置类型和 decltype 更简单一些，但是最好使用类型别名。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;直接声明&#x27;</span></span><br><span class="line"><span class="type">bool</span> (*f1(<span class="type">int</span>))(<span class="type">double</span>);       <span class="comment">// f1 是一个函数，函数的形参列表为 int，返回类型为函数指针。这个函数指针的类型为 bool (*)(double)，即形参为 double，返回类型为 bool。</span></span><br><span class="line"><span class="string">&#x27;使用尾置类型&#x27;</span></span><br><span class="line"><span class="keyword">auto</span> <span class="title function_">f1</span><span class="params">(<span class="type">int</span>)</span> -&gt; <span class="title function_">bool</span><span class="params">(*)</span><span class="params">(<span class="type">double</span>)</span>;</span><br><span class="line"><span class="string">&#x27;使用 decltype&#x27;</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">func</span><span class="params">(<span class="type">double</span>)</span>;</span><br><span class="line">decltype(func)* f1(<span class="type">double</span>);     </span><br><span class="line"><span class="string">&#x27;使用类型别名&#x27;</span></span><br><span class="line">using PF = <span class="type">bool</span>(*)(<span class="type">double</span>);</span><br><span class="line">PF <span class="title function_">f1</span><span class="params">(<span class="type">int</span>)</span>;</span><br></pre></td></tr></table></figure><p><strong>和数组的类似，可以进行对比</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> arrT[<span class="number">10</span>]; <span class="comment">// arrT 表示含有 10 个整数的数组</span></span><br><span class="line">using arrT = <span class="type">int</span>[<span class="number">10</span>]; <span class="comment">//等价声明</span></span><br><span class="line">arrT* <span class="title function_">func</span><span class="params">(<span class="type">int</span> i)</span>; <span class="comment">// 函数 func 返回一个指向含有 10 个整数的数组的指针</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> <span class="title function_">func</span><span class="params">(<span class="type">int</span> i)</span> -&gt; <span class="title function_">int</span><span class="params">(*)</span>[10];</span><br><span class="line"><span class="comment">//func接受一个int 类型的实参，返回一个指针，该指针指向含有10个整数的数组</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> odd[]=&#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">9</span>&#125;;</span><br><span class="line">decltype(odd)* func(<span class="type">int</span> i);<span class="comment">//返回一个数组指针</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> c++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c ++ primer 语句</title>
      <link href="/2022/06/28/post19/"/>
      <url>/2022/06/28/post19/</url>
      
        <content type="html"><![CDATA[<h1 id="🌔第5章-语句"><a href="#🌔第5章-语句" class="headerlink" title="🌔第5章 语句"></a>🌔第5章 语句</h1><h2 id="🌗5-1-简单语句"><a href="#🌗5-1-简单语句" class="headerlink" title="🌗5.1 简单语句"></a>🌗5.1 简单语句</h2><p><strong>表达式语句</strong></p><ul><li>一个表达式，末尾加上分号就变成了<code>表达式语句</code></li><li>表达式语句的作用是<code>执行表达式并丢弃掉求值结果</code><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ival + <span class="number">3</span>;    <span class="comment">//一条没有实际用处的表达式语句</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ival;<span class="comment">//一条有用的表达式语句</span></span><br></pre></td></tr></table></figure><strong>空语句</strong></li><li>空语句只含单独的一个分号</li></ul><p><code>用法</code>:</p><ul><li>用在<code>语法上需要一条语句但逻辑上不需要的地方</code>,此时用空语句</li><li>当循环的全部工作条件部分就可以完成时<code>使用空语句应该加上注释。</code><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">; <span class="comment">//空语句</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; s &amp;&amp; s != sought)</span><br><span class="line">    ;<span class="comment">//空语句</span></span><br></pre></td></tr></table></figure></li></ul><p><strong>复合语句（块）</strong></p><ul><li>复合语句是指用<code>&#123;&#125;</code>(花括号)括起来的语句和声明的序列，复合语句也被称作<code>块</code></li><li>一个块就是一个作用域</li><li>空块的作用等价于空语句</li></ul><p><code>用法</code></p><ul><li>语法上需要一条语句，但是逻辑上需要多条语句</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (val &lt;= <span class="number">10</span>)</span><br><span class="line">&#123;</span><br><span class="line">sum += val;</span><br><span class="line">++ val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="🌗5-2-语句作用域"><a href="#🌗5-2-语句作用域" class="headerlink" title="🌗5.2 语句作用域"></a>🌗5.2 语句作用域</h2><ul><li>可以在 if、switch、while、for 语句的控制结构内定义变量。。但是定义在控制结构当中的变量<code>只能在内部使用一旦语句结束，变量不可以使用</code></li><li>如果其他代码也需要访问控制变量，则变量必须定义在语句的外部。</li></ul><h2 id="🌗5-3-条件语句"><a href="#🌗5-3-条件语句" class="headerlink" title="🌗5.3 条件语句"></a>🌗5.3 条件语句</h2><p>条件语句分为俩种<code>if</code>语句和 <code>switch</code>语句。</p><h3 id="🌕5-3-1-if-语句"><a href="#🌕5-3-1-if-语句" class="headerlink" title="🌕5.3.1 if 语句"></a>🌕5.3.1 if 语句</h3><ul><li>if 语句有两种形式，一种有 else 分支，另一种没有。</li><li><code>使用 if 语句最好在所有的 if 和 else 之后都用花括号</code>。</li><li>悬垂else（dangling else）：用来描述在嵌套的<code>if else</code>语句中，如果<code>if</code>比<code>else</code>多时如何处理的问题。C++使用的方法是<code>else</code>匹配最近没有配对的<code>if</code>。<h3 id="🌕5-3-2-switch-语句"><a href="#🌕5-3-2-switch-语句" class="headerlink" title="🌕5.3.2 switch 语句"></a>🌕5.3.2 switch 语句</h3></li><li>switch 语句计算一个<code>整型表达式</code>的值，然后根据这个值从几条执行路径中选择一条。</li><li>case 关键字和它对应的值一起被称为 case 标签，<code>case 标签必须为整型常量表达式</code>。</li><li>default 也是一种特殊的 case 标签。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>(ch)&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;a&#x27;</span>: ++aCnt; <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;b&#x27;</span>: ++bCnt; <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> ival = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">switch</span>(ch)&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">3.14</span>; <span class="comment">//错误</span></span><br><span class="line"><span class="keyword">case</span> ival; <span class="comment">//错误</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>执行问题</code>:</p><ul><li>如果 某个 case 标签匹配成功后，程序将<code>从该 case 标签开始顺序执行所有case分支或者遇到break结尾</code></li><li>c++ 程序的形式比较自由，case 标签之后不一定要换行。</li><li><code>一条 case 后可以跟多条语句</code>，不必用花括号括起来。</li><li><code>一般在每个 case标签后都有一条 break 语句</code>。如果需要两个或多个值共享同一组操作，可以故意省略掉 break 语句。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> vowlCnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">switch</span>(ch)&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;a&#x27;</span>:</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;b&#x27;</span>:</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;c&#x27;</span>:</span><br><span class="line">++ vowelCnt;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span>(ch)&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;a&#x27;</span>: <span class="keyword">case</span> <span class="string">&#x27;b&#x27;</span>:</span><br><span class="line">        ++Cnt;</span><br><span class="line">        <span class="keyword">break</span>;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><code>注意</code>:</li><li><code>一般不要省略 case 分支最后的 break 语句</code>。如果没有 break 语句，最好注释一下。</li><li>如果没有任何一个 case 标签匹配 switch 表达式的值，就执行 default 分支。</li><li>即使不准备在 default 下做任何工作，最好也定义一个 default 标签。</li><li><code>如果要在 case 分支定义并初始化变量，应该定义在块内以约束其作用域</code>。</li></ul><h2 id="🌗5-4-迭代语句"><a href="#🌗5-4-迭代语句" class="headerlink" title="🌗5.4 迭代语句"></a>🌗5.4 迭代语句</h2><p>迭代语句有三种：while语句、for语句（范围for语句）、do while语句</p><h3 id="🌕5-4-1-while-语句"><a href="#🌕5-4-1-while-语句" class="headerlink" title="🌕5.4.1 while 语句"></a>🌕5.4.1 while 语句</h3><ul><li>while 的条件不能为空。条件部分可以是一个<code>表达式</code>或者是<code>一个带初始化的变量声明</code>。</li><li>定义在 while 条件部分或while循环体内的变量每次迭代都经历从创建到销毁的过程。</li><li>while 适合不确定到底迭代多少次的情况。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (condition)</span><br><span class="line">statement</span><br></pre></td></tr></table></figure><h3 id="🌕5-4-2-传统的for语句"><a href="#🌕5-4-2-传统的for语句" class="headerlink" title="🌕5.4.2 传统的for语句"></a>🌕5.4.2 传统的for语句</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(init-statement; condition; expression)</span><br><span class="line">    statement;</span><br></pre></td></tr></table></figure></li><li>init-statement 可以是<code>声明语句</code>、<code>表达式语句</code>或<code>空语句</code>。</li><li>init-statement 可以定义多个对象，但是<code>只能有一条声明语句</code>,因此所有的变量基础类型必须相同。</li><li>expression 在每次循环之后执行。</li><li>for 语句头能省略掉三者中的任意一个或全部。</li><li>省略 condition 等于条件恒为 true。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; n ;i++)</span><br><span class="line">statement</span><br><span class="line"><span class="title function_">for</span> <span class="params">(<span class="type">int</span> i = <span class="number">0</span>, <span class="type">char</span> j = <span class="string">&#x27;0&#x27;</span>; i &lt; n ;i++)</span>  <span class="comment">//错误</span></span><br></pre></td></tr></table></figure><h3 id="🌕5-4-3-范围for语句"><a href="#🌕5-4-3-范围for语句" class="headerlink" title="🌕5.4.3 范围for语句"></a>🌕5.4.3 范围for语句</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(declaration : expression)</span><br><span class="line">    statement</span><br></pre></td></tr></table></figure></li><li>范围 for 语句用来<code>遍历容器或其他序列的所有元素。</code></li><li>expression 表示的<code>必须是一个序列</code>，可以是<code>花括号括起来的初始值列表</code>。这些序列的共同的是都可以<code>返回迭代器的 begin 和 end 成员。</code></li><li>如果需要对容器中的元素执行<code>写操作</code>，必须将<code>循环变量声明成引用类型</code>。</li><li>declaration 定义一个能从序列中元素转换过来的<code>变量</code>（不是迭代器）。最简单的方法是使用<code>auto 类型说明符</code>。</li><li>范围 for 语句<code>不能</code>改变序列的元素数量(增加、删除)。因为范围for<code>预存了 end()</code> 的值，改变元素数量后 <code>end() 的值就可能失效了</code>。</li><li><code>每次迭代都会重新定义循环控制变量，并将其初始化为序列的下一个值。</code></li></ul><h3 id="🌕5-4-4-do-while-语句"><a href="#🌕5-4-4-do-while-语句" class="headerlink" title="🌕5.4.4 do while 语句"></a>🌕5.4.4 do while 语句</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span></span><br><span class="line">statement</span><br><span class="line"><span class="title function_">while</span> <span class="params">(condition)</span>;</span><br></pre></td></tr></table></figure><ul><li><code>do while</code>语句和<code>while</code>语句的唯一区别是do while语句先执行循环体后检查条件。<code>即至少执行一次循环。</code></li><li>do while 后<code>不要忘了加分号。</code></li><li>因为 condition 在循环体后面，所以 condition 使用的变量应该定义在循环体外面。<h2 id="🌗5-5-跳转语句"><a href="#🌗5-5-跳转语句" class="headerlink" title="🌗5.5 跳转语句"></a>🌗5.5 跳转语句</h2></li><li>四种跳转语句：<code>break</code>、<code>continue</code>、<code>return</code>、<code>go to</code>。</li></ul><h3 id="🌕5-5-1-break-语句"><a href="#🌕5-5-1-break-语句" class="headerlink" title="🌕5.5.1 break 语句"></a>🌕5.5.1 break 语句</h3><ul><li>break 语句负责终止离他最近的<code>while</code>、<code>do while</code>、<code>for</code> 或者 <code>switch</code> 语句，并从这些语句之后的第一条语句开始执行。</li><li>break 语句只能出现在迭代语句或者 switch 语句内部（包括嵌套在此类循环里的语句或块的内部）<h3 id="🌕5-5-2-continue-语句"><a href="#🌕5-5-2-continue-语句" class="headerlink" title="🌕5.5.2 continue 语句"></a>🌕5.5.2 continue 语句</h3></li><li>continue 语句终止最近的循环中的当前迭代并立即开始下一次迭代。</li><li>continue 只能出现在<code>for</code>、<code>while</code>、<code>do while</code>中，<code>比break少了一个switch</code>。</li></ul><h3 id="🌕5-5-3-goto语句"><a href="#🌕5-5-3-goto语句" class="headerlink" title="🌕5.5.3 goto语句"></a>🌕5.5.3 goto语句</h3><ul><li>goto 语句的作用是从 <code>goto 语句无条件跳转到同一函数内的另一条语句</code>。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">label : <span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">goto</span> label;</span><br></pre></td></tr></table></figure><ul><li>label 是用于<code>标识一条语句的标示符</code></li><li>标签标示符独立于变量或其他标示符的名字，标签标示符可以和程序中其他实体的标示符使用同一个名字而不会相互干扰。</li><li><code>如果 goto 语句跳回了一条变量的定义之前意味着系统将会销毁该变量，然后重新创建它。</code></li><li><code>不要使用 goto，它会令程序又难理解又难修改。</code></li></ul><h2 id="🌗5-6-try-语句块和异常处理"><a href="#🌗5-6-try-语句块和异常处理" class="headerlink" title="🌗5.6 try 语句块和异常处理"></a>🌗5.6 try 语句块和异常处理</h2><ul><li>异常是指存在于运行时的反常行为，典型的异常有失去数据库连接和遇到意外输入等。</li><li>当程序的某部分检测到一个它无法处理的问题时，需要用到异常处理。此时检测到问题的部分应该发出检测信号。<code>（它不需要处理异常，只需要用于检测异常）</code></li><li>如果程序里有可能引发异常的代码，通常需要有专门的代码处理问题。</li><li>c++中异常处理机制一般包括<code>异常检测</code>和<code>异常处理</code>俩部分协同完成。</li></ul><ol><li><code>throw 表达式：异常检测部分使用 throw 表达式来表示遇到了无法处理的问题。称为 throw 引发了异常。</code></li><li><code>try 语句块：异常处理部分使用 try 语句块处理异常。try 语句块以关键字 try 开始，并以一个或多个 catch 子句结束。</code></li><li><code>一套异常类：用于在 throw 表达式和相关的 catch 子句间传递异常的具体信息。</code></li></ol><h3 id="🌕5-6-1-throw-表达式"><a href="#🌕5-6-1-throw-表达式" class="headerlink" title="🌕5.6.1 throw 表达式"></a>🌕5.6.1 throw 表达式</h3><ul><li>throw 表达式包含关键字 <code>throw</code> 和<code>紧随其后的一个表达式</code>，表达式的类型就是抛出的异常类型。</li><li>throw 表达式后面紧跟一个分号。从而构成一条表达式语句。</li><li><code>throw只是用来检测异常，并不处理，处理交给try和catch语句。</code></li><li>throw 后面跟一个异常类型的对象（必须同时使用 string 或 C 风格字符串对其初始化）。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (item1.isbn() != item2.isbn())</span><br><span class="line">throw runtime_error(<span class="string">&quot;Data must refer to same ISBN&quot;</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; item1 + item2 &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure></li></ul><h3 id="🌕5-6-2-try-语句块"><a href="#🌕5-6-2-try-语句块" class="headerlink" title="🌕5.6.2 try 语句块"></a>🌕5.6.2 try 语句块</h3><ul><li><code>try</code> 语句块的一开始是<code>关键字try</code>,随后紧跟一个块。</li><li>跟在 <code>try</code> 块后面的是<code>一个或多个 catch 子句</code>。catch 子句包括三部分：<code>关键字 catch</code>、<code>括号内一个(可能未命名)的对象的声明（叫做异常声明）</code>、<code>一个块</code>。</li><li>try语句<code>块内</code>声明的变量在<code>块外部无法访问</code>，特别是在<code>catch子句也无法访问</code>。</li><li><code>当 try 语句块中抛出了一个异常，如果该异常类型与 catch 子句括号中的异常类型相同，就会执行该 catch 子句</code>。</li><li>catch 一旦完成，程序就跳转到 try 语句块最后一个 catch 子句之后的那条语句继续执行。</li><li>在 catch 后面的括号里使用省略号(…)可以让 catch 捕获所有类型的异常。</li><li><code>每个标准库异常类都有一个 what 成员函数，它没有参数，返回初始化该对象时所用的 C 风格字符串。</code><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; item1 &gt;&gt; item2)&#123;&#125;</span><br><span class="line">try&#123;</span><br><span class="line">   throw runtime_error(<span class="string">&quot;Data must be same as size&quot;</span>);<span class="comment">//try 语句块抛出了一个异常</span></span><br><span class="line">&#125;</span><br><span class="line">catch(runtime_error err)&#123;<span class="comment">//在 catch 后面的括号中声明了一个“runtime_error”类型的对象，与 try 抛出的异常类型相同，接下来执行此子句。</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; err.what()</span><br><span class="line">     &lt;&lt; <span class="string">&quot;\nTry Again? Enter y or n&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="type">char</span> c;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; c;</span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">cin</span> || c == <span class="string">&#x27;n&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">break</span>;   <span class="comment">//跳出while循环</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>异常运行结果<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">err.what()就是为了输出上面错误的信息<span class="string">&quot;Data must be same as size&quot;</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Data must refer to same ISBN</span><br><span class="line">Try Again? Enter y or n</span><br></pre></td></tr></table></figure></li></ul><p><strong>函数在寻找处理代码的过程中退出</strong></p><ul><li>throw 语句可能出现在<code>嵌套的 try 语句块中或在 try 语句块中调用的某个函数内</code>。当异常被抛出，<code>首先程序会从内到外一层层寻找相应类型的 catch 子句</code>。如果最后还是没找到，系统会调用<code>terminate 函数</code>并终止当前程序的执行。</li><li><code>如果对于 throw 语句外就没有 try 语句块，也会执行 terminate 函数</code>。</li></ul><p><strong>编写异常代码非常困难</strong></p><ul><li>异常中断了程序的正常流程。异常发生时，<code>有的程序执行完成有的程序执行到一半就中断了</code>，c此时会导致<code>资源没有正常释放</code>，<code>对象处于无效状态</code>等情况。异常安全的代码要求在异常发生时能正确执行清理工作。这个非常困难。<h3 id="🌕5-6-3-标准异常"><a href="#🌕5-6-3-标准异常" class="headerlink" title="🌕5.6.3 标准异常"></a>🌕5.6.3 标准异常</h3>C++ 标准库定义了<code>一组异常类</code>，用于报告标准库函数遇到的问题。他们<code>定义在 4 个头文件中</code>。</li><li>定义在<code>stdexcept 头文件</code>中的类型必须使用 string 对象或 C 风格字符串来初始化他们。<code>不允许使用默认初始化方式</code>。</li><li>其他 3 个头文件中的 3 中类型则<code>只能默认初始化，不能提供初始值。</code></li><li>异常类型<code>只有一个 what 成员函数</code>，该函数<code>没有参数</code>，返回是一个 <code>C 风格字符串的指针</code>，目的是提供关于异常的文本信息。</li><li>对于无初始值的异常类型，what 返回的内容由编译器决定，有初始值的返回初始值。</li></ul><div class="table-container"><table><thead><tr><th style="text-align:center">exception</th><th style="text-align:center">异常类 exception 是最通用的异常类。它只报告异常      的发生，不提供额外信息。</th></tr></thead><tbody><tr><td style="text-align:center"><strong>bad_alloc</strong></td><td style="text-align:center"><strong>异常类 bad_alloc。在使用 new 分配动态内存失败时抛出</strong></td></tr><tr><td style="text-align:center"><strong>bad_cast</strong></td><td style="text-align:center"><strong>异常类型 bad_cast。经常发生在使用 dynamic_cast 时发生</strong></td></tr><tr><td style="text-align:center"><strong>exception</strong></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"><strong>runtime_error</strong></td><td style="text-align:center"><strong>只有在运行时才能检测出的问题</strong></td></tr><tr><td style="text-align:center"><strong>range_error</strong></td><td style="text-align:center"><strong>运行时错误：生成的结果超出了有意义的值域范围</strong></td></tr><tr><td style="text-align:center"><strong>overflow_error</strong></td><td style="text-align:center"><strong>运行时错误：计算上溢</strong></td></tr><tr><td style="text-align:center"><strong>underflow_error</strong></td><td style="text-align:center"><strong>运行时错误：计算下溢</strong></td></tr><tr><td style="text-align:center"><strong>logic_error</strong></td><td style="text-align:center"><strong>程序逻辑错误</strong></td></tr><tr><td style="text-align:center"><strong>domain_error</strong></td><td style="text-align:center"><strong>逻辑错误：参数对象的结果值不存在</strong></td></tr><tr><td style="text-align:center"><strong>invalid_argument</strong></td><td style="text-align:center"><strong>逻辑错误：无效参数</strong></td></tr><tr><td style="text-align:center"><strong>length_error</strong></td><td style="text-align:center"><strong>逻辑错误：试图创建一个超出该类型最大长度的对象</strong></td></tr><tr><td style="text-align:center"><strong>out_of_range</strong></td><td style="text-align:center"><strong>逻辑错误：使用一个超出有效范围的值</strong></td></tr></tbody></table></div><ul><li><code>exception头文件</code> 定义了<code>exception</code>。</li><li><code>new头文件</code>定义了<code>bad_alloc</code>。</li><li><code>type_info头文件</code>定义了<code>bad_cast</code>。</li><li>其余的都定义在<code>stdexcept头文件</code>。</li></ul><p><strong>上面的异常类之间存在继承关系，其中 exception 是所有其他类的基类，总的继承关系如下图</strong></p><p><img src="https://img-blog.csdnimg.cn/76cc45326e26430cb13aec86f4e4345e.png" alt="在这里插入图片描述"><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">StrBlob::check</span><span class="params">(size_type i, <span class="type">const</span> <span class="built_in">string</span>&amp; msg)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (i &gt;= data-&gt;size())</span><br><span class="line">        throw out_of_range(msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> c++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c ++ primer 表达式</title>
      <link href="/2022/06/23/post18/"/>
      <url>/2022/06/23/post18/</url>
      
        <content type="html"><![CDATA[<h1 id="⛄️第4章-表达式"><a href="#⛄️第4章-表达式" class="headerlink" title="⛄️第4章 表达式"></a>⛄️第4章 表达式</h1><h2 id="☔️4-1-基础"><a href="#☔️4-1-基础" class="headerlink" title="☔️4.1 基础"></a>☔️4.1 基础</h2><h3 id="❄️4-1-1-基本概念"><a href="#❄️4-1-1-基本概念" class="headerlink" title="❄️4.1.1 基本概念"></a>❄️4.1.1 基本概念</h3><p><strong>运算对象转换</strong></p><ul><li><code>小整数类型（如bool、char、short等）通常会被提升成较大的整数类型，主要是 int 型</code></li><li>一般在进行二元运算符时，即使俩个数类型不一样，只要他们可以相互准换为同一个类型就可以。</li><li>运算符作用于类类型的运算对象时，用户可以自行定义其含义。这种做法称之为<code>重载运算符</code></li></ul><p><strong>左值和右值</strong></p><ul><li>c中左值可以位于赋值语句的左侧，而右值不行</li><li>c ++ 表达式<code>要么是左值，要么是右值</code></li><li>左值：当一个对象被用作左值时，用的是<code>对象的身份（在内存中的位置）</code></li><li>右值：当一个对象被用作右值时，用的是<code>对象的值（内容）</code></li></ul><p>需要右值的地方可以被左值代替，但是不能把右值当成左值（也就是位置）使用。</p><ul><li>使用关键字 decltype 时，如果表达式的求值结果是左值，decltype 作用于该表达式（不是变量）得到一个引用类型。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">例如</span><br><span class="line"><span class="type">int</span> *p;</span><br><span class="line">decltype(*p)的结果是<span class="type">int</span>&amp;;</span><br></pre></td></tr></table></figure><ul><li>运算符对于作用对象是左值还是右值会有要求，比如赋值运算符的左侧运算对象必须是左值。</li></ul><h3 id="❄️4-1-2-优先级与结合律"><a href="#❄️4-1-2-优先级与结合律" class="headerlink" title="❄️4.1.2 优先级与结合律"></a>❄️4.1.2 优先级与结合律</h3><ul><li>左结合律：如果运算符优先级相同，按照从左向右的顺序组合运算对象。</li><li>大部分二元运算符满足左结合律，赋值运算符满足右结合律。<h3 id="❄️4-1-3-求值顺序"><a href="#❄️4-1-3-求值顺序" class="headerlink" title="❄️4.1.3 求值顺序"></a>❄️4.1.3 求值顺序</h3></li><li>优先级规定了运算对象的组合方式，但是并没有规定运算对象按照什么顺序求值。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = f1() * f2();</span><br><span class="line">函数f1和函数f2一定会在乘法之前调用，但是到底是f1()在f2()之前调用还是，之后调用，不确定</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li>对于没有指定执行顺序的运算符，如果表达式指向并修改了同一个对象，那么将会发生错误<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;&quot;</span>&lt;&lt; ++i &lt;&lt; end;<span class="comment">//错误！未定义的行为，不知道先求 i 还是先求 ++i</span></span><br></pre></td></tr></table></figure><strong>处理复合语句</strong></li></ul><ol><li>不确定优先级与结合律的情况下，强制用括号</li><li><p><code>如果改变了某个运算对象的值，在同一表达式中不要再使用该运算对象。</code></p><h2 id="☔️4-2-算术运算符"><a href="#☔️4-2-算术运算符" class="headerlink" title="☔️4.2 算术运算符"></a>☔️4.2 算术运算符</h2><p>算术运算符(左结合律),有三种</p></li><li><p>+、- ：一元正号与一元负号</p></li><li>*、/、% ：乘法、除法、求余</li><li>+、- ：加法、减法</li></ol><ul><li>上面的所有运算符，都满足左结合律，意味着优先级相同，按照从左向右的顺序进行组合。</li><li><code>整数除法的结果是向0取整</code></li><li>求余运算的运算对象必须是整数，运算结果始终与被除数符号相同<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">-21</span> % <span class="number">-8</span> = <span class="number">-5</span></span><br><span class="line"><span class="number">21</span> % <span class="number">-5</span> = <span class="number">1</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="☔️4-3-逻辑和关系运算符"><a href="#☔️4-3-逻辑和关系运算符" class="headerlink" title="☔️4.3 逻辑和关系运算符"></a>☔️4.3 逻辑和关系运算符</h2><ul><li>逻辑运算符：！、&amp;&amp;、||</li><li>关系运算符：&lt;, &lt;=, &gt;, &gt;=, !=, == </li><li>逻辑运算符与关系运算符的求值结果都是<code>布尔值</code>。</li><li><code>短路求值</code>：逻辑与运算符和逻辑或运算符都是先求左侧运算对象的值再求右侧运算对象的值，当且仅当左侧运算对象无法确定表达式的结果时才会计算右侧运算对象的值。<code>先左再右</code></li><li>声明为引用类型可以避免对元素的拷贝，如下，如string特别大时可以节省大量时间。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; text;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">const</span> <span class="keyword">auto</span> &amp;s: text)&#123;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><strong>注意：如果想要测试一个算术对象或者指针对象的真值，最直接的方法是将其作为 if 语句的条件，不要与布尔值进行比较。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(a);<span class="comment">//正确   只要a 是 正数，则为真</span></span><br><span class="line"><span class="keyword">if</span>(a == <span class="literal">true</span>);<span class="comment">//错误：会将 true 先转换为 int 再比较，比较结果是不相等（只有a = 1时才为真）</span></span><br></pre></td></tr></table></figure><h2 id="☔️4-4-赋值运算符"><a href="#☔️4-4-赋值运算符" class="headerlink" title="☔️4.4 赋值运算符"></a>☔️4.4 赋值运算符</h2><ul><li>赋值运算的<code>返回结果时它的左侧运算对象</code>，且是一个<code>左值</code>。类型也就是左侧对象的类型。</li><li>如果赋值运算的左右侧运算对象类型不同，则右侧运算对象将转换成左侧运算对象的类型。</li><li>赋值运算符满足右结合律</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i, j;</span><br><span class="line">i = j = <span class="number">1</span>;<span class="comment">//正确，j 被赋值为 1，随后i 被赋值为 j 的值。</span></span><br><span class="line">等价于</span><br><span class="line">i = (j = <span class="number">1</span>)；</span><br></pre></td></tr></table></figure><ul><li>赋值运算优先级<code>比较低</code>，在条件语句中，赋值部分通常应该<code>加上括号</code></li><li>复合赋值运算符，复合运算符只求值一次，普通运算符求值两次。</li><li>位运算也可以使用赋值运算符。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">+=; -=; *=; /=; %=; &lt;&lt;=; &gt;&gt;=; &amp;=; ^=; |=;</span><br><span class="line"></span><br><span class="line">例如a = a + <span class="number">1</span>; 需要进行俩次运算</span><br><span class="line">而  a += <span class="number">1</span>; 只需要进行一次运算</span><br></pre></td></tr></table></figure><h2 id="☔️4-5-递增和递减运算符"><a href="#☔️4-5-递增和递减运算符" class="headerlink" title="☔️4.5 递增和递减运算符"></a>☔️4.5 递增和递减运算符</h2><p>递增和递减运算符有俩种形式：</p><ul><li>前置版本：++i  ,得到递增之后的值。(先 +1，在运算)</li><li>后置版本：i++，得到递增之前的值。(先运算，在 +1)</li></ul><p>前置版本将对象本身作为左值返回，后置版本将对象的原始值的副本返回。<br><code>非必须，不要使用后置版本</code>原因有俩点：</p><ol><li>前置版本直接返回改变了的运算对象，后置版本需要将原始值保存下来以便于返回，是一种浪费。</li><li>后置版本对于整数和指针来说影响不大，但是对于迭代器而言消耗巨大。</li></ol><p><strong>在一条语句中混用解引用和递增运算符</strong></p><p><code>pbeg++ 等价于 *(pbeg++)</code></p><ul><li><strong>pbeg++,把pbeg的值加1，然后返回pbeg的初始值的副本作为其求值结果。</strong></li><li>递增运算符优先级高于解引用，所以不用加括号</li><li>建议这样写，比较简约<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">auto</span> pbeg = v.begin();</span><br><span class="line"><span class="keyword">while</span>(pbeg != v.end())</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; *pbeg++ &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><h2 id="☔️4-6-成员访问"><a href="#☔️4-6-成员访问" class="headerlink" title="☔️4.6 成员访问"></a>☔️4.6 成员访问</h2></li><li><code>点运算符</code>和<code>箭头运算符</code>都可以访问成员。</li><li><code>.</code>运算符的优先级大于<code>*</code>，所以要记得加括号</li><li><code>ptr-&gt;mem</code>等价于<code>(*ptr).mem</code></li></ul><h2 id="☔️4-7-条件运算符"><a href="#☔️4-7-条件运算符" class="headerlink" title="☔️4.7 条件运算符"></a>☔️4.7 条件运算符</h2><ul><li>条件运算符(<code>?:</code>)，允许我们把简单的的<code>if-else</code>逻辑嵌入到单个表达式当中，条件运算符的格式为<code>cond ? expr1: expr2;</code></li><li>可以使用嵌套条件运算符</li><li><code>条件运算符优先级比较低，一般要加括号</code><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> final = (grade &gt; <span class="number">90</span>) ? <span class="string">&quot;high pass&quot;</span>:(grade &lt; <span class="number">60</span>)? <span class="string">&quot;fail&quot;</span>:<span class="string">&quot;pass&quot;</span> </span><br></pre></td></tr></table></figure></li></ul><h2 id="☔️4-8-位运算符"><a href="#☔️4-8-位运算符" class="headerlink" title="☔️4.8 位运算符"></a>☔️4.8 位运算符</h2><p>位运算符作用于<code>整数类型</code>的对象，并把运算符对象看成是<code>二进制位</code>的集合。</p><div class="table-container"><table><thead><tr><th style="text-align:center">运算符</th><th style="text-align:center">功能</th></tr></thead><tbody><tr><td style="text-align:center">~</td><td style="text-align:center">位求反</td></tr><tr><td style="text-align:center">&lt;&lt;</td><td style="text-align:center">左移</td></tr><tr><td style="text-align:center">&gt;&gt;</td><td style="text-align:center">右移</td></tr><tr><td style="text-align:center">&amp;</td><td style="text-align:center">位与</td></tr><tr><td style="text-align:center">^</td><td style="text-align:center">位异或</td></tr><tr><td style="text-align:center">!</td><td style="text-align:center">位或</td></tr></tbody></table></div><ul><li>如果运算对象是“小整型”，值会被自动提升为较大的整数类型。</li><li>运算对象可以带符号，也可以不带符号。<code>不带符号的运算结果是固定的，带符号的运算结果依赖于机器。</code></li><li><code>左移操作可能会改变符号位的值，因此在c++中建议仅用位运算来处理无符号类型</code></li></ul><p><strong>移位运算符</strong></p><ul><li>使用移位运算符，移动的位数必须严格小于结果的位数。否则产生未定义的行为。</li><li><code>&gt;&gt;</code>右移运算符处理<code>无符号数</code>时，相当于在左侧插入0，右侧移出边界的值舍弃</li><li><code>&lt;&lt;</code>左移运算符处理<code>无符号数</code>时，相当于在右侧插入0，左侧移出边界的值舍弃</li></ul><p>对于有符号位：</p><ul><li><code>&lt;&lt;</code>左移运算符，相当于在右侧插入值为0的二进制位</li><li><code>&gt;&gt;</code>右移运算符：如果该运算对象是无符号类型，相当于在左侧插入值为0的二进制位。如果有符号类型，在左侧插入符号的副本或值为0的二进制位，具体看环境<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">移位运算符满足左结合律</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; a &lt;&lt; b &lt;&lt; <span class="built_in">endl</span>;  </span><br><span class="line">((<span class="built_in">cout</span> &lt;&lt; a) &lt;&lt;b ) &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><h2 id="☔️4-9-sizeof运算符"><a href="#☔️4-9-sizeof运算符" class="headerlink" title="☔️4.9 sizeof运算符"></a>☔️4.9 sizeof运算符</h2></li><li><code>sizeof</code>返回一条表达式或一个类型名字所占的字节数，返回值是<code>size_t</code>类型</li><li>sizeof 满足右结合律</li><li>sizeof并<code>不实际计算其运算对象的值</code>。</li></ul><p><strong>sizeof有俩种形式：</strong></p><ul><li>sizeof (type)，给出类型名</li><li>sizeof expr，给出表达式<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Sales_data data *p;</span><br><span class="line"><span class="keyword">sizeof</span> p;          <span class="comment">//指针所占空间大小</span></span><br><span class="line"><span class="keyword">sizeof</span> *p          <span class="comment">//P所指类型的大小，例如int * p ;此时p的大小就是int 类型的大小</span></span><br></pre></td></tr></table></figure></li><li>对数组执行 sizeof 运算符得到的是整个数组所占空间的大小。不会把数组转换为指针来处理。</li><li>但是对指针执行 sizeof 运算符得到的是指针类型的大小，也就是 8。</li><li>对 string 或 vector 对象执行 sizeof 运算只返回该类型固定部分的大小，不会计算对象中的元素占了多少空间。</li><li>可以用 sizeof 获得数组中元素的个数：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> ia[<span class="number">10</span>];</span><br><span class="line"><span class="comment">// sizeof(ia)返回整个数组所占空间的大小</span></span><br><span class="line"><span class="comment">// sizeof(ia)/sizeof(*ia)返回数组的大小</span></span><br><span class="line">constexpr <span class="type">size_t</span> sz = <span class="keyword">sizeof</span>(ia)/<span class="keyword">sizeof</span>(*ia);</span><br><span class="line"><span class="type">int</span> arr[sz];</span><br></pre></td></tr></table></figure></li></ul><h2 id="☔️4-10-逗号运算符"><a href="#☔️4-10-逗号运算符" class="headerlink" title="☔️4.10 逗号运算符"></a>☔️4.10 逗号运算符</h2><ul><li><p>按照从左向右顺序依次求值。</p></li><li><p>左侧求值结果丢弃，逗号运算符结果是右侧表达式的值。</p></li><li>在 for 循环中可以用逗号分隔两个不同的条件</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i!=n; i++,j++)</span><br></pre></td></tr></table></figure><p><code>注意不要在判断条件那里使用逗号分隔不同的条件，那样只会返回逗号分隔的最后一个表达式的值。</code></p><h2 id="☔️4-11-类型转换"><a href="#☔️4-11-类型转换" class="headerlink" title="☔️4.11 类型转换"></a>☔️4.11 类型转换</h2><p>在c++中，如果参加运算的俩个对象是不同类型的。则会<code>通过类型转换把，把俩个对象统一一下类型，在进行计算</code></p><p><strong>隐式类型转换</strong></p><ul><li>比 int 类型小的整型值首先提升为较大的整数类型</li><li>在条件里，把非布尔值转换成布尔值</li><li>初始化中，初始值转换成变量的类型。</li><li>赋值时，右侧运算对象转换成左侧类型</li><li>算数运算或关系运算的运算对象有多种类型，转换成一种。</li><li>函数调用时也会有转换。</li></ul><h3 id="❄️4-11-1-算术转换"><a href="#❄️4-11-1-算术转换" class="headerlink" title="❄️4.11.1 算术转换"></a>❄️4.11.1 算术转换</h3><p>将运算符中的运算对象，转换为<code>最宽的类型</code>。例如：当表达式中既有浮点数也有整数时。整数值将准换成相应的浮点类型</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> c = <span class="number">3</span> + <span class="string">&#x27;a&#x27;</span>;<span class="comment">//先将&#x27;a&#x27;提升成 int，然后把 int 转换成 double</span></span><br></pre></td></tr></table></figure><p><strong>整数提升</strong></p><p><code>整数提升负责把小整数转换成为较大的整数类型。</code><br>例如:(bool, short, char等),只要他们所有的可能的值都能存在<code>int</code> 里，他们就会提升成 <code>int</code>类型</p><p><strong>无符号类型的运算对象</strong></p><ul><li>如果一个是无符号一个带符号。如果无符号类型不小于带符号类型（比如都是 4 字节），则带符号转换为无符号</li><li>如果无符号类型小于带符号，转换结果依赖机器。尽量不使用。</li></ul><h3 id="❄️4-11-2-其他隐式类型转换"><a href="#❄️4-11-2-其他隐式类型转换" class="headerlink" title="❄️4.11.2 其他隐式类型转换"></a>❄️4.11.2 其他隐式类型转换</h3><p><strong>数组转换为指针</strong></p><ul><li>大多数情况下数组会自动转换成指向数组首元素的指针。（decltype关键字参数、取地址符(&amp;)、sizeof、typeid 都不会发生这种转换）</li></ul><p><strong>指针的转换</strong></p><ul><li><code>整数0</code>或 <code>nullptr</code> 都能转换成任意指针类型。</li><li>指向非常量的指针能转换成 void<em>。指向所有对象的指针都能转换成 const void</em>。</li></ul><p><strong>转换成常量</strong><br>允许将指向<code>非常量类型的指针</code>转换成指向相应的<code>常量类型</code>指针。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;j = i;   <span class="comment">//非常量转换为const int 引用</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> *p = &amp;i;   <span class="comment">//非常量地址转换为const 的地址</span></span><br><span class="line"><span class="type">int</span> &amp;r = j, *q = p;  <span class="comment">//错误：不允许const转换为非常量</span></span><br></pre></td></tr></table></figure><br><strong>类类型定义的转换</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> s = <span class="string">&quot;value&quot;</span>;<span class="comment">//将 c 风格字符串字面值转换为 string类型</span></span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;s);     <span class="comment">//将 cin 转换为 bool 值</span></span><br></pre></td></tr></table></figure></p><h3 id="❄️4-11-3-显示转换"><a href="#❄️4-11-3-显示转换" class="headerlink" title="❄️4.11.3 显示转换"></a>❄️4.11.3 显示转换</h3><p><code>显示准换就是强制转换</code></p><p><strong>强制转换的具体格式：</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">castname&lt;type&gt;(expression);</span><br></pre></td></tr></table></figure><br><strong>castname有四种：</strong></p><ul><li>static_cast</li><li>dynamic_cast</li><li>const_cast</li><li>reinterpret_cast </li></ul><p><strong>static_cast</strong></p><ul><li><p><code>任何类型转换，只要不包含底层 const，都可以用 static_cast</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> slope = static_cast&lt;<span class="type">double</span>&gt;(j)/i; <span class="comment">//将 j 转换成 double 以便执行浮点数除法</span></span><br></pre></td></tr></table></figure></li><li><p><strong>当把较大的类型转换为较小的类型时，static_cast 很有用。这时它告诉读者和编译器：我们知道且不在乎精度损失。平时编译器会给警告，显式转换后就不警告了。</strong></p></li></ul><p><strong>const_cast</strong></p><ul><li>const_cast 只能改变对象的底层 const。可以去掉或增加 const 性质。</li><li>只有 const_cast 能改变表达式的常量属性，其他都不行。</li><li>cosnt_cast 常用于有函数重载的上下文中。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span>&amp; s;</span><br><span class="line">const_cast &lt;<span class="type">const</span> <span class="built_in">string</span>&amp;&gt; (s);<span class="comment">// 将 s 转换为常量引用</span></span><br><span class="line">const_cast &lt;<span class="built_in">string</span>&amp;&gt; (s);<span class="comment">// 将 s 转换回非常量引用</span></span><br></pre></td></tr></table></figure></li></ul><p><strong>reinterpret_cast</strong></p><p><code>不要用它。</code></p><p><strong>旧式的强制类型转换</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>(a);<span class="comment">// 函数形式的强制类型转换</span></span><br><span class="line">(<span class="type">int</span>)a;<span class="comment">// c 语言风格的强制类型转换</span></span><br></pre></td></tr></table></figure></p><ul><li>旧式的强制类型转换本质上采用 const_cast、static_cast 或 reinterpret_cast 的一种。</li><li>旧式与新式相比没那么清晰明了，如果出现问题，追踪困难。</li></ul><h2 id="☔️4-12-运算符优先级（省略p147）"><a href="#☔️4-12-运算符优先级（省略p147）" class="headerlink" title="☔️4.12 运算符优先级（省略p147）"></a>☔️4.12 运算符优先级（省略p147）</h2>]]></content>
      
      
      <categories>
          
          <category> c++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL执行一条select过程</title>
      <link href="/2022/06/18/post17/"/>
      <url>/2022/06/18/post17/</url>
      
        <content type="html"><![CDATA[<h1 id="MySQL执行流程如下："><a href="#MySQL执行流程如下：" class="headerlink" title="MySQL执行流程如下："></a>MySQL执行流程如下：</h1><p>图片来源于<a href="https://www.xiaolincoding.com/">https://www.xiaolincoding.com/</a><br><img src="https://img-blog.csdnimg.cn/8b2fadcd47f2460eb1fbce515d94c517.png" alt="在这里插入图片描述"> <code>MySQL 的架构共分为两层：Server 层和存储引擎层</code></p><ul><li><code>Server 层</code>负责建立连接、分析和执行 SQL。MySQL 大多数的核心功能模块都在这实现，主要包括连接器，查询缓存、解析器、预处理器、优化器、执行器等。</li><li><code>存储引擎层</code>负责数据的存储和提取。</li></ul><h2 id="流程如下："><a href="#流程如下：" class="headerlink" title="流程如下："></a><code>流程如下</code>：</h2><ul><li><strong>连接器</strong>：建立连接，管理连接、校验用户身份；</li><li><strong>查询缓存</strong>：查询语句如果命中查询缓存则直接返回，否则继续往下执行。MySQL 8.0 已删除该模块；</li><li><strong>解析器:</strong> 解析 SQL，通过解析器对 SQL 查询语句进行词法分析、语法分析，然后构建语法树，方便后续模块读取表名、字段、语句类型；</li><li><p>执行 SQL：执行 SQL 共有三个阶段：</p><ul><li><strong>预处理器：</strong> 检查表或字段是否存在；将 select <em> 中的 </em> 符号扩展为表上的所有列。</li><li><strong>优化器：</strong> 基于查询成本的考虑， 选择查询成本最小的执行计划；</li><li><strong>执行器：</strong> 根据执行计划执行 SQL 查询语句，从存储引擎读取记录，返回给客户端；</li></ul></li><li><p><strong>存储引擎：</strong> 存储数据、提供读写接口。</p></li></ul><h2 id="连接器"><a href="#连接器" class="headerlink" title="连接器"></a>连接器</h2><p><code>流程：</code></p><ul><li>与客户端进行 TCP 三次握手建立连接；</li><li>校验客户端的用户名和密码，如果用户名或密码不对，则会报错；</li><li>如果用户名和密码都对了，会读取该用户的权限，然后后面的权限逻辑判断都基于此时读取到的权限；</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#x27;MySQL 服务被多少个客户端连接了？&#x27;</span><br><span class="line">show processlist</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Command 列的状态为 Sleep说明有连接处于空闲，空闲连接不会一直占用，可以通过wait_timeout来查看，也可以手动断开连接</span><br><span class="line"></span><br><span class="line">&#x27;MySQL 的连接数有限制吗？&#x27;</span><br><span class="line">max_connections </span><br><span class="line"></span><br><span class="line">&#x27;MySQL和HTTP一样使用长链接&#x27;</span><br><span class="line">优点：可以减少建立连接和断开连接的过程</span><br><span class="line">缺点：长连接后可能会占用内存增多，因为 MySQL 在执行查询过程中临时使用内存管理连接对象，这些连接对象资源只有在连接断开时才会释放。如果长连接累计很多，将导致 MySQL 服务占用内存太大</span><br><span class="line"></span><br><span class="line">&#x27;怎么解决长连接占用内存的问题？&#x27;</span><br><span class="line">定期断开长连接</span><br><span class="line">客户端主动重置连接</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="解析器"><a href="#解析器" class="headerlink" title="解析器"></a>解析器</h2><ul><li><code>词法分析</code>：MySQL根据输入的字符串识别关键字，构建SQL语法树，方便获取SQL类型、表名、字段名等</li><li><code>语法分析</code>：判断你输入的这个 SQL 语句是否满足 MySQL 语法。</li></ul><p><code>注意：</code>判断表存在与不存在不是在解析器里面做的，而是在预处理器做的。</p><h2 id="预处理器"><a href="#预处理器" class="headerlink" title="预处理器"></a>预处理器</h2><ul><li>检查 SQL 查询语句中的表或者字段是否存在；</li><li>将 select <em> 中的 </em> 符号，扩展为表上的所有列；<h2 id="优化器"><a href="#优化器" class="headerlink" title="优化器"></a>优化器</h2></li><li>优化器主要负责将 SQL 查询语句的执行方案确定下来，比如在表里面有多个索引的时候，优化器会基于查询成本的考虑，来决定选择使用哪个索引。<h2 id="执行器"><a href="#执行器" class="headerlink" title="执行器"></a>执行器</h2></li><li>操作引擎层，并且返回结果，执行器与引擎交互有三种方式<br>&gt;<blockquote><ul><li><code>主键索引查询</code><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from product where id = 1;</span><br></pre></td></tr></table></figure><ul><li>执行器第一次查询，会调用 read_first_record 函数指针指向的函数</li><li>函数指针被指向为 InnoDB 引擎索引查询的接口，把条件 id = 1 交给存储引擎，让存储引擎定位符合条件的第一条记录。</li><li>存储引擎通过主键索引的 B+ 树结构定位到 id = 1的第一条记录，不存在报错，<code>存在就返回给执行器，由执行器判断该记录是否符合，符合就发送给客户</code>。</li><li><code>判断是否符合是在执行器判断的</code></li></ul></li></ul></blockquote></li></ul><blockquote><ul><li><p><code>全表扫描</code></p><ul><li>同主键索引</li></ul></li><li><p><code>索引下推</code></p><ul><li><code>索引下推能够减少二级索引在查询时的回表操作，提高查询的效率，因为它将 Server 层部分负责的事情，交给存储引擎层去处理了。</code><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from t_user  where age &gt; 20 and reward = 100000;</span><br></pre></td></tr></table></figure></li><li>联合索引当遇到范围查询 (&gt;、&lt;) 就会停止匹配，也就是 age 字段能用到联合索引，但是 reward 字段则无法利用到索引。</li><li>Server 层首先调用存储引擎的接口定位到满足查询条件的第一条二级索引记录，也就是定位到 age &gt; 20 的第一条记录；</li><li>存储引擎定位到二级索引后，先不执行回表操作，而是先判断一下该索引中包含的列（reward列）的条件（reward 是否等于 100000）是否成立。如果条件不成立，则直接跳过该&gt;二级索引。如果成立，则执行回表操作，将完成记录返回给 Server 层。</li></ul></li></ul><p>文章节选自<a href="https://www.xiaolincoding.com/">https://www.xiaolincoding.com/</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL行格式</title>
      <link href="/2022/06/14/post16/"/>
      <url>/2022/06/14/post16/</url>
      
        <content type="html"><![CDATA[<h2 id="1-MySQL数据存放文件"><a href="#1-MySQL数据存放文件" class="headerlink" title="1.MySQL数据存放文件"></a>1.MySQL数据存放文件</h2><ul><li>我们每创建一个 database（数据库） 都会在 /var/lib/mysql/ 目录里面创建一个以 database 为名的目录,创建一个<code>student</code>表<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@xiaodainiao ~]#ls /var/lib/mysql/my_test</span><br><span class="line">db.opt  </span><br><span class="line">student.frm  </span><br><span class="line">student.ibd</span><br></pre></td></tr></table></figure></li><li><code>db.opt</code>：用来存储当前数据库的默认字符集和字符校验规则。</li><li><code>student.frm</code>：student的<code>表结构</code>会保存在这个文件。在 MySQL 中建立一张表都会生成一个.frm 文件，该文件是用来保存每个表的元数据信息的，主要包含表结构定义。</li><li><code>student.ibd</code>：student 的<code>表数据</code>会保存在这个文件。(也叫表空间)</li><li>表空间由段（segment）、区（extent）、页（page）、行（row）组成<ul><li>InnoDB 的数据是按「页」为单位来读写的,默认每个页的大小为 16KB(最多能保证 16KB 的连续存储空间)</li><li>在表中数据量大的时候，为某个索引分配空间的时候就不再按照页为单位分配了，而是按照区（extent）为单位分配。每个区的大小为 1MB，对于 16KB 的页来说，连续的 64 个页会被划为一个区，这样就使得链表中相邻的页的物理位置也相邻，就能使用顺序 I/O 了。</li><li>表空间是由各个段（segment）组成的，段是由多个区（extent）组成的。段一般分为数据段、索引段和回滚段等。<h2 id="2-行格式"><a href="#2-行格式" class="headerlink" title="2.行格式"></a>2.行格式</h2></li></ul></li><li>MySQL默认是默认行格式为COMPACT格式<br><img src="https://img-blog.csdnimg.cn/d0b346439dcb484eaca5abd7ad0089b5.png" alt="在这里插入图片描述"></li><li>记录的额外信息包含 3 个部分：变长字段长度列表、NULL 值列表、记录头信息。</li><li>记录的真是数据包含：row_id、trx_id、roll_ptr、列1值、列2值、列3值。<h3 id="变长字段"><a href="#变长字段" class="headerlink" title="变长字段"></a>变长字段</h3></li><li>varchar(n) 和 char(n) 的区别是什么，相信大家都非常清楚，char 是定长的，varchar 是变长的，变长字段实际存储的数据的长度（大小）不固定的。<br><img src="https://img-blog.csdnimg.cn/601745eac14745d2a8a33a580763fca3.png" alt="在这里插入图片描述"></li><li>name 列的值为 a，真实数据占用的字节数是 1 字节，十六进制 0x01；</li><li>phone 列的值为 123，真实数据占用的字节数是 3 字节，十六进制 0x03；<br><img src="https://img-blog.csdnimg.cn/6d50d7ad70d74e3f809732c0d6469a24.png" alt="在这里插入图片描述"><br><code>注意：变长字段字节数列表不是必须的。当数据表没有变长字段的时候，比如全部都是 int 类型的字段，这时候表里的行格式就不会有「变长字段长度列表」了</code><h3 id="NULL值列表"><a href="#NULL值列表" class="headerlink" title="NULL值列表"></a>NULL值列表</h3></li><li>表中的某些列可能会存储 NULL 值，如果把这些 NULL 值都放到记录的真实数据中会比较浪费空间，所以 Compact 行格式把这些值为 NULL 的列存储到 NULL值列表中。</li><li>如果存在允许 NULL 值的列，则每个列对应一个二进制位（bit），二进制位按照列的顺序逆序排列。<ul><li>二进制位的值为1时，代表该列的值为NULL。</li><li>二进制位的值为0时，代表该列的值不为NULL。<br><img src="https://img-blog.csdnimg.cn/526b238ae39f43de913696fb3b4d3591.png" alt="在这里插入图片描述"></li></ul></li></ul><p><code>注意：</code></p><ul><li>NULL 值列表也不是必须的。当数据表的字段都定义成 NOT NULL 的时候，这时候表里的行格式就不会有 NULL 值列表了。(NULL 值列表至少占用 1 字节空间）</li><li>「NULL 值列表」的空间不是固定 1 字节的。当一条记录有 9 个字段值都是 NULL，那么就会创建 2 字节空间的「NULL 值列表」，以此类推。<h3 id="记录头信息（省略）"><a href="#记录头信息（省略）" class="headerlink" title="记录头信息（省略）"></a>记录头信息（省略）</h3></li></ul><h3 id="记录真实数据"><a href="#记录真实数据" class="headerlink" title="记录真实数据"></a>记录真实数据</h3><ul><li><p><code>row_id</code></p><ul><li>如果我们建表的时候指定了主键或者唯一约束列，那么就没有 row_id 隐藏字段了。如果既没有指定主键，又没有唯一约束，那么 InnoDB 就会为记录添加 row_id 隐藏字段。row_id不是必需的，占用 6 个字节。</li></ul></li><li><p><code>trx_id</code></p><ul><li>事务id，表示这个数据是由哪个事务生成的。 trx_id是必需的，占用 6 个字节。</li></ul></li><li><code>roll_pointer</code><ul><li>这条记录上一个版本的指针。roll_pointer 是必需的，占用 7 个字节。（MVCC机制） </li></ul></li></ul><h2 id="3-varchar-n-中-n-最大取值为多少？"><a href="#3-varchar-n-中-n-最大取值为多少？" class="headerlink" title="3.varchar(n) 中 n 最大取值为多少？"></a>3.varchar(n) 中 n 最大取值为多少？</h2><ul><li>一行记录最大只能存储<code>65535 字节</code>的数据。</li><li>varchar(n) 字段类型的 n 代表的是最多存储的字符数量，并不是字节大小</li><li><p><code>65535字节的数据 = 变长字段长度列表 + NULL 值列表 + 真实数据</code></p><ul><li>创建表的时候，字段是允许为 NULL 的，所以会用 1 字节来表示「NULL 值列表」。 </li><li>「变长字段长度列表」所占用的字节数 = 所有「变长字段长度」占用的字节数之和。<ul><li>如果变长字段允许存储的最大字节数小于等于 255 字节，就会用 1 字节表示「变长字段长度」否则用2个字节代替 </li></ul></li></ul></li><li><p><code>varchar(n) 中 n 最大值 = 65535 - 2 - 1 = 65532。</code></p></li></ul><h2 id="4-行溢出"><a href="#4-行溢出" class="headerlink" title="4.行溢出"></a>4.行溢出</h2><ul><li>发生行溢出，多的数据就会存到另外的<code>溢出页</code>中。</li><li>当发生行溢出时，在记录的真实数据处只会保存该列的一部分数据，而把剩余的数据放在「溢出页」中，然后真实数据处用 20 字节存储指向溢出页的地址，从而可以找到剩余数据所在的页。</li></ul><p><img src="https://img-blog.csdnimg.cn/f89cf706cc79448ab8b42e047b0f59f6.png" alt="在这里插入图片描述"></p><h2 id="5-字节面试"><a href="#5-字节面试" class="headerlink" title="5.字节面试"></a>5.字节面试</h2><ul><li><code>MySQL 的 NULL 值会占用空间吗？</code><ul><li>MySQL 的 Compact 行格式中会用「NULL值列表」来标记值为 NULL 的列，NULL 值并不会存储在行格式中的真实数据部分。</li><li>NULL值列表会占用 1 字节空间，当表中所有字段都定义成 NOT NULL，行格式中就不会有 NULL值列表，这样可节省 1 字节的空间。 </li></ul></li><li><code>MySQL 怎么知道 varchar(n) 实际占用数据的大小？</code><ul><li>MySQL 的 Compact 行格式中会用「变长字段长度列表」存储变长字段实际占用的数据大小。</li></ul></li><li><code>varchar(n) 中 n 最大取值为多少？</code><ul><li>一行记录最大能存储 65535 字节的数据，但是这个是包含「变长字段字节数列表所占用的字节数」和「NULL值列表所占用的字节数」。所以， 我们在算 varchar(n) 中 n 最大值时，需要减去这两个列表所占用的字节数。</li></ul></li><li><code>行溢出后，MySQL 是怎么处理的？</code><ul><li>如果一个数据页存不了一条记录，InnoDB 存储引擎会自动将溢出的数据存放到「溢出页」中。</li><li>Compact 行格式针对行溢出的处理是这样的：当发生行溢出时，在记录的真实数据处只会保存该列的一部分数据，而把剩余的数据放在「溢出页」中，然后真实数据处用 20 字节存储指向溢出页的地址，从而可以找到剩余数据所在的页。 </li></ul></li></ul><p>文章节选自<a href="https://www.xiaolincoding.com/">https://www.xiaolincoding.com/</a></p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL事务</title>
      <link href="/2022/06/05/post15/"/>
      <url>/2022/06/05/post15/</url>
      
        <content type="html"><![CDATA[<h2 id="事务的四大特性"><a href="#事务的四大特性" class="headerlink" title="事务的四大特性"></a>事务的四大特性</h2><ul><li><code>原子性（atomicity）</code>：事务是最小的执行单位，不允许分割，事务执行时要么全部成功，要么失败回滚。</li><li><code>一致性（consistency）</code>：事务执行之前和事务执行结束，数据库完整性没有被破坏，也就是数据从一个正确的状态转换到另一个正确状态。</li><li><code>隔离型（isolation）</code>：数据库允许多个并发事务同时对数据进行读写，而隔离是一个事务执行，不影响其他事务的运行效果。</li><li><code>持久性（durability）</code>：一个事务一旦提交（结束），对数据库的修改就是永久的，即使系统故障也不会丢失。</li></ul><h2 id="并发事务带来的问题"><a href="#并发事务带来的问题" class="headerlink" title="并发事务带来的问题"></a>并发事务带来的问题</h2><p>对于服务器来说可能同时处理多个事务。事务有<code>隔离性</code>的特性，理论上在某个事务 <code>对某个数据进行访问</code> 时，其他事务应该进行<code>排队</code>，当该事务提交之后，其他事务才可以继续访问这个数据。但是这样对 <code>性能影响太大</code>，我们既想保持事务的隔离性，又想让服务器在处理访问同一数据的多个事务时 性能尽量高些 。</p><ul><li><p><code>脏读（ Dirty Read ）</code>：事务A和事务B交替执行，事务A<code>读取</code>了已经被事务B<code>修改</code>但是<code>还未提交的字段</code>，而此时事务B发生了<code>回滚</code>，那么事务A读到的就是<code>脏数据</code>。<br><img src="https://img-blog.csdnimg.cn/1563f8a30c514f819daf558da47406e2.png" alt="在这里插入图片描述"></p></li><li><p><code>幻读（ Phantom ）</code>:    事务A查询一个范围的结果集，另一个并发事务B往这个范围中<code>插入/删除了数据</code>，并提交，然后事务A再次查询相同的范围，两次读取得到的结果集不一样了，这就是幻读。</p></li></ul><p><img src="https://img-blog.csdnimg.cn/aaacd0bd91db4ce48684bea82981619e.png" alt="在这里插入图片描述"></p><ul><li><p><code>不可重复读（ Non-Repeatable Read ）</code>:事务 A 读取 了一个字段，然后 事务 B 更新 了该字段。 之后事务A 再次读取 同一个字段， 值就不同了<br><img src="https://img-blog.csdnimg.cn/c6df590c50534f269653a8680308f52a.png" alt="在这里插入图片描述"></p></li><li><p><code>丢弃修改</code>：俩个写事务A,B同时对A = 0进行+1操作，结果B覆盖了A，导致最终结果是1而不是2，事务被覆盖。<br><img src="https://img-blog.csdnimg.cn/94684da7473046c092b6e075cdf83854.png" alt="在这里插入图片描述"></p></li></ul><p><strong>幻读和不可重复读区别</strong></p><ul><li>不可重复读重点是修改，而幻读重点在于新增或删除。<blockquote><p>例如事务A读取工资为1000操作没完成，此时事务B修改1000为2000，此时A在读导致钱是1000.<br>幻读是事务A查询工资单中大于3000的一共有3人，而此时事务B又加了一条4000元进行，此时事务A读到的就是4人。</p><h2 id="事务的隔离级别"><a href="#事务的隔离级别" class="headerlink" title="事务的隔离级别"></a>事务的隔离级别</h2></blockquote></li><li><code>READ UNCOMMITTED</code>：读未提交，事务发生了修改，即使没有提交，所有事务都可以看到其他未提交事务的执行结果。<code>不能避免脏读、不可重复读、幻读。</code></li><li><code>READ COMMITTED</code> ：读已提交，一个事务从开始直到提交前，所做的任何修改时其他事务不可见的。这是大多数数据库系统的默认隔离级别（但不是MySQL默认的）。可以避免脏读，但<code>不可重复读、幻读问题</code>仍然存在。</li><li><code>REPEATABLE READ</code>：可重复读，事务A在读到一条数据之后，此时事务B对该数据进行了修改并提交，那么事务A再读该数据，读到的还是原来的内容。可以避免脏读、不可重复读，但幻读问题仍然存在。这是MySQL的默认隔离级别。</li><li><code>SERIALIZABLE</code> ：可串行化，确保事务可以从一个表中读取相同的行。在这个事务持续期间，禁止其他事务对该表执行插入、更新和删除操作。所有的并发问题都可以避免，但性能十分低下。能避免脏读、不可重复读和幻读。<br><img src="https://img-blog.csdnimg.cn/001182f4dc04493482474f631625a930.png" alt="在这里插入图片描述"></li></ul><h2 id="事务如何保持四大特性（简要）"><a href="#事务如何保持四大特性（简要）" class="headerlink" title="事务如何保持四大特性（简要）"></a>事务如何保持四大特性（简要）</h2><h3 id="数据库如何保持原子性"><a href="#数据库如何保持原子性" class="headerlink" title="数据库如何保持原子性"></a>数据库如何保持原子性</h3><p>主要是利用 Innodb 的<strong>undo log</strong>。 <strong>undo log</strong>名为回滚日志，是实现原子性的关键，当事务回滚时能够撤销所有已经成功执行的 SQL语句，他需要记录你要回滚的相应日志信息。 例如</p><ul><li>当你delete一条数据的时候，就需要记录这条数据的信息，回滚的时候，insert这条旧数据</li><li>当你update一条数据的时候，就需要记录之前的旧值，回滚的时候，根据旧值执行update操作</li><li>当年insert一条数据的时候，就需要这条记录的主键，回滚的时候，根据主键执行delete操作</li></ul><p><strong>undo log</strong>记录了这些回滚需要的信息，当事务执行失败或调用了rollback，导致事务需要回滚，便可以利用<strong>undo log</strong>中的信息将数据回滚到修改之前的样子。</p><h3 id="数据库如何保持一致性"><a href="#数据库如何保持一致性" class="headerlink" title="数据库如何保持一致性"></a>数据库如何保持一致性</h3><p>分为两个层面来说。</p><ul><li><strong>从数据库层面</strong>，数据库通过原子性、隔离性、持久性来保证一致性。也就是说ACID四大特性之中，C(一致性)是目的，A(原子性)、I(隔离性)、D(持久性)是手段，是为了保证一致性，数据库提供的手段。<strong>数据库必须要实现AID三大特性，才有可能实现一致性</strong>。例如，原子性无法保证，显然一致性也无法保证。</li><li><strong>从应用层面</strong>，通过代码判断数据库数据是否有效，然后决定回滚还是提交数据！<h3 id="数据库如何保持隔离性"><a href="#数据库如何保持隔离性" class="headerlink" title="数据库如何保持隔离性"></a>数据库如何保持隔离性</h3></li><li><p>采用加锁的机制</p><h3 id="数据库如何保持持久性"><a href="#数据库如何保持持久性" class="headerlink" title="数据库如何保持持久性"></a>数据库如何保持持久性</h3><p>主要是利用Innodb的<strong>redo log</strong>。重写日志， 正如之前说的，MySQL是先把磁盘上的数据加载到内存中，在内存中对数据进行修改，再写回到磁盘上。如果此时突然宕机，内存中的数据就会丢失。 怎么解决这个问题？ 简单啊，事务提交前直接把数据写入磁盘就行啊。 这么做有什么问题？</p></li><li><p>只修改一个页面里的一个字节，就要将整个页面刷入磁盘，太浪费资源了。毕竟一个页面16kb大小，你只改其中一点点东西，就要将16kb的内容刷入磁盘，听着也不合理。</p></li><li>毕竟一个事务里的SQL可能牵涉到多个数据页的修改，而这些数据页可能不是相邻的，也就是属于随机IO。显然操作随机IO，速度会比较慢。</li></ul><p>于是，决定采用<strong>redo log</strong>解决上面的问题。当做数据修改的时候，不仅在内存中操作，还会在<strong>redo log</strong>中记录这次操作。当事务提交的时候，会将<strong>redo log</strong>日志进行刷盘(<strong>redo log</strong>一部分在内存中，一部分在磁盘上)。当数据库宕机重启的时候，会将<strong>redo log</strong>中的内容恢复到数据库中，再根据<strong>undo log</strong>和<strong>binlog</strong>内容决定回滚数据还是提交数据。</p><p>文章借鉴：<a href="https://interviewguide.cn/notes/03-hunting_job/02-interview/03-02-net.html">https://interviewguide.cn/notes/03-hunting_job/02-interview/03-02-net.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL日志</title>
      <link href="/2022/05/25/post14/"/>
      <url>/2022/05/25/post14/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>事务有4种特性：<code>原子性、一致性、隔离性和持久性</code>。那么事务的四种特性到底是基于什么机制实现呢？</p><ul><li>事务的隔离性由 <code>锁机制</code> 实现。<ul><li>而事务的原子性、一致性和持久性由事务的 <code>redo 日志</code>和<code>undo 日志</code>来保证。<ul><li><code>undo log（回滚日志）</code>：是 Innodb <code>存储引擎层</code>生成的日志，实现了事务中的原子性，主要用于事务回滚和 MVCC。(回滚行记录到某个特定版本，用来保证事务的原子性、一致性。)<ul><li><code>redo log（重做日志）</code>：是 Innodb <code>存储引擎层</code>生成的日志，实现了事务中的持久性，主要用于掉电等故障恢复；(提供再写入操作，恢复提交事务修改的页操作，用来保证事务  的持久性。)</li><li><code>binlog （归档日志）</code>：是 <code>Server 层</code>生成的日志，主要用于数据备份和主从复制；</li></ul></li></ul></li></ul></li></ul><h2 id="redo-log（引擎层）"><a href="#redo-log（引擎层）" class="headerlink" title="redo log（引擎层）"></a>redo log（引擎层）</h2><h3 id="1-为什么使用redo-log"><a href="#1-为什么使用redo-log" class="headerlink" title="1. 为什么使用redo log"></a>1. 为什么使用redo log</h3><p>MySQL是先把磁盘上的数据加载到内存中，在内存中对数据进行修改，再写回到磁盘上。如果此时突然宕机，内存中的数据就会丢失。 怎么解决这个问题？ 简单啊，事务提交前直接把数据写入磁盘就行啊。 这么做有什么问题？</p><ul><li>只修改一个页面里的一个字节，就要将整个页面刷入磁盘，太浪费资源了。毕竟一个页面16kb大小，你只改其中一点点东西，就要将16kb的内容刷入磁盘，听着也不合理。</li><li>毕竟一个事务里的SQL可能牵涉到多个数据页的修改，而这些数据页可能不是相邻的，也就是属于随机IO。显然操作随机IO，速度会比较慢。</li></ul><p>于是，决定采用redo log解决上面的问题。当做数据修改的时候，不仅在内存中操作，还会在redo log中记录这次操作。当事务提交的时候，会将redo log日志进行刷盘(redo log一部分在内存中，一部分在磁盘上)。当数据库宕机重启的时候，会将redo log中的内容恢复到数据库中，再根据undo log和binlog内容决定回滚数据还是提交数据。</p><h3 id="2-redo-log-优点"><a href="#2-redo-log-优点" class="headerlink" title="2. redo log 优点"></a>2. redo log 优点</h3><ul><li><code>redo日志占用的空间非常小</code>，只是记录哪一页修改了啥，修改什么内容是不知道的。体积小，刷盘快，降低刷盘频率。(具体数据是回滚还是提交，再根据undo log和redo log内容决定是回滚数据还是提交数据)</li><li><code>redo日志是顺序写入磁盘的</code>，它是一直往末尾进行追加，属于顺序IO。</li><li><code>事务执行过程中，redo log不断记录</code><h3 id="3-redo-log-流程"><a href="#3-redo-log-流程" class="headerlink" title="3. redo log 流程"></a>3. redo log 流程</h3><img src="https://img-blog.csdnimg.cn/943860fe2a7044a8ac5c88071c9e6388.png" alt="在这里插入图片描述"></li></ul><blockquote><p>第1步：先将原始数据从磁盘中读入内存中来，修改数据的内存拷贝<br>第2步：生成一条重做日志并写入redo log buffer，记录的是数据被修改后的值(此时并不会直接将redo log buffer的内容进行刷盘，而是放在了操作系统的缓冲区中，由操作系统进行系统调用<code>fsync()</code>函数决定什么时候刷盘)<br>第3步：当事务commit时，将redo log buffer中的内容刷新到 redo log file，对 redo log file采用追加写的方式<br>第4步：定期将内存中修改的数据刷新到磁盘中<br>Write-Ahead Log(预先日志持久化)：在持久化一个数据页之前，先将内存中相应的日志页持久化(MySQL 的写操作并不是立刻写到磁盘上，而是先写日志，然后在合适的时间再写到磁盘上。)。</p></blockquote><p><code>被修改 Undo 页面，需要记录对应 redo log 吗？</code></p><ul><li>开启事务后，InnoDB 层更新记录前，首先要记录相应的 undo log，如果是更新操作，需要把被更新的列的旧值记下来，也就是要生成一条 undo log，undo log 会写入 Buffer Pool 中的 Undo 页面。不过，在内存修改该 Undo 页面后，需要记录对应的 redo log。</li></ul><h3 id="4-什么时候刷盘"><a href="#4-什么时候刷盘" class="headerlink" title="4.  什么时候刷盘"></a>4.  什么时候刷盘</h3><ul><li><code>刷盘是指从redo log buffer到redo log file中，只要这个过程不出问题，就不会有事</code></li><li>首先是从<code>redo log buffer</code>刷到 <code>文件系统缓存（page cache）</code>中去,然后由操作系统判断什么时候刷盘。</li></ul><p>InnoDB给出 <code>innodb_flush_log_at_trx_commit</code> 参数，该参数控制 commit提交事务时，如何将 redo log buffer 中的日志刷新到 redo log file 中。它支持三种策略：</p><ul><li><code>设置为0</code> ：表示每次事务提交时不进行刷盘操作。（系统默认master thread每隔1s进行一次重做日<br>志的同步）</li><li><code>设置为1</code>：表示每次事务提交时都将进行同步，刷盘操作（ <code>默认值</code> ）</li><li><code>设置为2</code> ：表示每次事务提交时都只把 redo log buffer 内容写入 page cache，不进行同步。由os自<br>己决定什么时候同步到磁盘文件。</li></ul><h3 id="redo-log-文件写满怎么办？"><a href="#redo-log-文件写满怎么办？" class="headerlink" title="redo log 文件写满怎么办？"></a>redo log 文件写满怎么办？</h3><p>「重做日志文件组」由有 2 个 redo log 文件组成</p><ul><li><code>ib_logfile0 和 ib_logfile1</code> 。</li><li>redo log File 设置的上限是 1 GB(总共2GB)</li><li>重做日志文件组是以循环写的方式工作的，从头开始写，写到末尾就又回到开头</li></ul><p><code>流程</code>：</p><ul><li>InnoDB 存储引擎会先写 ib_logfile0 文件，当 ib_logfile0 文件被写满的时候，会切换至 ib_logfile1 文件，当 ib_logfile1 文件也被写满时,MySQL 会被阻塞<ul><li>会停下来将 Buffer Pool 中的脏页刷新到磁盘中，然后标记 redo log 哪些记录可以被擦除，接着对旧的 redo log 记录进行擦除，等擦除完旧记录腾出了空间,继续执行新的更新操作。</li></ul></li></ul><p><img src="https://img-blog.csdnimg.cn/1e51aea87646485fbd0fd290c333a13a.png" alt="在这里插入图片描述"></p><h2 id="undo-log（引擎层）"><a href="#undo-log（引擎层）" class="headerlink" title="undo log（引擎层）"></a>undo log（引擎层）</h2><p><img src="https://img-blog.csdnimg.cn/a1059268fa8b40689fa94f1ff94427cb.png" alt="在这里插入图片描述"></p><ul><li>redo log是事务持久性的保证，undo log是事务原子性的保证。在事务中 <code>更新数据</code> 的<code>前置操作</code> 其实是要先写入一个 <code>undo log</code>。<h3 id="1-为什么使用undo-log"><a href="#1-为什么使用undo-log" class="headerlink" title="1. 为什么使用undo log"></a>1. 为什么使用undo log</h3>事务需要保证<code>原子性</code>，也就是事务中的操作要么全部完成，要么什么也不做。但有时候事务执行到一半会出现一些情况，比如：</li><li>情况一：事务执行过程中可能遇到各种错误，比如 <code>服务器本身的错误 ， 操作系统错误</code> ，甚至是突然 断电 导致的错误。</li><li>情况二：程序员可以在事务执行过程中手动输入 <code>ROLLBACK</code>语句结束当前事务的执行。</li></ul><p>以上情况出现，我们需要把数据改回原先的样子，这个过程称之为 <code>回滚</code>，这样就可以造成一个假象：这个事务看起来什么都没做，所以符合 <code>原子性</code>要求。</p><p><code>一条记录的每一次更新操作产生的 undo log 格式都有一个 roll_pointer 指针和一个 trx_id 事务id：</code></p><ul><li>通过 <code>trx_id</code>可以知道该记录是被哪个事务修改的；</li><li>通过 <code>roll_pointer</code>指针可以将这些 undo log 串成一个链表，这个链表就被称为版本链；<h3 id="2-undo-log作用"><a href="#2-undo-log作用" class="headerlink" title="2. undo log作用"></a>2. undo log作用</h3><code>作用1：回滚数据,保证事务的原子性</code></li><li><p>undo是<code>逻辑日志</code>，因此只是将数据库从逻辑上恢复到原来的样子，但是物理层面做了一些改变是不会恢复的（例如创建了一个页，里面插入一个数据，然后回滚是删除该条数据，但是整个页是不会删除的）</p><p><code>作用2：MVCC</code></p><ul><li>innodb存储引擎中MVCC的实现是通过undo来完成。当用户读取一行记录时，若该条记录已经被其他事务占用，<code>当前事务可以通过undo读取之前的版本信息</code>，以此实现非锁定读取<h3 id="3-undo-log-流程"><a href="#3-undo-log-流程" class="headerlink" title="3. undo log 流程"></a>3. undo log 流程</h3><img src="https://img-blog.csdnimg.cn/52daa9e255b2457aba4e48ec2e7e0e73.png" alt="在这里插入图片描述"></li></ul></li><li><p>行格式有三个隐藏的列：</p><ul><li><code>row_id</code>：行ID,唯一标识一条记录（如果没有定义主键，也没有定义唯一索引，那么innodb会自动为表添加一个row_id的隐藏列作为主键）</li><li><code>transaction_id</code>：事务ID（每个事务都会分配一个事务ID，当对某条记录发生变更时，就会将这个事务的事务ID写入trx_id中）</li><li><code>roll_pointer</code>:：回滚指针（本质上是指向undo log的指针）</li></ul></li></ul><p><img src="https://img-blog.csdnimg.cn/6198edb30d7d42328110ff23694cdbe8.png" alt="在这里插入图片描述"></p><h4 id="undo-log是如何删除的"><a href="#undo-log是如何删除的" class="headerlink" title="undo log是如何删除的"></a>undo log是如何删除的</h4><p>针对于<code>insert undo log</code></p><ul><li>因为insert操作的记录，只对事务本身可见，对其他事务不可见。故该undo log可以在事务提交后直接删除，不需要进行purge操作。</li></ul><p>针对于<code>update undo log</code></p><ul><li>该undo log可能需要提供MVCC机制，因此不能在事务提交时就进行删除。提交时放入undo log链表，等待purge线程进行最后的删除。</li></ul><p><code>总结</code>：</p><ul><li><code>undo log是逻辑日志</code>，对事务回滚时，只是将数据库逻辑地恢复到原来的样子。</li><li><code>redo log是物理日志</code>，记录的是数据页的物理变化，undo log不是redo log的逆过程。</li></ul><h3 id="4-undo-log如何刷盘"><a href="#4-undo-log如何刷盘" class="headerlink" title="4. undo log如何刷盘"></a>4. undo log如何刷盘</h3><blockquote><ul><li>undo log 和数据页的刷盘策略是一样的，都需要通过 redo log 保证持久化。</li><li>buffer pool 中有 undo 页，对 undo 页的修改也都会记录到 redo log。redo log 会每秒刷盘，提交事务时也会刷盘，数据页和 undo 页都是靠这个机制保证持久化的。<h2 id="bin-log-数据层"><a href="#bin-log-数据层" class="headerlink" title="bin log(数据层)"></a>bin log(数据层)</h2></li><li>主要实现主从同步，主机的数据会写到bin log中，从机拿到bin log日志进行同步，实现主从同步。</li></ul></blockquote><p>binlog即binary log，二进制日志文件，也叫作变更日志（update log）。它记录了数据库所有执行的<br><code>DDL</code> 和 <code>DML</code> 等数据库更新事件的语句，<code>但是不包含没有修改任何数据的语句（如数据查询语句select、show等）。</code></p><p>binlog主要应用场景：</p><ul><li><code>数据恢复</code>：如果MySQL数据库意外停止，可以通过二进制日志文件来查看用户执行了哪些操作，对数据库服务器文件做了哪些修改，然后根据二进制日志文件中的记录来恢复数据库服务器。</li><li><code>数据复制</code>：由于日志的延续性和时效性，master把它的二进制传递给slaves来达到master-salve数据一致的目的。</li></ul><p><img src="https://img-blog.csdnimg.cn/72709b379e0b45f8ae676f8e2ea3c4fe.png" alt="在这里插入图片描述"></p><h3 id="写入日志流程"><a href="#写入日志流程" class="headerlink" title="写入日志流程"></a>写入日志流程</h3><ul><li>事务执行过程中，<code>先把日志写到 binlog cache ，事务提交的时候，再把binlog cache写到binlog文件中。</code>因为一个事务的binlog不能被拆开，无论这个事务多大，也要确保一次性写入，所以系统会给每个线程分配一个块内存作为binlog cache。</li><li><code>write</code>，指的就是指把日志写入到 binlog 文件，但是并没有把数据持久化到磁盘，因为数据还缓存在文件系统的 page cache 里，write 的写入速度还是比较快的，因为不涉及磁盘 I/O。</li><li><p><code>fsync</code>，才是将数据持久化到磁盘的操作，这里就会涉及磁盘 I/O，所以频繁的 fsync 会导致磁盘的 I/O 升高。</p></li><li><p>write和fsync的时机，可以由参数 sync_binlog 控制，默认是 0 。为0的时候，表示每次提交事务都只write，由系统自行判断什么时候执行fsync。虽然性能得到提升，但是机器宕机，page cache里面的binglog 会丢失。如下图</p></li></ul><p><img src="https://img-blog.csdnimg.cn/5cee5576b5ca4fc5a9869b08497d8b59.png" alt="在这里插入图片描述"></p><h3 id="binlog与redolog对比"><a href="#binlog与redolog对比" class="headerlink" title="binlog与redolog对比"></a>binlog与redolog对比</h3><p><code>1.适用对象不同：</code></p><ul><li><code>redo log 它是 物理日志</code> ，记录内容是“在某个数据页上做了什么修改”，属于 InnoDB <code>存储引擎层</code>产生的。（真实记录在物理磁盘页的）</li><li><code>binlog 是 逻辑日志</code> ，记录内容是语句的原始逻辑，类似于“给 ID=2 这一行的 c 字段加 1”，属于<code>MySQL Server 层</code>,所有存储引擎都可以使用；</li></ul><p><code>2.文件格式不同：</code></p><ul><li>binlog 有 3 种格式类型，分别是 STATEMENT（默认格式）、ROW、 MIXED</li><li>redo log 是物理日志，记录的是在某个数据页做了什么修改，比如对 XXX 表空间中的 YYY 数据页 ZZZ 偏移量的地方做了AAA 更新；</li></ul><p><code>3.用途不同：</code></p><ul><li>binlog 用于备份恢复、主从复制；</li><li>redo log 用于掉电等故障恢复。</li><li><code>redo log在事务执行的过程中不断写入，而binlog只有在提交事务时才写入，所以redolog与binlog的写入时机不一样</code></li></ul><p><code>4.写入方式不同</code></p><ul><li>binlog 是<code>追加写</code>，写满一个文件，就创建一个新的文件继续写，不会覆盖以前的日志，保存的是全量的日志。</li><li>redo log 是<code>循环写</code>，日志空间大小是固定，全部写满就从头开始，保存未被刷入磁盘的脏页日志。</li></ul><h4 id="两阶段提交"><a href="#两阶段提交" class="headerlink" title="两阶段提交"></a>两阶段提交</h4><ul><li>在执行更新语句过程，会记录redo log与binlog两块日志，以基本的事务为单位，redo log在事务执行过程中可以不断写入，而binlog只有在提交事务时才写入，所以redo log与binlog的<code>写入时机</code> 不一样。<code>就会导致由于binlog没写完就异常，这时候binlog里面没有对应的修改记录。</code></li></ul><p><img src="https://img-blog.csdnimg.cn/d74c385db969403b9376af7c7dc7097a.png" alt="在这里插入图片描述"></p><ul><li>为了解决两份日志之间的逻辑一致问题，InnoDB存储引擎使用<code>两阶段提交</code>方案。<br><img src="https://img-blog.csdnimg.cn/9cf66c0b0e3146c4b7a5d6a156c1db63.png" alt="在这里插入图片描述"></li><li>使用<code>两阶段提交</code>后，写入binlog时发生异常也不会有影响<br><img src="https://img-blog.csdnimg.cn/7ca36b9a11f74df9811e268d32c90af2.png" alt="在这里插入图片描述"></li></ul><p><img src="https://img-blog.csdnimg.cn/c28511bd258f48ed9b64cbd4ca8c30d2.png" alt="在这里插入图片描述"></p><p><code>流程</code></p><ul><li><p><code>prepare 阶段</code>：将 XID（内部 XA 事务的 ID） 写入到 redo log，同时将 redo log 对应的事务状态设置为 prepare，然后将 redo log 持久化到磁盘（innodb_flush_log_at_trx_commit = 1 的作用）；</p></li><li><p><code>commit 阶段</code>：把 XID 写入到 binlog，然后将 binlog 持久化到磁盘（sync_binlog = 1 的作用），接着调用引擎的提交事务接口，将 redo log 状态设置为 commit，此时该状态并不需要持久化到磁盘，只需要 write 到文件系统的 page cache 中就够了，因为只要 binlog 写磁盘成功，就算 redo log 的状态还是 prepare 也没有关系，一样会被认为事务已经执行成功；</p></li></ul><h2 id="出现异常重启会出现什么现象？"><a href="#出现异常重启会出现什么现象？" class="headerlink" title="出现异常重启会出现什么现象？"></a>出现异常重启会出现什么现象？</h2><p><img src="https://img-blog.csdnimg.cn/58e2f9128b594f1f9108e9a92d09e6c7.png" alt="在这里插入图片描述"><br>不管是时刻 A（redo log 已经写入磁盘， binlog 还没写入磁盘），还是时刻 B （redo log 和 binlog 都已经写入磁盘，还没写入 commit 标识）崩溃，此时的 redo log 都处于 prepare 状态。</p><ul><li><code>如果 binlog 中没有当前内部 XA 事务的 XID，说明 redolog 完成刷盘，但是 binlog 还没有刷盘，则回滚事务。</code>对应时刻 A 崩溃恢复的情况。</li><li><code>如果 binlog 中有当前内部 XA 事务的 XID，说明 redolog 和 binlog 都已经完成了刷盘，则提交事务</code>。对应时刻 B 崩溃恢复的情况。</li></ul><p>注意：</p><ul><li>对于处于 prepare 阶段的 redo log，即可以提交事务，也可以回滚事务，这取决于是否能在 binlog 中查找到与 redo log 相同的 XID</li><li>两阶段提交是以 binlog 写成功为事务提交成功的标识，因为 binlog 写成功了，就意味着能在 binlog 中查找到与 redo log 相同的 XID。</li><li><code>事务没提交的时候，redo log 也是可能被持久化到磁盘的。</code></li></ul><h2 id="两阶段提交带来的问题"><a href="#两阶段提交带来的问题" class="headerlink" title="两阶段提交带来的问题"></a>两阶段提交带来的问题</h2><p>磁盘 I/O 次数高：对于“双1”配置，每个事务提交都会进行两次 fsync（刷盘），一次是 redo log 刷盘，另一次是 binlog 刷盘。<br>锁竞争激烈：两阶段提交虽然能够保证「单事务」两个日志的内容一致，但在「多事务」的情况下，却不能保证两者的提交顺序一致，因此，在两阶段提交的流程基础上，还需要加一个锁来保证提交的原子性，从而保证多事务的情况下，两个日志的提交顺序一致。</p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>主从复制</title>
      <link href="/2022/05/20/post13/"/>
      <url>/2022/05/20/post13/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul><li>在实际工作中，经常用<code>Redis</code>和<code>MySQL</code>搭配使用，当有请求时，首先会从缓存中进行查询，如果存在就直接取出。如果不存在在访问数据库，这样就<code>提升了读取效率</code>，也减少了后端数据库的访问<code>压力</code>。</li><li><p>一般对数据库而言都是<code>读多写少</code>,对于数据库的读取数据压力比较大，所以可以采用<code>数据库集群的方案</code>，做<code>主从架构</code>、进行<code>读写分离</code>,同样可以提升数据库并发处理能力。<br><img src="https://img-blog.csdnimg.cn/ca5b36fba9704d568c7345d1a1fa911a.png" alt="在这里插入图片描述"></p><h2 id="主从复制作用"><a href="#主从复制作用" class="headerlink" title="主从复制作用"></a>主从复制作用</h2><p><img src="https://img-blog.csdnimg.cn/bdf0627325b147679f283e012b4df202.png" alt="在这里插入图片描述"></p></li><li><p><strong><code>读写分离</code></strong>：由于<code>读多写少</code>，master主库充当<code>写库</code>，salve从库充当<code>读库</code>，当主库更新时，会自动将数据复制到从库中，而客户端读取数据时，会从从库中进行读取，面对读多写少，采用<code>读写分离</code>，在实现高并发的同时，还能对<code>从服务器进行负载均衡</code>，让不同的读请求按照相应策略均匀的分发到不同的从服务器上，而且<code>减少锁表</code>的影响，<code>主库写锁时，从库依旧可以读。</code></p></li><li><strong><code>数据备份</code></strong>：通过主从复制将主库上的数据复制到了从库上，相当于一种<code>热备份机制</code>，也就是在主库正常运行的情况下的备份，不会影响到服务</li><li><strong><code>高可用性</code></strong>：数据库备份实际上是一种<code>冗余的机制</code>,通过冗余的方式可以换取数据库的高可用性，也就是当服务器出现<code>故障</code>或<code>宕机</code>情况下们可以<code>切换</code>到从服务器上，保证服务的正常运行。</li></ul><h2 id="主从复制原理"><a href="#主从复制原理" class="headerlink" title="主从复制原理"></a>主从复制原理</h2><ul><li>MySQL 的主从复制依赖于 binlog ，也就是记录 MySQL 上的所有变化并以二进制形式保存在磁盘上。复制的过程就是将 binlog 中的数据从主库传输到从库上。</li><li>这个过程是异步的，也就是主库上执行事务操作的线程不会等待复制 binlog 的线程同步完成。</li><li><code>Slave</code> 会从<code>Master</code> 读取 <code>binlog</code> 来进行数据同步。但是也可能出现主库将数据同步到从库需要500ms，而此时主库刚写完，就要从读库读（假设读200ms），此时就会出现延迟问题，这就需要后面的方法。</li></ul><p><strong>实际上主从同步的原理就是基于 binlog 进行数据同步的。在主从复制过程中，会基于 3 个线程 来操作，一个主库线程，两个从库线程</strong><br><img src="https://img-blog.csdnimg.cn/055b561ee95f45c8b01aa695a520d9d1.png" alt="在这里插入图片描述"></p><p><strong>复制三步骤</strong></p><ul><li><strong>写入 Binlog：</strong> 主库写 binlog 日志，提交事务，并更新本地存储数据。</li><li><strong>同步 Binlog：</strong> 把 binlog 复制到所有从库上，每个从库把 binlog 写到暂存日志中。</li><li><strong>回放 Binlog：</strong> 回放 binlog，并更新存储引擎中的数据。</li></ul><p><strong>具体详细过程如下：</strong></p><ul><li>MySQL 主库在收到客户端提交事务的请求之后，会先写入 binlog，再提交事务，更新存储引擎中的数据，事务提交完成后，返回给客户端“操作成功”的响应。</li><li>从库会创建一个专门的 I/O 线程，连接主库的 log dump 线程，来接收主库的 binlog 日志，再把 binlog 信息写入 relay log 的中继日志里，再返回给主库“复制成功”的响应。</li><li>从库会创建一个用于回放 binlog 的线程，去读 relay log 中继日志，然后回放 binlog 更新存储引擎中的数据，最终实现主从的数据一致性。</li></ul><p><strong>复制的问题</strong></p><ul><li>复制的最大问题： <code>延时</code></li></ul><p><strong>从库是不是越多越好？</strong></p><ul><li>从库连接上来的 I/O 线程也比较多，主库也要创建同样多的 log dump 线程来处理复制的请求，对主库资源消耗比较高，同时还受限于主库的网络带宽。</li></ul><p><strong>MySQL 主从复制还有哪些模型？</strong></p><ul><li>同步复制</li><li>异步复制</li><li>半同步复制</li></ul><h2 id="数据同步一致性问题"><a href="#数据同步一致性问题" class="headerlink" title="数据同步一致性问题"></a>数据同步一致性问题</h2><p><strong>主从延迟</strong></p><ul><li>进行主从同步的内容是二进制日志，它是一个文件，在进行 网络传输 的过程中就一定会 存在主从延迟。这样就可能造成用户在从库上读取的数据不是最新的数据，也就是主从同步中的 数据<code>不一致性</code> 问题。</li></ul><p><strong>主从延迟问题原因</strong></p><ul><li>在网络正常的时候，日志从主库传给从库所需的时间是很短的，即T2-T1的值是非常小的。即，网络正常情况下，主备延迟的主要来源是备库接收完binlog和执行完这个事务之间的时间差</li><li><code>主备延迟最直接的表现是，从库消费中继日志（relay log）的速度，比主库生产binlog的速度要慢</code></li></ul><p><strong>如何减少主从延迟</strong></p><ol><li>优化SQL，避免慢SQL， <code>减少批量操作</code></li><li><code>提高从库机器的配置</code>，减少主库写binlog和从库读binlog的效率差</li><li>尽量采用<code>短的链路</code>，提升端口带宽</li><li>实时性要求的业务读强制走主库，从库只做灾备，备份。</li></ol><p><strong>如何解决一致性问题</strong></p><blockquote><ul><li>如果操作的数据存储在同一个数据库中，那么对数据进行更新的时候，可以对记录加写锁，这样在读取的时候就不会发生数据不一致的情况。但这时从库的作用就是 <code>备份</code>，并没有起到 <code>读写分离</code> ，分担主库<code>读压力</code> 的作用。</li><li><code>读写分离情况下，解决主从同步中数据不一致的问题， 就是解决主从之间 数据复制方式 的问题</code></li></ul></blockquote><p><img src="https://img-blog.csdnimg.cn/7c485267b3df4f9c8b6d815c418aef57.png" alt="在这里插入图片描述"></p><p><code>方法 1：异步复制</code></p><ul><li>异步模式就是客户端提交COMMIT之后不需要等从库返回任何结果，而是直接将结果返回给客户端，这样做的好处是不会影响主库写的效率，但可能会存在主库宕机，而Binlog还没有同步到从库的情况，也就是此时的主库和从库数据不一致。这时候从从库中选择一个作为新主，那么新主则可能缺少原来主服务器中已提交的事务。所以，这种复制模式下的数据一致性是最弱的。<br><img src="https://img-blog.csdnimg.cn/0d6c3108e7b74d4fb19c68354370e8df.png" alt="在这里插入图片描述"></li></ul><p><code>方法 2：半同步复制</code></p><ul><li>原理是在客户端提交COMMIT之后不直接将结果返回给客户端，而是等待至少有一个从库接收到了Binlog，并且写入到中继日志中，再返回给客户端。这样做的好处就是提高了数据的一致性，当然相比于异步复制来说，至少多增加了一个网络连接的延迟，降低了主库写的效率。</li></ul><p><img src="https://img-blog.csdnimg.cn/2de5cec2f4474991bea3dcfcfe8111fa.png" alt="在这里插入图片描述"></p><p><code>方法 3：组复制</code></p><ul><li>异步复制和半同步复制都无法最终保证数据的一致性问题，半同步复制是通过判断从库响应的个数来决定是否返回给客户端，虽然数据一致性相比于异步复制有提升，但仍然无法满足对数据一致性要求高的场景</li></ul><blockquote><ul><li>首先我们将多个节点共同组成一个复制组，在 执行读写（RW）事务 的时候，需要通过一致性协议层（Consensus 层）的同意，也就是读写事务想要进行提交，必须要经过组里“大多数人”（对应 Node 节点）的同意，大多数指的是同意的节点数量需要大于 （N/2+1），这样才可以进行提交，而不是原发起方一个说了算。而针对 只读（RO）事务 则不需要经过组内同意，直接 COMMIT 即可。</li><li>在一个复制组内有多个节点组成，它们各自维护了自己的数据副本，并且在一致性协议层实现了原子消息和全局有序消息，从而保证组内数据的一致性。</li></ul></blockquote><p><img src="https://img-blog.csdnimg.cn/4f94fafd5f7a4428a57a39446a00172b.png" alt="在这里插入图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MVCC-多版本并发控制技术</title>
      <link href="/2022/05/15/post12/"/>
      <url>/2022/05/15/post12/</url>
      
        <content type="html"><![CDATA[<h2 id="快照读与当前读"><a href="#快照读与当前读" class="headerlink" title="快照读与当前读"></a>快照读与当前读</h2><p><code>快照读（普通select语句）通过MVCC方式解决幻读</code></p><ul><li>MVCC在MySQL InnoDB中的实现主要是为了提高数据库并发性能，用更好的方式去处理 <code>读-写冲突</code> ，做到即使有读写冲突时，也能做到 <code>不加锁 ， 非阻塞并发读</code> ，而这个读指的就是 <code>快照读（属于乐观锁）</code> , 而非 当前读 。</li></ul><p><code>当前读（select...for update等语句）通过next-key lock(记录锁+间隙锁)</code></p><ul><li><code>当前读</code>实际上是一种加锁的操作，是悲观锁的实现。而MVCC本质是采用乐观锁思想的一种方式。</li><li>当前读读取的是记录的<code>最新版本</code>（最新数据，而不是历史版本的数据），读取时还要保证其他并发事务不能修改当前记录，会对读取的记录进行加锁</li></ul><h2 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h2><p><strong>MySQL通过MVCC解决幻读，MVCC多版本并发控制结束，多版本通过<code>undolog</code>实现，管理通过<code>ReadView</code>实现</strong></p><ul><li>事务有四个隔离级别，可能存在三种并发问题：</li></ul><p><img src="https://img-blog.csdnimg.cn/6d1bc7e23fc74916b6dcaa34aefb5bbe.png" alt="在这里插入图片描述"></p><ul><li>但是在MySQL中，默认的隔离级别是可重复读，可以解决<code>脏读和不可重复读</code>，如果从定义来看，它不能解决幻读，只能采取<code>可串行化</code></li><li>但是MVCC可以不采用锁机制，而是通过<code>乐观锁</code>方式解决幻读，所以MySQL在可重复读也解决了幻读问题。<br><img src="https://img-blog.csdnimg.cn/dc5308e102424de89c127b78ce212f12.png" alt="在这里插入图片描述"></li></ul><h2 id="这四种隔离级别具体是如何实现的呢？"><a href="#这四种隔离级别具体是如何实现的呢？" class="headerlink" title="这四种隔离级别具体是如何实现的呢？"></a>这四种隔离级别具体是如何实现的呢？</h2><ul><li>对于「读未提交」隔离级别的事务来说，因为可以读到未提交事务修改的数据，所以直接读取最新的数据就好了；</li><li>对于「串行化」隔离级别的事务来说，通过加读写锁的方式来避免并行访问；</li><li><code>对于「读提交」和「可重复读」隔离级别的事务来说，它们是通过 Read View 来实现的，它们的区别在于创建 Read View 的时机不同，大家可以把 Read View 理解成一个数据快照，就像相机拍照那样，定格某一时刻的风景。「读提交」隔离级别是在「每个语句执行前」都会重新生成一个 Read View，而「可重复读」隔离级别是「启动事务时」生成一个 Read View，然后整个事务期间都在用这个 Read View。</code></li></ul><blockquote><p>注意，执行「开始事务」命令，并不意味着启动了事务。在 MySQL 有两种开启事务的命令，分别是：</p><ul><li>第一种：<code>begin/start transaction</code> 命令；</li><li>第二种：<code>start transaction with consistent snapshot</code> 命令；</li></ul><p>这两种开启事务的命令，事务的启动时机是不同的：</p><ul><li>执行了 begin/start transaction 命令后，并不代表事务启动了。只有在执行这个命令后，执行了增删查改操作的 SQL 语句，才是事务真正启动的时机；</li><li>执行了 start transaction with consistent snapshot 命令，就会马上启动事务。</li></ul></blockquote><p><code>总结</code>:</p><ul><li>MVCC读的是<code>快照</code>，也就是<code>乐观锁</code>的实现方式，幻读不会出现，相当于解决了幻读，但是并不是编程串行化了，串行化读是通过加锁，一个一个的进行解决。</li></ul><h2 id="隐藏字段、Undo-log版本链"><a href="#隐藏字段、Undo-log版本链" class="headerlink" title="隐藏字段、Undo log版本链"></a>隐藏字段、Undo log版本链</h2><ul><li>针对每一条记录（行格式），有三个隐藏字段<ul><li><code>UUID</code>：如果没有主键也没有唯一性索引，默认提供一个UUID隐藏字段</li><li><code>trx_id</code>:记录最近一个更新事务的ID(当一个事务对某条聚簇索引记录进行改动时，就会把该事务的事务 id 记录在 trx_id 隐藏列里)</li><li><code>roll_pointer</code>:回滚指针，是通过和undo log日志，旧版本写入到undo日志中，旧版本通过链表指针相连接，roll_point指向最近的undo log记录<br><img src="https://img-blog.csdnimg.cn/47a060ce0f284ff0b450c979c0d4e70b.png" alt="在这里插入图片描述"><h2 id="ReadView"><a href="#ReadView" class="headerlink" title="ReadView"></a>ReadView</h2></li></ul></li><li>使用 <code>READ COMMITTED</code> 和 <code>REPEATABLE READ</code> 隔离级别的事务，都必须保证读到 <code>已经提交了的</code> 事务修改过的记录。假如另一个事务已经修改了记录但是尚未提交，是不能直接读取最新版本的记录的</li><li><code>核心问题就是需要判断一下版本链中的哪个版本是当前事务可见的，这是ReadView要解决的主要问题</code></li></ul><blockquote><ol><li><code>creator_trx_id</code>，创建这个 Read View 的事务 ID。</li><li><code>m_ids</code>，表示在生成ReadView时当前系统中「活跃且未提交」的 <code>事务id列表</code>。<code>(“活跃事务”指的就是，启动了但还没提交的事务。)</code></li><li><code>min_trx_id</code> ，创建 Read View 时，当前数据库中「活跃事务且未提交的」事务中最小事务的事务 id </li><li><code>max_trx_id</code> ，表示生成ReadView时系统中应该分配给下一个事务的 id 值。max_trx_id 是系统最大的事务id值，这里要注意是系统中的事务id，需要区别于正在活跃的事务ID。<br><img src="https://img-blog.csdnimg.cn/614dd079bb0b4c90a14d347b3eb5f72a.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/99d5dcbf590745e79358cdaf1caf4173.png" alt="在这里插入图片描述"></li></ol></blockquote><p><img src="https://img-blog.csdnimg.cn/84591f35ecdc40ce9375f45294feed0d.png" alt="在这里插入图片描述"></p><h2 id="MVCC整体操作流程-如何解决幻读-重点"><a href="#MVCC整体操作流程-如何解决幻读-重点" class="headerlink" title="MVCC整体操作流程/如何解决幻读(重点)"></a>MVCC整体操作流程/如何解决幻读(<code>重点</code>)</h2><ol><li>首先获取事务自己的版本号，也就是事务 ID；</li><li>获取 ReadView；(在第一个查询语句后，会创建一个Read View后续的查询语句利用这个 Read View)</li><li>查询得到的数据，然后与 ReadView 中的事务版本号进行比较；</li><li>如果不符合 ReadView 规则，就需要从 Undo Log 中获取历史快照；</li><li>最后返回符合规则的数据。</li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>MVCC 在 <code>READ COMMITTD</code> 、 <code>REPEATABLE READ</code>这俩个隔离级别才有效，因为这俩个情况下考虑快照（读旧数据），而剩下的读为提交和串行化，读的都是最新数据</li><li>核心点在于 <code>ReadView</code> 的原理， <code>READ COMMITTD</code> 、 <code>REPEATABLE READ</code> 这两个隔离级别的一个很大不同<br>就是生成<code>ReadView</code>的时机不同：<ul><li><code>READ COMMITTD</code>在每一次进行普通<code>SELECT</code>操作前都会生成一个ReadView</li><li><code>REPEATABLE READ</code>只在第一次进行普通<code>SELECT</code>操作前生成一个<code>ReadView</code>，之后的查询操作都重复<br>使用这个<code>ReadView</code>就好了。</li></ul></li></ol><p><img src="https://img-blog.csdnimg.cn/6e2994154c2740bea20a1092e309dffd.png" alt="在这里插入图片描述"></p><h2 id="当前读是如何避免幻读的？"><a href="#当前读是如何避免幻读的？" class="headerlink" title="当前读是如何避免幻读的？"></a>当前读是如何避免幻读的？</h2><ul><li>MySQL 里除了普通查询是快照读，其他都是当前读，比如 update、insert、delete，这些语句执行前都会查询最新版本的数据，然后再做进一步的操作。</li><li>假设你要 update 一个记录，另一个事务已经 delete 这条记录并且提交事务了，这样不是会产生冲突吗，所以 update 的时候肯定要知道最新的数据。</li><li><code>使用间隙锁，对范围加锁使得插入或者删除或者更新无法操作</code></li></ul><p><img src="https://img-blog.csdnimg.cn/8f46c7b63a0a4b5e81e98b7856403f15.png" alt="在这里插入图片描述"></p><h2 id="幻读没有被完全解决？"><a href="#幻读没有被完全解决？" class="headerlink" title="幻读没有被完全解决？"></a>幻读没有被完全解决？</h2><p><code>场景一：</code></p><ul><li>在可重复读隔离级别下，事务 A 第一次执行普通的 select 语句时生成了一个 ReadView，之后事务 B 向表中新插入了一条 id = 5 的记录并提交。接着，事务 A 对 id = 5 这条记录进行了更新操作，在这个时刻，这条新记录的 trx_id 隐藏列的值就变成了事务 A 的事务 id，之后事务 A 再使用普通 select 语句去查询这条记录时就可以看到这条记录了，于是就发生了幻读。</li></ul><p><code>场景二：</code></p><ul><li>T1 时刻：事务 A 先执行「快照读语句」：select * from t_test where id &gt; 100 得到了 3 条记录。</li><li>T2 时刻：事务 B 往插入一个 id= 200 的记录并提交；</li><li>T3 时刻：事务 A 再执行「当前读语句」 select * from t_test where id &gt; 100 for update 就会得到 4 条记录，此时也发生了幻读现象。</li></ul><p>要避免这类特殊场景下发生幻读的现象的话，就是尽量在开启事务之后，马上执行 select … for update 这类当前读的语句，因为它会对记录加 next-key lock，从而避免其他事务插入一条新记录。</p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL 锁</title>
      <link href="/2022/05/10/post11/"/>
      <url>/2022/05/10/post11/</url>
      
        <content type="html"><![CDATA[<h1 id="1-锁的种类"><a href="#1-锁的种类" class="headerlink" title="1.锁的种类"></a>1.锁的种类</h1><ul><li>根据加锁的范围，可以分为<code>全局锁、表级锁和行锁</code>三类。<br><img src="https://img-blog.csdnimg.cn/8f0411f37f7f403da7ca7b91c3e87b29.png" alt="在这里插入图片描述"><h2 id="全局锁"><a href="#全局锁" class="headerlink" title="全局锁"></a>全局锁</h2></li><li><p>全局锁主要应用于做<code>全库逻辑备份</code>。这样在备份数据库期间，不会因为数据或表结构的更新，而出现备份文件的数据与预期的不一样。</p></li><li><p>缺点：</p><ul><li><p>整个数据库都是只读状态。 会造成业务停滞。</p></li><li><p>解决办法</p><ul><li>如果数据库的引擎支持的事务支持可重复读的隔离级别，那么在备份数据库之前先开启事务，会先创建 Read View，然后整个事务执行期间都在用这个 Read View，而且由于 MVCC 的支持，备份期间业务依然可以对数据进行更新操作。</li></ul></li></ul></li></ul><h1 id="2-表级锁"><a href="#2-表级锁" class="headerlink" title="2.表级锁"></a>2.表级锁</h1><h2 id="表锁"><a href="#表锁" class="headerlink" title="表锁"></a>表锁</h2><ul><li>针对数据库的表进行加锁。不会出现死锁，发生锁的冲突几率高，并发低。</li><li>MySQL表锁有俩个模式：<code>表共享读锁和表独占写锁</code></li><li><code>表级自增锁</code>，当为表的某一列添加AUTO_INCREAMENT属性后，插入数据可以不指定该字段，系统会自动为它赋值。此时获取自增值是需要AUTO_INC锁锁定的</li><li>MyISANM不适合做写为主表的引擎，因为它是表锁，当锁住后，其他的线程不能做任何操作，从而大量更新会使得查询很难得到锁，最终导致永久阻塞。</li><li><code>InnoDB 牛逼的地方在于实现了颗粒度更细的行级锁。</code></li></ul><h2 id="意向锁"><a href="#意向锁" class="headerlink" title="意向锁"></a>意向锁</h2><p>如果出现行锁的时候，想加表锁，那就只能进行全表遍历，看是否有加行锁。太浪费时间</p><ul><li><code>意向锁是则不需要进行遍历数据也可以直接判断是否可以给表加锁</code>。<ul><li><code>意向共享锁（IS锁）</code>：当事务给某行记录增加了S锁（共享锁）,同时给表加一个IS锁</li><li><code>意向独占锁（IX锁）</code>：当事务给某条记录增加X锁时（独占锁），同时给表加一个IX锁。</li></ul></li><li>意向锁是innodb自动加的，不用用户干预。</li></ul><blockquote><p>意向共享锁和意向独占锁是表级锁，不会和行级的共享锁和独占锁发生冲突，&gt;而且意向锁之间也不会发生冲突，只会和共享表锁（lock tables … read）和独占表锁（lock tables … write）发生冲突。</p></blockquote><h1 id="3-行级锁"><a href="#3-行级锁" class="headerlink" title="3.行级锁"></a>3.行级锁</h1><h2 id="行锁"><a href="#行锁" class="headerlink" title="行锁"></a>行锁</h2><ul><li>innodb既支持行锁，也支持表锁</li><li><code>行锁</code>开销大，会出现死锁，发生冲突几率小，并发高</li><li>MySQL的行锁是通过索引加载的，锁住的永远是索引，而非记录本身，即使没有索引innodb会在后台创建一个聚簇索引，行锁就会锁住聚簇索引，<code>但是如果一个SQL语句没有走任何索引，那么就会为它加上表锁，全表扫描。</code></li></ul><p><code>共享锁（读锁也叫S锁）/排他锁（写锁也叫X锁）</code></p><ul><li><code>共享锁（S锁）</code>：当一个事务给一条记录上共享锁后，其他的事务也可以对该事务上共享锁，但是该锁只是可以读，如果有事务想写，那么它就会阻塞，一直等待所有的锁释放。</li><li><code>排他锁（X锁）</code>：当一个事务给记录上锁后，可以进行读写，其他的事务不能够上任何锁。<h2 id="记录锁"><a href="#记录锁" class="headerlink" title="记录锁"></a>记录锁</h2></li><li><p>记录锁，锁住的是一条记录。而且记录锁是有 S 锁和 X 锁之分的：</p><h2 id="间隙锁"><a href="#间隙锁" class="headerlink" title="间隙锁"></a>间隙锁</h2><p>MySQL默认隔离级别是<code>可重复读</code>,而可重读读只能解决脏读，不可重复读。<code>解决不了幻读</code>,但是不同的一点是MySQL通过俩种机制来解决幻读：<code>一靠MVCC方案解决，二加锁方案解决</code>。然而事务加锁时，记录是不存在的，是无法加行锁，则需要靠间隙锁。<br><img src="https://img-blog.csdnimg.cn/649593a458d4436eac325cc6f38dd3eb.png" alt="在这里插入图片描述"></p></li><li><p>例如给 id=8 记录加 gap 锁，锁住（4,8）区间。另一事务想插入 id=6 的记录，会先定位到 id=8 的记录，然后发现存在一个 gap 锁，则阻塞直到 第一个事务将 gap 锁释放掉，才可以在（4,8）区间插入记录</p></li><li>gap lock 仅仅是为了防止插入幻影记录，并不会限制其他事务对记录继续加行锁 或者 gap 锁</li></ul><h2 id="临键锁"><a href="#临键锁" class="headerlink" title="临键锁"></a>临键锁</h2><ul><li>Next-Key Lock 称为临键锁，是 Record Lock + Gap Lock 的组合，锁定一个范围，并且锁定记录本身。<h2 id="插入意向锁"><a href="#插入意向锁" class="headerlink" title="插入意向锁"></a>插入意向锁</h2></li><li><p>一个事务在插入一条记录的时候，需要判断插入位置是否已被其他事务加了间隙锁（next-key lock 也包含间隙锁）。</p></li><li><p>如果有的话，插入操作就会发生阻塞，直到拥有间隙锁的那个事务提交为止（释放间隙锁的时刻），<code>在此期间会生成一个插入意向锁，表明有事务想在某个区间插入新记录，但是现在处于等待状态。</code></p></li><li><p>插入意向锁名字虽然有意向锁，但是它并不是意向锁，它是一种特殊的间隙锁，属于行级别锁。</p><h1 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h1><ul><li>每次拿<code>数据</code>都默认别人不会修改，所以不会上锁，在更新的时候会判断一下在此期间别人有没有去更新这个数据。 </li></ul></li><li><p><code>实现方式</code>：乐观锁一般会使用版本号机制或CAS<a href="">算法</a>实现。 </p></li><li><p><strong>MVCC (Multiversion Concurrency Control)，即多版本并发控制技术。</strong></p><ul><li><strong>MVCC在MySQL InnoDB中的实现主要是为了提高<a href="">数据</a>库并发性能，用更好的方式去处理读-写冲突，做到即使有读写冲突时，也能做到不加锁</strong></li></ul></li></ul><p><code>总结</code>：</p><ul><li><code>MVCC其本质就是看做是乐观锁的机制，而排他锁等则是悲观锁的实现。</code><h1 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h1></li><li>每次拿<a href="">数据</a>时都认为别人会修改，所以每次那<a href="">数据</a>时都会上锁，别人拿<a href="">数据</a>时会阻塞直到拿到锁。 </li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>goland结构体</title>
      <link href="/2022/05/06/post10/"/>
      <url>/2022/05/06/post10/</url>
      
        <content type="html"><![CDATA[<h1 id="五、结构体"><a href="#五、结构体" class="headerlink" title="五、结构体"></a>五、结构体</h1><h2 id="结构体普通变量初始化"><a href="#结构体普通变量初始化" class="headerlink" title="结构体普通变量初始化"></a><strong>结构体普通变量初始化</strong></h2><ul><li>结构体的成员必须初始化<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">    id <span class="type">int</span></span><br><span class="line">    name <span class="type">string</span></span><br><span class="line">    sex <span class="type">byte</span></span><br><span class="line">    age <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="string">&#x27;顺序初始化，每个成员必须初始化&#x27;</span></span><br><span class="line">    <span class="keyword">var</span> s1 Student = Student&#123;<span class="number">1</span>, <span class="string">&quot;mike&quot;</span>, <span class="string">&#x27;m&#x27;</span>, <span class="number">18</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="string">&#x27;指定成员初始化，没有初始化的成员，自动赋值为0&#x27;</span></span><br><span class="line">    s2 := Student&#123;name: <span class="string">&quot;mike&quot;</span>, sex: <span class="string">&#x27;m&#x27;</span>&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="结构体指针初始化"><a href="#结构体指针初始化" class="headerlink" title="结构体指针初始化"></a><strong>结构体指针初始化</strong></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">    id <span class="type">int</span></span><br><span class="line">    name <span class="type">string</span></span><br><span class="line">    sex <span class="type">byte</span></span><br><span class="line">    age <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="string">&#x27;顺序初始化，每个成员必须初始化&#x27;</span></span><br><span class="line">    <span class="keyword">var</span> s1 *Student = Student&#123;<span class="number">1</span>, <span class="string">&quot;mike&quot;</span>, <span class="string">&#x27;m&#x27;</span>, <span class="number">18</span>&#125;</span><br><span class="line">    fmt.Println(<span class="string">&quot;p1 = &quot;</span>, p1)</span><br><span class="line"></span><br><span class="line">    <span class="string">&#x27;指定成员初始化，没有初始化的成员，自动赋值为0&#x27;</span></span><br><span class="line">    s2 := &amp;Student&#123;name: <span class="string">&quot;mike&quot;</span>, sex: <span class="string">&#x27;m&#x27;</span>&#125;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;p2 type is %T\n&quot;</span>, p2)</span><br><span class="line">    fmt.Println(<span class="string">&quot;*p2 = &quot;</span>, *p2)</span><br><span class="line">&#125;</span><br><span class="line"><span class="string">&#x27;结果&#x27;</span></span><br><span class="line">p1 = &amp;&#123;<span class="number">1</span> mike m <span class="number">18</span>&#125;</span><br><span class="line">p2 <span class="keyword">type</span> is Student</span><br><span class="line">*p2 = &#123;<span class="number">0</span> mike m <span class="number">0</span>&#125;</span><br></pre></td></tr></table></figure><h2 id="结构体成员使用：普通成员"><a href="#结构体成员使用：普通成员" class="headerlink" title="结构体成员使用：普通成员"></a><strong>结构体成员使用：普通成员</strong></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s Student</span><br><span class="line">s.id = <span class="number">1</span></span><br><span class="line">s.name = <span class="string">&quot;mike&quot;</span></span><br><span class="line">s.sex = <span class="string">&#x27;m&#x27;</span></span><br><span class="line">s.age = <span class="number">18</span></span><br><span class="line">fmt.Println(<span class="string">&quot;s = &quot;</span>, s)</span><br></pre></td></tr></table></figure><h2 id="结构体成员使用：指针成员"><a href="#结构体成员使用：指针成员" class="headerlink" title="结构体成员使用：指针成员"></a><strong>结构体成员使用：指针成员</strong></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;1. 指针有合法指向后，才操作成员&#x27;</span></span><br><span class="line"><span class="keyword">var</span> s Student    <span class="comment">//定义一个普通结构体变量</span></span><br><span class="line"><span class="keyword">var</span> p1 *Student  <span class="comment">//定义一个指针变量，保存s的地址</span></span><br><span class="line">p1 = &amp;s</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过指针操作成员 p1.id和(*p1).id完全一样，只能使用.不能使用-&gt;</span></span><br><span class="line">p1.id = <span class="number">1</span></span><br><span class="line">(*p1).name = <span class="string">&quot;mike&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;2. 通过new申请一个结构体&#x27;</span></span><br><span class="line">p2 := <span class="built_in">new</span>(Student)</span><br></pre></td></tr></table></figure><h2 id="结构体比较与赋值"><a href="#结构体比较与赋值" class="headerlink" title="结构体比较与赋值"></a><strong>结构体比较与赋值</strong></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s1 Student = Student&#123;<span class="number">1</span>, <span class="string">&quot;mike&quot;</span>, <span class="string">&#x27;m&#x27;</span>, <span class="number">18</span>&#125;</span><br><span class="line"><span class="keyword">var</span> s2 Student = Student&#123;<span class="number">1</span>, <span class="string">&quot;mike&quot;</span>, <span class="string">&#x27;m&#x27;</span>, <span class="number">18</span>&#125;</span><br><span class="line"><span class="keyword">var</span> s3 Student = Student&#123;<span class="number">1</span>, <span class="string">&quot;mike&quot;</span>, <span class="string">&#x27;w&#x27;</span>, <span class="number">20</span>&#125;</span><br><span class="line">fmt.Println(<span class="string">&quot;s1 == s2&quot;</span>, s1 == s2)</span><br><span class="line">fmt.Println(<span class="string">&quot;s1 == s3&quot;</span>, s1 == s3)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> tmp Student</span><br><span class="line">tmp = s3</span><br></pre></td></tr></table></figure><h2 id="结构体值传递与地址传递"><a href="#结构体值传递与地址传递" class="headerlink" title="结构体值传递与地址传递"></a><strong>结构体值传递与地址传递</strong></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;值传递&#x27;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test01</span> <span class="params">(s Student)</span></span>&#123;</span><br><span class="line">    s.id = <span class="number">666</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;test01:&quot;</span>, s)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;地址传递&#x27;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test02</span> <span class="params">(p *Student)</span></span>&#123;</span><br><span class="line">    p.id = <span class="number">666</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;test02:&quot;</span>, s)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">s := Student&#123;<span class="number">1</span>, <span class="string">&quot;mike&quot;</span>, <span class="string">&#x27;m&#x27;</span>, <span class="number">18</span>&#125;</span><br><span class="line">    test01(s)   <span class="comment">//值传递，形参无法改变实参</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;main:&quot;</span>, s)</span><br><span class="line"></span><br><span class="line">    test02(&amp;s)  <span class="comment">//地址传递（引用传递），形参可以改变实参</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;main:&quot;</span>, s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="go语言的可见性test"><a href="#go语言的可见性test" class="headerlink" title="go语言的可见性test"></a><strong>go语言的可见性</strong><br />test</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> test</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//如果首字母小写，只能在同一个包里面使用</span></span><br><span class="line"><span class="keyword">type</span> stu <span class="keyword">struct</span>&#123;</span><br><span class="line">    id <span class="type">int</span>  <span class="comment">//只能在同一个包使用</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> stu <span class="keyword">struct</span>&#123;</span><br><span class="line">    Id <span class="type">int</span>  <span class="comment">//可以在不同包使用</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">myFunc</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;只能在同一个包使用&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">MyFunc</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;不同包中可以使用&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>main<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;test&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">//包名.函数名</span></span><br><span class="line">    test.MyFunc()</span><br><span class="line"></span><br><span class="line">    <span class="comment">//包名.结构体里类型名</span></span><br><span class="line">    <span class="keyword">var</span> s test.Stu</span><br><span class="line">    s.Id = <span class="number">666</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> goland </category>
          
      </categories>
      
      
        <tags>
            
            <tag> goland </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>goland复合类型</title>
      <link href="/2022/05/04/post9/"/>
      <url>/2022/05/04/post9/</url>
      
        <content type="html"><![CDATA[<h1 id="四、复合类型"><a href="#四、复合类型" class="headerlink" title="四、复合类型"></a>四、复合类型</h1><p><a name="SIM8Z"></a></p><h2 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h2><p><strong>变量地址</strong><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> a <span class="type">int</span> = <span class="number">10</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;a = %d\n&quot;</span>, a)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;&amp;a = %v\n&quot;</span>, &amp;a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><strong>指针变量基本使用</strong><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> a <span class="type">int</span> = <span class="number">10</span></span><br><span class="line">    <span class="keyword">var</span> p *<span class="type">int</span></span><br><span class="line">    p = &amp;a  <span class="comment">//指针变量指向谁，就把谁的地址赋给指针变量</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;p = %v&quot;</span>, &amp;a = %v\n ,p, &amp;a)</span><br><span class="line"></span><br><span class="line">    *p = <span class="number">666</span> <span class="comment">//*p操作的不是p的内存，是p所指向的内存（也就是a）</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;*p = %v&quot;</span>, a = %v\n ,*p, a)  <span class="comment">//*p = 666 a = 666</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><img src="https://cdn.nlark.com/yuque/0/2023/png/29618862/1679467149136-621970ff-7d0d-49a2-8ea5-57934626e238.png#averageHue=%23faf7f7&amp;clientId=u7d93236d-ed98-4&amp;from=paste&amp;height=119&amp;id=u823a6bc3&amp;originHeight=179&amp;originWidth=238&amp;originalType=binary&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;size=9557&amp;status=done&amp;style=none&amp;taskId=ub7338a52-e20a-4ca6-8ad6-cbd6a49f8cb&amp;title=&amp;width=158.66666666666666" alt="1679467139192.png"><br /><strong>不要操作不合法的内存</strong><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> p *<span class="type">int</span></span><br><span class="line">    p = <span class="literal">nil</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;p =&quot;</span>, p)</span><br><span class="line">    <span class="comment">// *p = 666   err,因为p没有合法指向</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> a <span class="type">int</span></span><br><span class="line">    p = &amp;a    <span class="comment">//p指向a</span></span><br><span class="line">    *p = <span class="number">666</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;a = &quot;</span>, a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><strong>new函数</strong><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    a := <span class="number">10</span></span><br><span class="line">    <span class="keyword">var</span> p *<span class="type">int</span></span><br><span class="line">    p = <span class="built_in">new</span>(<span class="type">int</span>)  <span class="comment">//p是*int，指向int类型</span></span><br><span class="line">    *p = <span class="number">666</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;*p = &quot;</span>, p)</span><br><span class="line"></span><br><span class="line">    q := <span class="built_in">new</span>(<span class="type">int</span>) <span class="comment">//自动推导类型</span></span><br><span class="line">    *q = <span class="number">777</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;*q = &quot;</span>, *q)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><strong>值传递</strong><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">swap</span><span class="params">(a, b <span class="type">int</span>)</span></span>&#123;</span><br><span class="line">    a, b = b, a</span><br><span class="line">    fmt.Println(<span class="string">&quot;swap: a = %d, b = %d\n&quot;</span>, a, b)  <span class="comment">//a = 20 b = 10</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    a, b := <span class="number">10</span>, <span class="number">20</span></span><br><span class="line">    <span class="comment">//通过一个函数交换a和b的内容</span></span><br><span class="line">    swap(a, b) <span class="comment">//变量本身传递，值传递（相当于将实参拷贝了一份，传递给了形参，在拷贝的那份上进行交换，而实参没变）</span></span><br><span class="line">fmt.Println(<span class="string">&quot;swap: a = %d, b = %d\n&quot;</span>, a, b)   <span class="comment">//a = 10 b = 20</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><img src="https://cdn.nlark.com/yuque/0/2023/png/29618862/1679470292660-9669fa77-03b4-4f97-b2da-1d2f196dda79.png#averageHue=%23fcfaf9&amp;clientId=u7d93236d-ed98-4&amp;from=paste&amp;height=184&amp;id=u3f7aeeec&amp;originHeight=276&amp;originWidth=691&amp;originalType=binary&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;size=26328&amp;status=done&amp;style=none&amp;taskId=u1c67dd1b-0369-4f18-9abd-d40f005b5de&amp;title=&amp;width=460.6666666666667" alt="1679470282240.png"><br /><strong>地址传递</strong><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">swap</span><span class="params">(p1, p2 *<span class="type">int</span>)</span></span>&#123;</span><br><span class="line">    *p1, *p2 = *p2, *p1</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    a, b := <span class="number">10</span>, <span class="number">20</span></span><br><span class="line">    <span class="comment">//通过一个函数交换a和b的内容</span></span><br><span class="line">    swap(&amp;a, &amp;b) <span class="comment">//地址传递</span></span><br><span class="line">fmt.Println(<span class="string">&quot;main: a = %d, b = %d\n&quot;</span>, a, b)   <span class="comment">//a = 20 b = 10</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><a name="IcPn7"></a></p><h2 id=""><a href="#" class="headerlink" title=""></a><img src="https://cdn.nlark.com/yuque/0/2023/png/29618862/1679470533075-4a1dd0a1-0c48-4ba3-b9bf-8bffc15c18ac.png#averageHue=%23fcf8f7&amp;clientId=u7d93236d-ed98-4&amp;from=paste&amp;height=199&amp;id=uf28512af&amp;originHeight=299&amp;originWidth=556&amp;originalType=binary&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;size=33948&amp;status=done&amp;style=none&amp;taskId=uddfffa8e-1bef-4421-bce6-678b34d1ef9&amp;title=&amp;width=370.6666666666667" alt="1679470526993.png"></h2><p><a name="gPCjd"></a></p><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> id [<span class="number">50</span>]<span class="type">int</span>  <span class="comment">//数组，同一个类型的集合</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(id); i ++ &#123;   <span class="comment">//通过下标操作数组，从0开始，到len() - 1</span></span><br><span class="line">    id[i] = i + <span class="number">1</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;id[%d] = %d\n&quot;</span>, i, id[i])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>一维数组初始化</strong><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a [<span class="number">5</span>]<span class="type">int</span> = [<span class="number">5</span>]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">b := [<span class="number">5</span>]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125; <span class="comment">//全部初始化</span></span><br><span class="line"></span><br><span class="line">c := [<span class="number">5</span>]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;       <span class="comment">//部分初始化，没有初始化的元素，自动赋值为0</span></span><br><span class="line">d := [<span class="number">5</span>]<span class="type">int</span>&#123;<span class="number">2</span>: <span class="number">10.</span> <span class="number">4</span>: <span class="number">20</span>&#125;  <span class="comment">//指定某个元素初始化</span></span><br></pre></td></tr></table></figure><br><strong>二维数组</strong><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a [<span class="number">3</span>][<span class="number">4</span>]<span class="type">int</span></span><br><span class="line">k := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i ++&#123;</span><br><span class="line">    <span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="number">4</span>; j ++&#123;</span><br><span class="line">        k ++</span><br><span class="line">        a[i][j] = k</span><br><span class="line">        fmt.Printf(<span class="string">&quot;a[%d][%d] = %d&quot;</span>, i, j, a[i][j])</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><strong>二维数组初始化</strong><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">b := [<span class="number">3</span>][<span class="number">4</span>]<span class="type">int</span>&#123;&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;, &#123;<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>&#125;,&#123;<span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>&#125;&#125;</span><br><span class="line">c := [<span class="number">3</span>][<span class="number">4</span>]<span class="type">int</span>&#123;&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;, &#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;&#125;  <span class="comment">//部分初始化</span></span><br><span class="line">d := [<span class="number">3</span>][<span class="number">4</span>]<span class="type">int</span>&#123;<span class="number">1</span>: &#123;<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>&#125;&#125;       <span class="comment">//指定初始化某一个</span></span><br></pre></td></tr></table></figure><br><strong>二维数组比较和赋值</strong><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;支持比较，只支持 == 或 !=,比较是不是每一个元素都一样，2个元素要同类型&#x27;</span></span><br><span class="line">a := [<span class="number">5</span>]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">b := [<span class="number">5</span>]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">c := [<span class="number">5</span>]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">fmt.Println(<span class="string">&quot;a == b&quot;</span>, a == b)</span><br></pre></td></tr></table></figure><br><strong>随机数</strong><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置种子，只需要一次</span></span><br><span class="line"><span class="comment">//如果种子的参数一样，每次运行程序产生的随机数都一样rand.Seed(666)  </span></span><br><span class="line">rand.Seed(time.Now().UnixNano())  <span class="comment">//以当前系统时间作为种子参数</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i ++ &#123;</span><br><span class="line">    <span class="comment">//产生随机数</span></span><br><span class="line">    <span class="comment">//fmt.Println(&quot;rand = &quot;, rand.Int())      随机很大的数</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;rand = &quot;</span>, rand.Intn(<span class="number">100</span>))  <span class="comment">//限制在100内的数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><strong>数组做函数参数是值拷贝(形参数组是实参数组的拷贝)</strong><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">modify</span><span class="params">(a [5]<span class="type">int</span>)</span></span>&#123;</span><br><span class="line">    a[<span class="number">0</span>] = <span class="number">666</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;modify: a =&quot;</span>, a)   <span class="comment">//modify: a = &#123;666,2,3,4,5&#125;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    a := [<span class="number">5</span>]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">modify(a)</span><br><span class="line">fmt.Println(<span class="string">&quot;main: a =&quot;</span>, a)         <span class="comment">//main: a = &#123;1,2,3,4,5&#125;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><br><strong>数组指针做函数参数</strong><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//p指向实现数组a，它是指向数组，他是数组指针</span></span><br><span class="line"><span class="comment">//*p代表指针所指向的内存，就是是实参a</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">modify</span><span class="params">(p *[5]<span class="type">int</span>)</span></span>&#123;</span><br><span class="line">    (*p)[<span class="number">0</span>] = <span class="number">666</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;modify: *a =&quot;</span>, *p)   <span class="comment">//modify: a = &#123;666,2,3,4,5&#125;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    a := [<span class="number">5</span>]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">    modify(&amp;a)</span><br><span class="line">    fmt.Println(<span class="string">&quot;main: a =&quot;</span>, a)         <span class="comment">//main: a = &#123;666,2,3,4,5&#125;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><br><a name="eVthD"></a></p><h2 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h2><ul><li>数组长度定义后无法修改，数组是值类型，每次传递都将产生一份副本。（太麻烦）</li><li>切片不是数组或数组指针，他通过内部指针和相关属性引用数组片段，以实现变长方案</li><li>slice并不是动态数组，而是一个引用类型。slice总是指向一个底层array.它不需要长度</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2023/png/29618862/1679907201081-490edaf4-7206-44e5-9094-e76bc9fc0b39.png#averageHue=%23eeeeee&amp;clientId=u7d93236d-ed98-4&amp;from=paste&amp;height=173&amp;id=u348d6995&amp;originHeight=260&amp;originWidth=622&amp;originalType=binary&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;size=47306&amp;status=done&amp;style=none&amp;taskId=u3cab35f9-ed6f-4fde-ba8c-bc8c6d6ace1&amp;title=&amp;width=414.6666666666667" alt="1679907196632.png"><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[low:high:max]</span><br><span class="line">low: 下标的起点</span><br><span class="line">high: 下标的终点（不包括此下标）,[a[low]m a[high]) 左闭右开</span><br><span class="line">       <span class="built_in">len</span> = high - low, 长度</span><br><span class="line"><span class="built_in">cap</span> = max - low, 容量</span><br></pre></td></tr></table></figure><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    a := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">    s := a[<span class="number">0</span>:<span class="number">3</span>:<span class="number">5</span>]</span><br><span class="line">    fmt.Println(<span class="string">&quot;s =&quot;</span>, s)              <span class="comment">//s = [1 2 3]</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;len(s) =&quot;</span>, <span class="built_in">len</span>(s))    <span class="comment">//len(s) = 3</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;cap(s) = &quot;</span>, <span class="built_in">cap</span>(s))   <span class="comment">//cap(s) = 3</span></span><br><span class="line"></span><br><span class="line">    s = a[<span class="number">1</span>:<span class="number">4</span>:<span class="number">5</span>]</span><br><span class="line">    fmt.Println(<span class="string">&quot;s =&quot;</span>, s)              <span class="comment">//s = [2 3 4]</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;len(s) =&quot;</span>, <span class="built_in">len</span>(s))   <span class="comment">//len(s) = 4-1=3</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;cap(s) = &quot;</span>, <span class="built_in">cap</span>(s))  <span class="comment">//cap(s) = 5-1=4</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><strong>切片和数组区别</strong><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//数组[]里面的长度是固定的一个常量，数组不能修改长度，len和cap永远都是5</span></span><br><span class="line">a := [<span class="number">5</span>]<span class="type">int</span>&#123;&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;len = %d, cap = %d\n&quot;</span>, <span class="built_in">len</span>(a), <span class="built_in">cap</span>(a)) </span><br><span class="line"></span><br><span class="line"><span class="comment">//切片，[]里面是空的，或者为...切片的长度或容易可以不固定</span></span><br><span class="line">s := []<span class="type">int</span>&#123;&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;l: len = %d, cap = %d\n&quot;</span>, <span class="built_in">len</span>(s), <span class="built_in">cap</span>(s))</span><br><span class="line"></span><br><span class="line">s = <span class="built_in">append</span>(s, <span class="number">11</span>) <span class="comment">//给切片末尾追加一个成员</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;append: len = %d, cap = %d\n&quot;</span>, <span class="built_in">len</span>(s), <span class="built_in">cap</span>(s))</span><br></pre></td></tr></table></figure><br><strong>切片的创建</strong><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1. 自动推导类型，同时初始化</span></span><br><span class="line">s1 := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line">fmt.Println(<span class="string">&quot;s1 = &quot;</span>, s1)</span><br><span class="line"></span><br><span class="line"><span class="comment">//2. 借助make函数，格式make(切片类型，长度，容量)</span></span><br><span class="line">s2 := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">5</span>, <span class="number">10</span>)</span><br><span class="line">fmt.Printf(<span class="string">&quot;len = %d, cap = %d\n&quot;</span>, <span class="built_in">len</span>(s2), <span class="built_in">cap</span>(s2))</span><br><span class="line"></span><br><span class="line"><span class="comment">//3. 没有指定容量，默认容量和长度一样</span></span><br><span class="line">s3 := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">5</span>)</span><br><span class="line">fmt.Printf(<span class="string">&quot;len = %d, cap = %d\n&quot;</span>, <span class="built_in">len</span>(s3), <span class="built_in">cap</span>(s3))</span><br></pre></td></tr></table></figure><br><strong>切片的截取</strong><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">array := []<span class="type">int</span>&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;</span><br><span class="line"><span class="comment">//[low:high:max] 取下标从low开始的元素，len=high-low, cap=max-low</span></span><br><span class="line">s1 := array[:] <span class="comment">//[0:len(array):len(array)]  不指定容量和长度一样</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//操作某一个元素和数组操作方式一样</span></span><br><span class="line">data := array[<span class="number">1</span>]</span><br><span class="line">fmt.Println(<span class="string">&quot;data = &quot;</span>, data)</span><br><span class="line"></span><br><span class="line">s2 := array[<span class="number">3</span>:<span class="number">6</span>:<span class="number">7</span>]  <span class="comment">//a[3], a[4], a[5] len = 6-3=3 cap=7-3=4</span></span><br><span class="line"></span><br><span class="line">s3 := array[:<span class="number">6</span>]     <span class="comment">//从0开始，去6个元素，容量也是6，常用</span></span><br><span class="line"></span><br><span class="line">s4 := array[<span class="number">3</span>:]     <span class="comment">//从下标为3开始，到结尾</span></span><br></pre></td></tr></table></figure><br> <strong>切片与底层数组关系</strong><br /><img src="https://cdn.nlark.com/yuque/0/2023/png/29618862/1679910304479-34e31c62-8156-4965-b3a6-20c4ea383fcd.png#averageHue=%23fefefe&amp;clientId=u7d93236d-ed98-4&amp;from=paste&amp;height=197&amp;id=u398f3d02&amp;originHeight=296&amp;originWidth=717&amp;originalType=binary&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;size=55356&amp;status=done&amp;style=none&amp;taskId=ue0c68e4c-f99c-42e2-be2c-ac61fe6d8a7&amp;title=&amp;width=478" alt="1679910300403.png"><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    a := []<span class="type">int</span>&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;</span><br><span class="line"><span class="comment">//新切片</span></span><br><span class="line">    s1 := a[<span class="number">2</span>:<span class="number">5</span>]  <span class="comment">//从a[2]开始， 取3个元素</span></span><br><span class="line">    s1[<span class="number">1</span>] = <span class="number">666</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;s1 =&quot;</span>, s1)</span><br><span class="line">    fmt.Println(<span class="string">&quot;a = &quot;</span>, a)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//另外的切片</span></span><br><span class="line">    s2 := s1[<span class="number">2</span>:<span class="number">7</span>]</span><br><span class="line">    s2[<span class="number">2</span>] = <span class="number">888</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;s2 = &quot;</span>, s2)</span><br><span class="line">    fmt.Println(<span class="string">&quot;a = &quot;</span>, a)</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><img src="https://cdn.nlark.com/yuque/0/2023/png/29618862/1679910492839-8105f50c-5525-4347-b674-326f4b21a6af.png#averageHue=%23111110&amp;clientId=u7d93236d-ed98-4&amp;from=paste&amp;height=40&amp;id=u1abc0075&amp;originHeight=60&amp;originWidth=296&amp;originalType=binary&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;size=15856&amp;status=done&amp;style=none&amp;taskId=ua28d72b5-fcfb-44bb-9c56-94d7528523d&amp;title=&amp;width=197.33333333333334" alt="1679910484977.png"><br /><strong>append</strong></p><ul><li>在切片末尾追加，返回新的slice对象</li><li><p>append函数会智能的底层数组的容量增长，一旦超过原底层数组容量，通常以2倍容量重新分配底层数组， 并复制原来的数据</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">s1 := []<span class="type">int</span>&#123;&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;len = %d, cap = %d\n&quot;</span>, <span class="built_in">len</span>(s1), <span class="built_in">cap</span>(s1))</span><br><span class="line">fmt.Println(<span class="string">&quot;s1 = &quot;</span>, s1)</span><br><span class="line"></span><br><span class="line"><span class="comment">//在原切片的末尾添加元素</span></span><br><span class="line">s1 = <span class="built_in">append</span>(s1, <span class="number">1</span>)</span><br><span class="line">s1 = <span class="built_in">append</span>(s2, <span class="number">1</span>)</span><br><span class="line">s1 = <span class="built_in">append</span>(s3, <span class="number">1</span>)</span><br><span class="line">fmt.Println(<span class="string">&quot;len = %d, cap = %d\n&quot;</span>, <span class="built_in">len</span>(s1), <span class="built_in">cap</span>(s1))</span><br><span class="line">fmt.Println(<span class="string">&quot;s1 =&quot;</span>, s1)</span><br><span class="line"></span><br><span class="line">s2 := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">fmt.Println(<span class="string">&quot;s2 = &quot;</span>, s2)</span><br><span class="line">s2 = <span class="built_in">append</span>(s1, <span class="number">5</span>)</span><br><span class="line">s2 = <span class="built_in">append</span>(s2, <span class="number">5</span>)</span><br><span class="line">s2 = <span class="built_in">append</span>(s2, <span class="number">5</span>)</span><br><span class="line">fmt.Println(<span class="string">&quot;s2 = &quot;</span>, s2)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2023/png/29618862/1679910977134-4138e644-3d45-4ae7-ab35-2aec649732e6.png#averageHue=%232d2b29&amp;clientId=u7d93236d-ed98-4&amp;from=paste&amp;id=u229e1ac9&amp;originHeight=87&amp;originWidth=201&amp;originalType=binary&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;size=14850&amp;status=done&amp;style=none&amp;taskId=ucd428055-9a87-4068-837e-3140f896fda&amp;title=" alt="1679910969931.png"><br /><strong>append增长的特点</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">//如果超过原来的容量，通常以2倍容量扩容</span></span><br><span class="line">    s := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>, <span class="number">1</span>)  <span class="comment">//容量为1</span></span><br><span class="line">    oldCap := <span class="built_in">cap</span>(s)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">8</span>; i++ &#123;</span><br><span class="line">        s = <span class="built_in">append</span>(s, i)</span><br><span class="line">        <span class="keyword">if</span> newCap := <span class="built_in">cap</span>(s); oldCap &lt; newCap &#123;</span><br><span class="line">            fmt.Printf(<span class="string">&quot;cap: %d ===&gt; %d\n&quot;</span>, oldCap, newCap)</span><br><span class="line">            oldCap = newCap</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2023/png/29618862/1679911432027-1f6969d8-08b0-45f4-b1ee-433274dfabdf.png#averageHue=%2333312f&amp;clientId=u7d93236d-ed98-4&amp;from=paste&amp;height=45&amp;id=u2d4f8446&amp;originHeight=68&amp;originWidth=152&amp;originalType=binary&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;size=12924&amp;status=done&amp;style=none&amp;taskId=u3671b185-1cc8-4efa-b117-1b633bf9489&amp;title=&amp;width=101.33333333333333" alt="1679911424544.png"><br /><strong>copy</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">srcSlice := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>&#125;</span><br><span class="line">dstSlice := []<span class="type">int</span>&#123;<span class="number">6</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">6</span>&#125;</span><br><span class="line"><span class="built_in">copy</span>(dstSlice, srcSlice)</span><br><span class="line">fmt.Println(<span class="string">&quot;dst = &quot;</span>, dstSlice)</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;结果&#x27;</span></span><br><span class="line">dst = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">6</span>&#125;</span><br></pre></td></tr></table></figure><p><strong>切片做函数参数：切片是引用传递，数组是值传递</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">InitData</span><span class="params">(s []<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    rand.Seed(time.Now().UnixNano())  <span class="comment">//随机种子</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(s); i ++ &#123;</span><br><span class="line">        s[i] = rand.Intn(<span class="number">100</span>)        <span class="comment">//100以内的随机数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BubbleSort</span><span class="params">(s []<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(s)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span> - <span class="number">1</span>; i ++ &#123;</span><br><span class="line">        <span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="built_in">len</span> - i - <span class="number">1</span>; j ++ &#123;</span><br><span class="line">            <span class="keyword">if</span> s[j] &gt; s[j + <span class="number">1</span>]</span><br><span class="line">                s[j], s[j + <span class="number">1</span>] = s[j + <span class="number">1</span>], s[j]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    n := <span class="number">10</span>;</span><br><span class="line">    s := <span class="built_in">make</span>([]<span class="type">int</span>, n)</span><br><span class="line"></span><br><span class="line">    InitData(s)</span><br><span class="line">    fmt.Println(<span class="string">&quot;排序前&quot;</span>, s)</span><br><span class="line">    BubbleSort(s)</span><br><span class="line">    fmt.Println(<span class="string">&quot;排序后&quot;</span>, s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="Knv2A"></a></p><h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2></li><li><p>Go中的map（映射、字典）是一个无序的key-value对集合</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">info := <span class="keyword">map</span>[<span class="type">int</span>]<span class="type">string</span>&#123;  <span class="comment">//int为key, string为value</span></span><br><span class="line"><span class="number">110</span>: <span class="string">&quot;mike&quot;</span>,</span><br><span class="line"><span class="number">111</span>: <span class="string">&quot;yoyo&quot;</span>,</span><br><span class="line"><span class="number">112</span>: <span class="string">&quot;lily&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>map格式为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">map</span>[keyType]valueType</span><br></pre></td></tr></table></figure></li><li><p>在map里所有的键都是唯一的，必须支持==和!=操作符，切片、函数以及包含切片的结构类型由于具有引用语义，不能作为映射的键，会出现错误</p></li><li>map中的value可以是任意类型</li><li>map的键和值类型可以不一样</li><li>map中所有的键的类型必须一样</li></ul><p>注意：map是无序的，无法决定返回顺序，每次打印结果可能不一样</p><p><strong>map创建</strong><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> m1 <span class="keyword">map</span>[<span class="type">int</span>]<span class="type">string</span>         <span class="comment">//只是声明一个map,并没有初始化</span></span><br><span class="line">fmt.Println(<span class="string">&quot;m1 = &quot;</span>, m1)</span><br><span class="line">fmt.Println(<span class="string">&quot;len =&quot;</span>, <span class="built_in">len</span>(m1)) <span class="comment">//对于map只有len没有cap</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;可以通过make创建&#x27;</span></span><br><span class="line">m2 := <span class="built_in">make</span>(<span class="keyword">map</span> [<span class="type">int</span>]<span class="type">string</span>)</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;并且指定长度，只是指定了容量，但是里面却是一个数据也没有&#x27;</span></span><br><span class="line">m3 := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]<span class="type">string</span>, <span class="number">2</span>))</span><br><span class="line">m3[<span class="number">1</span>] = <span class="string">&quot;mike&quot;</span></span><br><span class="line">m3[<span class="number">2</span>] = <span class="string">&quot;c++&quot;</span></span><br><span class="line">m3[<span class="number">3</span>] = <span class="string">&quot;lili&quot;</span>   <span class="comment">//虽然指定容量为2，但是不够的话会自动扩充</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;声明时直接初始化&#x27;</span></span><br><span class="line">m4 := <span class="keyword">map</span>[<span class="type">int</span>] <span class="type">string</span> &#123;<span class="number">1</span> : <span class="string">&quot;mike&quot;</span>, <span class="number">2</span> : <span class="string">&quot;go&quot;</span>, <span class="number">3</span> : <span class="string">&quot;c++&quot;</span>, <span class="number">1</span> : <span class="string">&quot;lalal&quot;</span>&#125; <span class="comment">//错误：键值应该唯一</span></span><br></pre></td></tr></table></figure><br><img src="https://cdn.nlark.com/yuque/0/2023/png/29618862/1680597916778-2da79570-fbcc-44e2-a66d-b46e99dc709d.png#averageHue=%23121010&amp;clientId=uad439440-e395-4&amp;from=paste&amp;height=67&amp;id=ue28aa395&amp;originHeight=100&amp;originWidth=239&amp;originalType=binary&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;size=22880&amp;status=done&amp;style=none&amp;taskId=u50d0a3f1-5f34-4c7c-9baf-c83cde08526&amp;title=&amp;width=159.33333333333334" alt="1680597911752.png"><br /><strong>map赋值</strong><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">m4 := <span class="keyword">map</span>[<span class="type">int</span>] <span class="type">string</span> &#123;<span class="number">1</span> : <span class="string">&quot;mike&quot;</span>, <span class="number">2</span> : <span class="string">&quot;go&quot;</span>&#125;</span><br><span class="line"><span class="comment">//如果已经存在的key值，修改内容</span></span><br><span class="line">m4[<span class="number">1</span>] = <span class="string">&quot;c++&quot;</span></span><br><span class="line">m4[<span class="number">3</span>] = <span class="string">&quot;java&quot;</span> <span class="comment">//没有的key则进行追加，map底层自动扩容，和append类似</span></span><br></pre></td></tr></table></figure><br><strong>map遍历</strong><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">m := <span class="keyword">map</span>[<span class="type">int</span>]<span class="type">string</span>&#123;<span class="number">1</span> : <span class="string">&quot;mike&quot;</span>, <span class="number">2</span> : <span class="string">&quot;yoyo&quot;</span>, <span class="number">3</span> : <span class="string">&quot;go&quot;</span>&#125;</span><br><span class="line"><span class="comment">//第一个返回的为key,第二个返回的为value，遍历结果无序</span></span><br><span class="line"><span class="keyword">for</span> key, value := <span class="keyword">range</span> m &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%d====&gt; %s\n&quot;</span>, key, value)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如何判断一个key值是否存在</span></span><br><span class="line"><span class="comment">//第一个返回值为key所对应的value，第二个返回值为key是否存在的条件，存在ok为true</span></span><br><span class="line">value, ok := m[<span class="number">1</span>]</span><br><span class="line"><span class="keyword">if</span> ok == <span class="literal">true</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;m[1] =&quot;</span>, value)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;key不存在&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><strong>map删除</strong><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">delete</span>(m ,<span class="number">1</span>) <span class="comment">//删除key = 1的</span></span><br></pre></td></tr></table></figure><br><strong>map做函数参数：是引用传递</strong><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">(m <span class="keyword">map</span>[<span class="type">int</span>]<span class="type">string</span>)</span></span> &#123;</span><br><span class="line">    <span class="built_in">delete</span>(m, <span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    m := <span class="keyword">map</span>[<span class="type">int</span>]<span class="type">string</span>&#123;<span class="number">1</span> : <span class="string">&quot;mike&quot;</span>, <span class="number">2</span> : <span class="string">&quot;yoyo&quot;</span>, <span class="number">3</span> : <span class="string">&quot;go&quot;</span>&#125;</span><br><span class="line">    test(m)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> goland </category>
          
      </categories>
      
      
        <tags>
            
            <tag> goland </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>goland函数类型</title>
      <link href="/2022/05/02/post8/"/>
      <url>/2022/05/02/post8/</url>
      
        <content type="html"><![CDATA[<h1 id="三、函数类型"><a href="#三、函数类型" class="headerlink" title="三、函数类型"></a>三、函数类型</h1><h2 id="函数类型"><a href="#函数类型" class="headerlink" title="函数类型"></a><strong>函数类型</strong></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Add</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123; <span class="keyword">return</span> a + b&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Minus</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;<span class="keyword">return</span> a - b&#125;</span><br><span class="line"><span class="keyword">type</span> FuncType <span class="function"><span class="keyword">func</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span></span> <span class="type">int</span>  <span class="comment">//没有函数名，没有&#123;&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> result <span class="type">int</span> </span><br><span class="line">    result = Add(<span class="number">1</span>, <span class="number">1</span>) <span class="comment">//普通调用</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> fTest FuncType</span><br><span class="line">    fTest = ADD</span><br><span class="line">    result = fTest(<span class="number">10</span>, <span class="number">20</span>) <span class="comment">//等价于Add(1, 1)</span></span><br><span class="line"></span><br><span class="line">    fTest = Minus</span><br><span class="line">    result = fTest(<span class="number">10</span>, <span class="number">20</span>) <span class="comment">//等价于Minus(10, 20)</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="ewtHA"></a></p><h2 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> FuncType <span class="function"><span class="keyword">func</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span></span> <span class="type">int</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Add</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123; <span class="keyword">return</span> a + b&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Minus</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;<span class="keyword">return</span> a - b&#125;</span><br><span class="line"><span class="comment">//回调函数，函数有一个参数是函数类型，这个函数就是回调函数</span></span><br><span class="line"><span class="comment">//多态，调用同一个接口，不同的表现，可以实现不同的功能，加减乘除</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Calc</span><span class="params">(a, b <span class="type">int</span>, fTest FuncType)</span></span> (result <span class="type">int</span>) &#123;</span><br><span class="line">    result = fTest(a, b) <span class="comment">//这个函数还没有实现，但是运行不出错</span></span><br><span class="line">    result = Add(a, b)  <span class="comment">//Add()必须先定义后，才能调用，否则就会出错</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    a := Calc(<span class="number">1</span>, <span class="number">1</span>, Add)</span><br><span class="line">    fmt.Println(<span class="string">&quot;a = &quot;</span>, a)</span><br><span class="line">    b := Calc(<span class="number">1</span>, <span class="number">1</span>, Minus)</span><br><span class="line">    fmt.Println(<span class="string">&quot;b = &quot;</span>, b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="of8R7"></a></p><h2 id="闭包（匿名函数）"><a href="#闭包（匿名函数）" class="headerlink" title="闭包（匿名函数）"></a>闭包（匿名函数）</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    a := <span class="number">10</span></span><br><span class="line">    str := <span class="string">&quot;Mike&quot;</span></span><br><span class="line"><span class="comment">//匿名函数，没有函数名字，函数定义，还没有调用</span></span><br><span class="line">    f1 := <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;a = &quot;</span>, a)</span><br><span class="line">    &#125;</span><br><span class="line">    f1 ()</span><br><span class="line"></span><br><span class="line">    <span class="string">&#x27;或者&#x27;</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;a = %d, str = %s\n&quot;</span>, a, str)</span><br><span class="line">    &#125;()  <span class="comment">//后面的()代表调用此匿名函数</span></span><br><span class="line"></span><br><span class="line">    <span class="string">&#x27;有参数&#x27;</span></span><br><span class="line">    f3 := <span class="function"><span class="keyword">func</span><span class="params">(i, j <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;i = %d, j = %d\n&quot;</span>, i, j)</span><br><span class="line">    &#125;</span><br><span class="line">    f3(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span><span class="params">(i, j <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">         fmt.Printf(<span class="string">&quot;i = %d, j = %d\n&quot;</span>, i, j)</span><br><span class="line">    &#125;(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    <span class="string">&#x27;匿名函数，有参数有返回值&#x27;</span></span><br><span class="line">    x, y := <span class="function"><span class="keyword">func</span><span class="params">(i, j <span class="type">int</span>)</span></span> (max, min <span class="type">int</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> i &gt; j &#123;</span><br><span class="line">            max = i</span><br><span class="line">            min = j</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            max = j</span><br><span class="line">            min = i</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">&#125;(<span class="number">10</span>, <span class="number">20</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="闭包捕获外部变量特点"><a href="#闭包捕获外部变量特点" class="headerlink" title="闭包捕获外部变量特点"></a><strong>闭包捕获外部变量特点</strong></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//闭包以引用方式捕获外部变量，最后发现内部和外部打印的结果都是a=666, str=go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    a := <span class="number">10</span></span><br><span class="line">    str := <span class="string">&quot;mike&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        a = <span class="number">666</span></span><br><span class="line">        str = <span class="string">&quot;go&quot;</span></span><br><span class="line">        fmt.Printf(<span class="string">&quot;内部:a = %d, str = %s\n&quot;</span>, a, str)</span><br><span class="line">    &#125;()  <span class="comment">//()代表直接调用</span></span><br><span class="line"></span><br><span class="line">    fmt.Printf(<span class="string">&quot;外部:a = %d, str = %s\n&quot;</span>, a, str)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="闭包特点"><a href="#闭包特点" class="headerlink" title="闭包特点"></a><strong>闭包特点</strong></h2><ul><li><p>它不关心这些捕获了的变量和常量是否已经超出了作用域，所以只有闭包还在使用它，这些变量就还会存在</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//函数的返回值时一个匿名函数，返回一个函数类型</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test02</span><span class="params">()</span></span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> x <span class="type">int</span>      <span class="comment">//没有初始化，值为0</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">int</span> &#123;</span><br><span class="line">        x ++</span><br><span class="line">        <span class="keyword">return</span> x * x</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test01</span><span class="params">()</span></span> <span class="type">int</span> &#123;</span><br><span class="line">     <span class="comment">//函数被调用时，x才会分配空间，才初始化为0</span></span><br><span class="line">    <span class="keyword">var</span> x <span class="type">int</span>       <span class="comment">//没有初始化，值为0</span></span><br><span class="line">    x++</span><br><span class="line">    <span class="keyword">return</span> x * x    <span class="comment">//函数调用完毕，x自动释放</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(test01()) <span class="comment">//1</span></span><br><span class="line">    fmt.Println(test01()) <span class="comment">//1</span></span><br><span class="line">    fmt.Println(test01()) <span class="comment">//1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回值是一个匿名函数，返回一个函数类型，通过f来调用返回的匿名函数，f来调用闭包函数</span></span><br><span class="line">    f := test02()  <span class="comment">//返回值是一个匿名函数</span></span><br><span class="line">    fmt.Println(f())  <span class="comment">//1</span></span><br><span class="line">    fmt.Println(f())  <span class="comment">//2</span></span><br><span class="line">    fmt.Println(f())  <span class="comment">//3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="dTtcl"></a></p><h2 id="延迟调用defer-只能出现在函数或方法的内部"><a href="#延迟调用defer-只能出现在函数或方法的内部" class="headerlink" title="延迟调用defer,只能出现在函数或方法的内部"></a>延迟调用defer,只能出现在函数或方法的内部</h2></li><li><p>defer延迟调用，main函数结束的一刹那前调用</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> fmt.Println(<span class="string">&quot;bbb&quot;</span>)</span><br><span class="line">    fmt.Println(<span class="string">&quot;aaa&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="string">&#x27;运行结果&#x27;</span></span><br><span class="line">aaa</span><br><span class="line">bbb</span><br></pre></td></tr></table></figure></li><li><p>多个defer一起调用，出现先进后出,哪怕函数或某个延迟调用发生村务，这些调用依旧会被执行</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">(x <span class="type">int</span>)</span></span> &#123;fmt.Println(<span class="number">100</span> / x)&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> fmt.Println(<span class="string">&quot;aaa&quot;</span>)</span><br><span class="line">    <span class="keyword">defer</span> fmt.Println(<span class="string">&quot;bbb&quot;</span>)</span><br><span class="line">    <span class="keyword">defer</span> test(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">defer</span> fmt.Println(<span class="string">&quot;ccc&quot;</span>)</span><br><span class="line">&#125;   <span class="comment">// ccc   bbb   aaa   崩掉了</span></span><br></pre></td></tr></table></figure></li><li><p>defer和匿名函数结合使用</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    a := <span class="number">10</span></span><br><span class="line">    b := <span class="number">20</span></span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;内部a = %d, b = %d\n&quot;</span>, a, b)    <span class="comment">//结果：外部a=111 b=222 | 内部a=111 b=222</span></span><br><span class="line">    &#125; ()  <span class="comment">//()代表调用此匿名函数</span></span><br><span class="line"></span><br><span class="line">     <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">(a ,b <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;内部a = %d, b = %d\n&quot;</span>, a, b)</span><br><span class="line">    &#125; (a, b)  <span class="comment">//()代表调用此匿名函数,把参数传递过去，已经先传递参数了，只是没有调用</span></span><br><span class="line">                                                   <span class="comment">//结果：外部a=111 b=222 | 内部a=10 b=20</span></span><br><span class="line">                                                   <span class="comment">//等价于defer func(a, b, int)&#123;</span></span><br><span class="line">                                                   <span class="comment">//        fmt.Println(&quot;内部a = %d, b = %d\n&quot;, a, b)</span></span><br><span class="line">                                                   <span class="comment">//     &#125;(10, 20)</span></span><br><span class="line">    a = <span class="number">111</span></span><br><span class="line">    b = <span class="number">222</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;外部a = %d, b = %d\n&quot;</span>, a, b)   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="获取命令行参数"><a href="#获取命令行参数" class="headerlink" title="获取命令行参数"></a><strong>获取命令行参数</strong></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;os&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    list := as.Args   <span class="comment">//返回是一个列表 []string</span></span><br><span class="line">    n := <span class="built_in">len</span>(list)</span><br><span class="line">    fmt.Println(<span class="string">&quot;n = &quot;</span>, n)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;list[%d] = %s\n&quot;</span>, i, list[i])</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i, data <span class="keyword">range</span> list &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;list[%d] = %s\n&quot;</span>, i, data)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="string">&#x27;运行&#x27;</span></span><br><span class="line"><span class="keyword">go</span> run main.<span class="keyword">go</span> a b</span><br><span class="line">n=<span class="number">3</span></span><br><span class="line">list[<span class="number">0</span>]=main.<span class="keyword">go</span></span><br><span class="line">list[<span class="number">1</span>]=a</span><br><span class="line">list[<span class="number">2</span>]=b</span><br></pre></td></tr></table></figure><p><a name="U0TSZ"></a></p><h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2></li><li><p><strong>全局变量</strong></p><ul><li>定义在函数外部的变量是全局变量，全局变量在任何地方都可以使用<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">fun test() &#123;fmt.Println(<span class="string">&quot;test a = &quot;</span>, a)&#125;</span><br><span class="line"><span class="keyword">var</span> a <span class="type">int</span>  <span class="comment">//正确</span></span><br><span class="line">a := <span class="number">10</span>    <span class="comment">//错误</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    a = <span class="number">10</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;a = &quot;</span>, a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>局部变量</strong></p><ul><li>执行到定义变量的那句话，才开始分配空间，离开作用域自动释放<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;定义在&#123;&#125;里面的变量就是局部变量，只能在&#123;&#125;里面有效&#x27;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span></span> &#123;a := <span class="number">10</span> fmt.Println(<span class="string">&quot;a =&quot;</span>, a)&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> flag := <span class="number">3</span>, flag == <span class="number">3</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;flag = &quot;</span>, flag)</span><br><span class="line">    &#125;</span><br><span class="line">        flag = <span class="number">4</span>  <span class="comment">//错误，未定义</span></span><br><span class="line">        a = <span class="number">5</span>     <span class="comment">//错误，未定义</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>局部变量与全局变量同名</strong></p><ul><li>就近原则<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a <span class="type">byte</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> a <span class="type">int</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;%T\n&quot;</span>, a)           <span class="comment">//int</span></span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> a <span class="type">float32</span></span><br><span class="line">        fmt.Printf(<span class="string">&quot;%T\n&quot;</span>, a)       <span class="comment">//float32</span></span><br><span class="line">    &#125;</span><br><span class="line">    test()</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span></span>&#123;fmt.Printf(<span class="string">&quot;%T\n&quot;</span>, a)&#125;  <span class="comment">//uint8</span></span><br></pre></td></tr></table></figure><a name="pD1dp"></a><h2 id="工程管理"><a href="#工程管理" class="headerlink" title="工程管理"></a>工程管理</h2><strong>工作区</strong></li></ul></li><li><p>go代码必须放在工作区</p></li></ul><p><strong>包</strong></p><ul><li>go是以包作为管理，go语言程序会组织成若干个包，这些包都可以被其他项目引用</li><li>import “包名”</li><li><p>每个包都有对应一个独立的名字空间 package main | package calc</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main   <span class="comment">//必须</span></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;this is a test&quot;</span>)</span><br><span class="line">    fmt.Println(<span class="string">&quot;os.Args = &quot;</span>, os.Args)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>点操作(调用函数，无需通过包名)</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main   <span class="comment">//必须</span></span><br><span class="line"><span class="keyword">import</span> . <span class="string">&quot;fmt&quot;</span>   </span><br><span class="line"><span class="keyword">import</span> . <span class="string">&quot;os&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    Println(<span class="string">&quot;this is a test&quot;</span>)</span><br><span class="line">    Println(<span class="string">&quot;os.Args = &quot;</span>, Args)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>别名操作(给包起别名)</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main   <span class="comment">//必须</span></span><br><span class="line"><span class="keyword">import</span> os <span class="string">&quot;fmt&quot;</span>   </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    os.Println(<span class="string">&quot;this is a test&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>忽略操作(_操作是引入包，而不直接使用包里面的函数，而是用来调用该包里面的init函数)</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> _ <span class="string">&quot;fmt&quot;</span></span><br></pre></td></tr></table></figure><p><strong>同级目录</strong></p></li><li><p>同一个目录，包名必须一样</p></li><li>同一个目录，调用别的文件的函数，直接调用即可，无需包名引用</li></ul><p>同一个文件下的俩个go程序：main.go和test.go<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;this is a test&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    test()   <span class="comment">//this is a test</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><strong>不同目录</strong></p><ul><li>不同目录，包名不一样package main | package calc</li><li>调用不同包里面的函数，格式：包名.函数名()  calc.Add(10, 20)</li><li>调用别的包函数，这个包函数名字如果首字母必须是大写 func Add()，才可以让别人调用<ul><li><strong>src目录下的main.go</strong><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;calc&quot;</span></span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;fmt.Println(<span class="string">&quot;this is main init&quot;</span>)&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    a := calc.Add(<span class="number">10</span>, <span class="number">20</span>)</span><br><span class="line">    fmt.Println(<span class="string">&quot;a = &quot;</span>, a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><ul><li><strong>src/calc目录下的calc.go</strong><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> calc</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;this is calc init&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Add</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><strong>init函数</strong><br /><img src="https://cdn.nlark.com/yuque/0/2023/png/29618862/1679456530811-9739809d-9e25-4d84-bf55-a57c6e567fb6.png#averageHue=%23f8f4f0&amp;clientId=u7d93236d-ed98-4&amp;from=paste&amp;height=337&amp;id=u230e231f&amp;originHeight=506&amp;originWidth=691&amp;originalType=binary&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;size=141616&amp;status=done&amp;style=none&amp;taskId=ub7d35d63-d5ac-4d9f-8f34-2b731631b5b&amp;title=&amp;width=460.6666666666667" alt="1679456525126.png"><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;运行结果&#x27;</span></span><br><span class="line">this is calc init</span><br><span class="line">this is main init</span><br><span class="line">a = <span class="number">30</span></span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> goland </category>
          
      </categories>
      
      
        <tags>
            
            <tag> goland </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>goland函数</title>
      <link href="/2022/04/27/post7/"/>
      <url>/2022/04/27/post7/</url>
      
        <content type="html"><![CDATA[<h1 id="二、函数"><a href="#二、函数" class="headerlink" title="二、函数"></a>二、函数</h1><ul><li><p>无参无返回值</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">MyFunc</span><span class="params">()</span></span>&#123;</span><br><span class="line">    a := <span class="number">666</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;a =&quot;</span>, a)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    MyFunc</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>有参无返回值</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">MyFunc</span><span class="params">(a <span class="type">int</span>)</span></span>&#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;a = &quot;</span>,a)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">MyFunc1</span><span class="params">(a <span class="type">int</span>, b <span class="type">int</span>)</span></span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">MyFunc2</span><span class="params">(a, b <span class="type">int</span>)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">MyFunc3</span><span class="params">(a, b <span class="type">int</span>, c <span class="type">float64</span>, e <span class="type">int</span>)</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    MyFunc(<span class="number">666</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>不定参数类型</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//...int 类型这样的类型， ...type不定参数类型</span></span><br><span class="line"><span class="comment">//注意：不定参数，必须放到形参中的最后一个参数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">MyFunc1</span><span class="params">(args ...<span class="type">int</span>)</span></span>&#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;len(args) = &quot;</span>, args)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">MyFunc2</span><span class="params">(a <span class="type">int</span>, args ...<span class="type">int</span>)</span></span>&#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;len(args) = &quot;</span>, args)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">MyFunc3</span><span class="params">(args ...<span class="type">int</span>, a <span class="type">int</span>)</span></span>&#123;      <span class="comment">//错误</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;len(args) = &quot;</span>, args)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    MyFunc1()</span><br><span class="line">    MyFunc1(<span class="number">666</span>)</span><br><span class="line">    MyFunc(<span class="number">11</span>, <span class="number">22</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>不定参数传递</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">myFunc</span><span class="params">(tmp ...<span class="type">int</span>)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span> _, data := <span class="keyword">range</span> tmp &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;data = &quot;</span>, data)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">myFunc2</span><span class="params">(tmp ...<span class="type">int</span>)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span> _, data := <span class="keyword">range</span> tmp &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;data = &quot;</span>, data)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">(args ...<span class="type">int</span>)</span></span>&#123;</span><br><span class="line">   </span><br><span class="line">myFunc(args...)      <span class="comment">//全部元素传递给myFunc</span></span><br><span class="line">myFunc2(args[:<span class="number">2</span>]...) <span class="comment">//args[0]~args[2]（包含0，不包含数字2）,传递过去</span></span><br><span class="line">&#125;                        <span class="comment">//[0, 2)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">test(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>无参数有一个返回值</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">myFunc01</span><span class="params">()</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">666</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">myFunc01</span><span class="params">()</span></span> (result <span class="type">int</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">666</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">myFunc01</span><span class="params">()</span></span> (result <span class="type">int</span>) &#123;</span><br><span class="line">    result = <span class="number">666</span></span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>无参数有多个返回值</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">myFunc01</span><span class="params">()</span></span> (<span class="type">int</span>, <span class="type">int</span>, <span class="type">int</span>)&#123; <span class="keyword">return</span> <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">myFunc02</span><span class="params">()</span></span> (a <span class="type">int</span>, b <span class="type">int</span>, c <span class="type">int</span>)&#123;</span><br><span class="line">    a, b, c = <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span></span><br><span class="line">    <span class="keyword">return</span> </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    a, b, c := myfunc02()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>有参有返回值的</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">MaxAndMin</span><span class="params">(a, b <span class="type">int</span>)</span></span> (max, min <span class="type">int</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> a &gt; b &#123;</span><br><span class="line">        max = a</span><br><span class="line">        min = b</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        max = b</span><br><span class="line">        min = a</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    max, min := MaxAndMin(<span class="number">10</span>, <span class="number">20</span>)</span><br><span class="line">    max, _ := MaxAndMin(<span class="number">10</span>, <span class="number">20</span>)   <span class="comment">//匿名变量丢弃某个返回值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>递归（结果：c = 1 b = 2 a = 3 main）</p></li></ul><p><img src="https://cdn.nlark.com/yuque/0/2023/png/29618862/1679390361802-32f2f9e6-66f9-4c86-b9c0-694ccfed051a.png#averageHue=%23fbfbfb&amp;clientId=ud8920060-c3f2-4&amp;from=paste&amp;height=351&amp;id=u52e6a0ab&amp;originHeight=527&amp;originWidth=1166&amp;originalType=binary&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;size=237608&amp;status=done&amp;style=none&amp;taskId=u3378062d-0525-4ce9-a8e8-e3018828dd3&amp;title=&amp;width=777.3333333333334" alt="1679390356039.png"><br /><img src="https://cdn.nlark.com/yuque/0/2023/png/29618862/1679390515290-f9393eca-2538-4679-b4a3-e6d400cc18d9.png#averageHue=%23fcfcfc&amp;clientId=ud8920060-c3f2-4&amp;from=paste&amp;height=351&amp;id=u20fa9b9f&amp;originHeight=527&amp;originWidth=1177&amp;originalType=binary&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;size=213825&amp;status=done&amp;style=none&amp;taskId=u25a19a16-83c3-4678-b8a8-f4ac1b61e96&amp;title=&amp;width=784.6666666666666" alt="1679390506371.png"><br><a name="rhNN3"></a></p>]]></content>
      
      
      <categories>
          
          <category> goland </category>
          
      </categories>
      
      
        <tags>
            
            <tag> goland </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>goland基础</title>
      <link href="/2022/04/27/post6/"/>
      <url>/2022/04/27/post6/</url>
      
        <content type="html"><![CDATA[<h1 id="一、基础"><a href="#一、基础" class="headerlink" title="一、基础"></a>一、基础</h1><p><strong>编译运行</strong></p><ul><li>go build xxx.go：编译go代码，生成可执行程序xxx,然后运行可执行程序 xxx</li><li>go run xxx.go：不生成程序，直接运行</li></ul><p><strong>变量名声明格式(var+变量名+类型)：</strong></p><ul><li>var a int（定义一个变量）</li><li>导入包必须使用否则报错</li><li>变量声明了必须使用否则报错</li><li>只是声明，没有初始化的变量，默认值为0</li><li>同一个{ }里，声明的变量名是唯一的</li><li>var b, c int（定义多个变量）</li></ul><p><strong>变量初始化方式</strong><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;方式1&#x27;</span></span><br><span class="line"><span class="keyword">var</span> b <span class="type">int</span> = <span class="number">10</span></span><br><span class="line">b = <span class="number">30</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;方式2(常用)：自动推导类型，必须初始化，通过初始化的值确定类型&#x27;</span></span><br><span class="line">c := <span class="number">30</span></span><br><span class="line"></span><br><span class="line">b=<span class="number">40</span>(赋值)</span><br><span class="line">b=<span class="number">50</span>(赋值)</span><br><span class="line">c := <span class="number">40</span>(错误)</span><br><span class="line">c = <span class="number">40</span>(正确)</span><br></pre></td></tr></table></figure></p><ul><li>赋值可以多次，但是类型推导只能使用一次，用于初始化那次</li></ul><p><strong>Println和Printf</strong><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fmt.Println(<span class="string">&quot;a = &quot;</span>, a, <span class="string">&quot;b = &quot;</span>, b, <span class="string">&quot;c = &quot;</span>, c)  <span class="comment">//一段一段出来，自动加换行</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;a = %d, b = %d, c = %d\n&quot;</span>, a, b, c) <span class="comment">//&quot;\n代表换行符&quot;</span></span><br></pre></td></tr></table></figure><br><strong>多重赋值与匿名变量</strong><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a, b := <span class="number">10</span>, <span class="number">20</span></span><br><span class="line">b,a = a, b     <span class="comment">//交换变量的值</span></span><br><span class="line">tmp, _ = i, j  <span class="comment">//将i赋值给tmp, j丢弃不处理</span></span><br></pre></td></tr></table></figure><br><strong>常量</strong></p><ul><li>const a int = 10 或者 const b = 11.2（正确）</li><li><p>const b := 10（错误）</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a <span class="type">int</span> = <span class="number">1</span></span><br><span class="line"><span class="keyword">var</span> b <span class="type">float64</span> = <span class="number">3.14</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (               <span class="comment">//也可以自动推导类型</span></span><br><span class="line">    a <span class="type">int</span> = <span class="number">1</span></span><br><span class="line">    b <span class="type">float64</span> = <span class="number">3.14</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> i <span class="type">int</span> = <span class="number">1</span></span><br><span class="line"><span class="keyword">const</span> j <span class="type">float64</span> = <span class="number">3.14</span></span><br><span class="line"><span class="keyword">const</span> (            <span class="comment">//可以自动类型推导</span></span><br><span class="line">    i = <span class="number">1</span></span><br><span class="line">    j = <span class="number">3.14</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><strong>iota枚举</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    a = <span class="literal">iota</span>  <span class="comment">//0</span></span><br><span class="line">    b = <span class="literal">iota</span>  <span class="comment">//1</span></span><br><span class="line">    c = <span class="literal">iota</span>  <span class="comment">//2</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//iota遇到const重置为0</span></span><br><span class="line"><span class="keyword">const</span> d = <span class="literal">iota</span> <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    a1 = <span class="literal">iota</span> <span class="comment">//0</span></span><br><span class="line">    a2, a3, a4 = <span class="literal">iota</span>, <span class="literal">iota</span>, <span class="literal">iota</span> <span class="comment">//a2=a3=a4=1</span></span><br><span class="line">    a5 = <span class="literal">iota</span>  <span class="comment">//2</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><strong>类型</strong></p></li><li><p><strong>bool</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a <span class="type">bool</span>  |    <span class="keyword">var</span> a <span class="type">bool</span> = <span class="literal">false</span>  |  c := <span class="literal">false</span></span><br><span class="line">a = <span class="literal">true</span>    |</span><br></pre></td></tr></table></figure></li><li><p>float32</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> f1 <span class="type">float32</span> |  f2 := <span class="number">3.14</span> <span class="comment">//自动推导类型为64，因为更准确</span></span><br><span class="line">f1 = <span class="number">3.14</span>      |</span><br></pre></td></tr></table></figure></li><li><p>字符</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ch <span class="type">byte</span>  = <span class="number">97</span><span class="comment">//字符类型</span></span><br><span class="line">fmt.printf(<span class="string">&quot;%c, %d\n&quot;</span>, ch, ch) <span class="comment">// a, 97</span></span><br><span class="line"></span><br><span class="line">ch = <span class="string">&#x27;A&#x27;</span></span><br><span class="line">fmt.printf(<span class="string">&quot;%c, %d\n&quot;</span>, ch, ch) <span class="comment">//A, 65</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;大小写相差32，小写大&#x27;</span></span><br><span class="line">fmt.printf(<span class="string">&quot;大写转小写%c\n&quot;</span>, <span class="string">&#x27;A&#x27;</span> + <span class="number">32</span>)</span><br><span class="line">fmt.printf(<span class="string">&quot;小写转大写%c\n&quot;</span>, <span class="string">&#x27;a&#x27;</span> - <span class="number">32</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>字符串</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str1 <span class="type">string</span> |  str2 := <span class="string">&quot;mike&quot;</span>  | <span class="built_in">len</span>(str2) <span class="comment">//获得str2的长度</span></span><br><span class="line">str1 = <span class="string">&quot;abc&quot;</span></span><br></pre></td></tr></table></figure></li><li><p>字符与字符串区别</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//字符为单引号                     </span></span><br><span class="line"><span class="keyword">var</span> ch <span class="type">byte</span> = <span class="string">&#x27;a&#x27;</span>   </span><br><span class="line"></span><br><span class="line"> <span class="comment">//字符串为双引号(且字符串 = 一个或多个字符 + &#x27;\0&#x27;)</span></span><br><span class="line"><span class="keyword">var</span> str1 <span class="type">string</span> = <span class="string">&quot;abc&quot;</span>  <span class="comment">// abc + &#x27;\0&#x27;</span></span><br><span class="line"></span><br><span class="line">str1[<span class="number">0</span>], str1[<span class="number">1</span>]可以直接对某一个字符进行修改 </span><br></pre></td></tr></table></figure></li><li><p>虚数</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> t <span class="type">complex128</span> = <span class="number">2.1</span> + <span class="number">3.14i</span></span><br><span class="line">t2 := <span class="number">3.3</span> + <span class="number">4.4i</span></span><br><span class="line"><span class="built_in">real</span>(t2), <span class="built_in">imag</span>(t2) <span class="comment">//获得实部和虚部</span></span><br></pre></td></tr></table></figure><p><strong>格式化输出</strong></p></li><li><p>%d（整形）</p></li><li>%c（字符）</li><li>%s（字符串）</li><li>%f（浮点）</li><li>%v（自动匹配）</li></ul><p><strong>输入</strong><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fmt.Scanf(%d, &amp;a)</span><br><span class="line"><span class="string">&#x27;或者&#x27;</span></span><br><span class="line">fmt.Scan(&amp;a)</span><br></pre></td></tr></table></figure><br><strong>类型转换</strong></p><ul><li>只能是兼容类型之间可以进行转换</li><li>bool和整形之间不能互相转换</li><li><p>字符和整形之间可以转换</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ch <span class="type">byte</span> = <span class="string">&#x27;a&#x27;</span></span><br><span class="line"><span class="keyword">var</span> t <span class="type">int</span></span><br><span class="line">t = <span class="type">int</span>(ch) <span class="comment">// t = 97</span></span><br></pre></td></tr></table></figure><p><strong>类型别名</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> bigint <span class="type">int64</span></span><br><span class="line"><span class="keyword">var</span> a bigint = <span class="number">65</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> (</span><br><span class="line">    long <span class="type">int64</span></span><br><span class="line">    char <span class="type">byte</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">var</span> b long = <span class="number">11</span></span><br><span class="line"><span class="keyword">var</span> ch char = <span class="string">&#x27;a&#x27;</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;b = %d, ch = %c&quot;</span>, b, ch)</span><br></pre></td></tr></table></figure><p><strong>运算符</strong></p></li><li><p>go中只有a++,没有++a</p></li><li>0&lt;= a &amp;&amp; a &lt;= 10（正确） 0 &lt;= a &lt;= 10（错误，因为go中bool和整形不兼容）</li></ul><p><strong>if-else</strong><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> s == <span class="string">&#x27;小呆鸟&#x27;</span> &#123;  <span class="comment">//左括号和If在同一行</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;hahaha&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> a := <span class="number">10</span>; a == <span class="number">10</span>&#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;a == 10&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> a := <span class="number">8</span>; a == <span class="number">8</span>&#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;a==8&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> a &gt; <span class="number">8</span>&#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;a &gt; 8&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;a &lt; 8&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><strong>switch语句</strong><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> num := <span class="number">2</span>; num&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">    fmt.Println(<span class="string">&quot;1&quot;</span>)</span><br><span class="line">        <span class="comment">//break   go语言默认包含break，可以不用写</span></span><br><span class="line">        <span class="comment">//fallthrough 不跳出switch语句，后面的无条件执行</span></span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>, <span class="number">6</span>, <span class="number">7</span>:</span><br><span class="line">    fmt.Println(<span class="string">&quot;2&quot;</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">    fmt.Println(<span class="string">&quot;3&quot;</span>)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    fmt.Println(<span class="string">&quot;xxx&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;或者&#x27;</span></span><br><span class="line"></span><br><span class="line">score := <span class="number">99</span></span><br><span class="line"><span class="keyword">switch</span> &#123;   <span class="comment">//可以没有条件</span></span><br><span class="line"><span class="keyword">case</span> score &gt; <span class="number">90</span>:</span><br><span class="line">      fmt.Println(<span class="string">&quot;优秀&quot;</span>)</span><br><span class="line"> <span class="keyword">case</span> score &lt; <span class="number">90</span>:</span><br><span class="line">      fmt.Println(<span class="string">&quot;一般&quot;</span>)   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><strong>for 和 range(数组，切片等用到，go没有while和do…while语句)</strong><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;for&#x27;</span></span><br><span class="line">sum := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt;= <span class="number">100</span>; i ++&#123;</span><br><span class="line">    sum = sum + i</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;range&#x27;</span></span><br><span class="line">str := <span class="string">&quot;abc&quot;</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(str); i ++ &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;str[%d] = %c\n&quot;</span>, i, str[i])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i, date := <span class="keyword">range</span> str &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;str[%d] = %c\n&quot;</span>, i, date)</span><br><span class="line">&#125;</span><br><span class="line"><span class="string">&#x27;等价&#x27;</span></span><br><span class="line"><span class="keyword">for</span> i, _ := <span class="keyword">range</span> str &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;str[%d] = %c\n&quot;</span>, i, str[i])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><strong>break和continue</strong><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">i := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">    i ++</span><br><span class="line">    time.sleep(time.Second)</span><br><span class="line">    <span class="keyword">if</span> i == <span class="number">5</span>&#123;</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">        <span class="comment">//continue</span></span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(<span class="string">&quot;i = &quot;</span>, i)</span><br><span class="line">        </span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> goland </category>
          
      </categories>
      
      
        <tags>
            
            <tag> goland </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统概述</title>
      <link href="/2022/04/26/post5/"/>
      <url>/2022/04/26/post5/</url>
      
        <content type="html"><![CDATA[<blockquote><p>💛本文摘要💛</p><p><strong><code>操作系统系列文章</code></strong><br><a href="https://blog.csdn.net/weixin_45043334/article/details/126274844">1. 操作系统—概述</a><br><a href="https://blog.csdn.net/weixin_45043334/article/details/126293098">2. 操作系统—中断、异常、系统调用</a><br><a href="https://blog.csdn.net/weixin_45043334/article/details/126353734">3. 操作系统—物理内存管理</a><br><a href="https://blog.csdn.net/weixin_45043334/article/details/126360202">4. 操作系统—非连续内存分配</a><br><a href="https://blog.csdn.net/weixin_45043334/article/details/126378112">5. 虚拟内存管理</a><br><a href="https://blog.csdn.net/weixin_45043334/article/details/126398876">6. 操作系统—虚拟内存管理技术页面置换算法</a><br><a href="https://blog.csdn.net/weixin_45043334/article/details/126426025">7. 进程管理</a><br><a href="https://blog.csdn.net/weixin_45043334/article/details/126451433">8. 调度算法</a><br><a href="https://blog.csdn.net/weixin_45043334/article/details/126477243">9. 同步与互斥</a><br><a href="https://blog.csdn.net/weixin_45043334/article/details/126533681">10. 信号量和管程</a><br><a href="https://blog.csdn.net/weixin_45043334/article/details/126624006">11. 死锁和进程通信</a><br><a href="https://blog.csdn.net/weixin_45043334/article/details/126652312">12. 文件系统管理</a></p></blockquote><h2 id="🐋1-介绍"><a href="#🐋1-介绍" class="headerlink" title="🐋1.介绍"></a>🐋1.介绍</h2><ul><li>基本概述及原理</li><li>操作系统介绍</li><li>中断及系统调用</li><li>内存管理</li><li>进程及线程</li><li>调度</li><li>同步</li><li>文件系统</li><li><p>I/O子系统</p><h2 id="🐋2-什么是操作系统"><a href="#🐋2-什么是操作系统" class="headerlink" title="🐋2. 什么是操作系统"></a>🐋2. 什么是操作系统</h2><p><code>用户角度：操作系统是一个控制软件</code></p></li><li><p>管理应用程序</p></li><li>为应用程序提供服务</li><li>杀死应用程序</li></ul><p><code>程序角度：操作系统是资源管理器</code></p><ul><li>管理外设、分配资源</li><li>抽象<ul><li>将CPU抽象成进程</li><li>将磁盘抽象成文件</li><li>将内存抽象成地址空间</li></ul></li></ul><p><img src="https://img-blog.csdnimg.cn/70430656a04e41788f72eca0872d03d7.png" alt="在这里插入图片描述"></p><h3 id="🐻2-1-操作系统层次"><a href="#🐻2-1-操作系统层次" class="headerlink" title="🐻2.1 操作系统层次"></a>🐻2.1 操作系统层次</h3><ul><li>位于硬件之上，应用程序之下。</li></ul><h3 id="🐻2-2-操作系统的界面和内核"><a href="#🐻2-2-操作系统的界面和内核" class="headerlink" title="🐻2.2 操作系统的界面和内核"></a>🐻2.2 操作系统的界面和内核</h3><ul><li>Linux Windows Android 的界面属于外壳(Shell) ，而不是内核(kernel)。操作系统研究的是内核，处于Shell之下。</li></ul><h3 id="🐻2-3-操作系统内部组件"><a href="#🐻2-3-操作系统内部组件" class="headerlink" title="🐻2.3 操作系统内部组件"></a>🐻2.3 操作系统内部组件</h3><ul><li>CPU调度器</li><li>物理内存管理</li><li>虚拟内存管理</li><li>文件系统管理</li><li>中断处理与设备驱动</li></ul><p><img src="https://img-blog.csdnimg.cn/f1a152b057074ddc8cb63e242a335222.png" alt="在这里插入图片描述"></p><p><strong>cpu:</strong> 主要是cpu的调度和进程线程的管理</p><p><strong>内存：</strong> 物理内存和虚拟内存，物理内存就是实际的内存，<code>虚拟内存为应用提供一个相对独立的空间（在有限的物理内存之上，虚拟出一个更大的，更安全的环境）</code></p><p><strong>文件：</strong> disk是以磁盘块作为一个读写的基本单位，访问比较底层不方便，于是在上面抽象成文件。</p><p><strong>中断处理：</strong> 它是直接与底层硬件交流</p><h3 id="🐻2-4操作系统特征"><a href="#🐻2-4操作系统特征" class="headerlink" title="🐻2.4操作系统特征"></a>🐻2.4操作系统特征</h3><ul><li><code>并发</code><ul><li>一段时间内运行多个进程（并行 : 一个时间点运行多个进程，一般要求有多个CPU)</li><li>需要OS管理和调度</li></ul></li><li><code>共享</code><ul><li>“同时”共享</li><li>互斥共享</li></ul></li><li><code>虚拟</code><ul><li>利用多道程序设计技术，让每一个用户觉得的有一个计算机专门为他服务</li></ul></li><li><code>异步</code><ul><li>程序是走走停停，而不是一直运行，<code>但是不管怎么走，只要运行环境相同，os要保证运行的结果也相同</code></li></ul></li></ul><h2 id="🐋3-操作系统历史"><a href="#🐋3-操作系统历史" class="headerlink" title="🐋3. 操作系统历史"></a>🐋3. 操作系统历史</h2><ol><li>早起计算机使用纸带传输程序和数据，os只起到加载作用</li><li><p>批处理阶段（一个程序一个程序的运行，每次都需要从外面导入程序）<br><img src="https://img-blog.csdnimg.cn/fde74b67bc9447e4bdc7d7bf55234b63.png" alt="在这里插入图片描述"></p></li><li><p>CPU执行多个程序。此时不需要将要跑的程序，从磁盘放到内存中，大大减少IO的开销（直接全部都放到内存中）<br><img src="https://img-blog.csdnimg.cn/cb79d79ae0e746ccbdaeeeaf9e475d2a.png" alt="在这里插入图片描述"></p></li><li>当一个程序运行阶段，可能要进行IO操作，此时时间非常长，这时就可以运行另一个程序，当程序1完成IO操作后，就进行中断，停止程序25，继续进行程序1</li></ol><p><img src="https://img-blog.csdnimg.cn/91dfef316f9d48a6b419acc491524a22.png" alt="在这里插入图片描述"></p><ol><li>提高交互性，上述的操作不需要人参与，交互性差，此时出现<code>分时系统</code>（通过分时使得不同的程序都有时间去执行工作。），目前计算机是1/1000秒产生一次分时。<code>（而分时主要靠时钟定期产生中断）</code></li></ol><p><img src="https://img-blog.csdnimg.cn/9646aacbec274d6c9e3303cbf9f48dee.png" alt="在这里插入图片描述"></p><ol><li>多核CPU</li><li>分布式操作系统<br><img src="https://img-blog.csdnimg.cn/d09de21a423241898bf6a98ef0690a90.png" alt="在这里插入图片描述"></li></ol><h2 id="🐋4-操作系统结构"><a href="#🐋4-操作系统结构" class="headerlink" title="🐋4. 操作系统结构"></a>🐋4. 操作系统结构</h2><p><strong>MS-DOS</strong></p><ul><li>不分模块的单体内核（<code>单体意味着通过函数调用实现（紧耦合）</code>）</li></ul><p><strong>微内核</strong></p><ul><li>尽可能把内核功能移动到用户空间<code>（在操作系统内核中放基本功能（松耦合），其他的文件系统，内存管理等都放在外面以进程形式存在，进程与进程之间通过内核消息传递进制进行通信）</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker概述</title>
      <link href="/2022/04/25/post4/"/>
      <url>/2022/04/25/post4/</url>
      
        <content type="html"><![CDATA[<blockquote><p>💛本文摘要💛<br>Docker系列文章：<br>一、<a href="https://blog.csdn.net/weixin_45043334/article/details/125243499">Docker概述</a><br>二、<a href="https://blog.csdn.net/weixin_45043334/article/details/125243542">Docker安装大全</a><br>三、<a href="https://blog.csdn.net/weixin_45043334/article/details/125243581">Docker 命令大全</a><br>四、<a href="https://blog.csdn.net/weixin_45043334/article/details/125262867">Docker容器部署</a><br>五、<a href="https://blog.csdn.net/weixin_45043334/article/details/125263703">Docker镜像详解</a><br>六、<a href="https://blog.csdn.net/weixin_45043334/article/details/125264727">Docker容器卷详解</a><br>七、 <a href="https://blog.csdn.net/weixin_45043334/article/details/125283158">Dockerfile详解</a><br>八、<a href="https://blog.csdn.net/weixin_45043334/article/details/125304543">Docker网路模式详解</a><br>笔记总结：<a href="https://www.bilibili.com/video/BV1og4y1q7M4?p=40&amp;vd_source=620a01017393bc61d7394b3dc716212d">https://www.bilibili.com/video/BV1og4y1q7M4</a><br>可面试可复习</p><h1 id="docker-概述"><a href="#docker-概述" class="headerlink" title="docker 概述"></a>docker 概述</h1><h2 id="🐳1-Docker-概述"><a href="#🐳1-Docker-概述" class="headerlink" title="🐳1. Docker 概述"></a>🐳1. Docker 概述</h2></blockquote><p>Docker 是一个基于go语言开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的<code>镜像</code>中，然后发布到任何流行的 <code>Linux</code>或<code>Window</code>操作系统的机器上，也可以实现<code>虚拟化</code>。容器是完全使用<code>沙箱</code>机制，相互之间不会有任何接口。</p><p><strong>一个完整的Docker有以下几个部分组成：</strong></p><ul><li><p>DockerClient客户端</p></li><li><p>Docker Daemon守护进程</p></li><li><p>Docker Image镜像</p></li><li><p>DockerContainer容器 </p></li></ul><h2 id="🐳2-Docker的出现"><a href="#🐳2-Docker的出现" class="headerlink" title="🐳2. Docker的出现"></a>🐳2. Docker的出现</h2><p>一款产品：开发—&gt;上线 俩套环境，应用配置！</p><p><strong>开发与运维的爱恨纠缠</strong>：我开发好的程序，放到别人的电脑上，就是运行不了（各种问题，要么缺少配置，要么缺少依赖，要么缺少库），可能还会遇到，版本更新，导致服务不可用！对于运维人来说，巨大考验。</p><p><strong>环境配置是一件非常头疼的事</strong>：</p><ul><li><p>每一个集群都要部署环境（redis、ES、Hadoop）</p></li><li><p>发布一个项目(jar+(Redis + MySQL + jdk + ES)),项目不能带上环境打包。</p></li><li><p>在服务器配置的一个应用环境Redis、MySQL、jdk、ES、Hadoop,配置麻烦，不能跨平台。</p></li></ul><p><img src="https://img-blog.csdnimg.cn/dda6ca47b4d242dc865746269a0379ea.png" alt="在这里插入图片描述"></p><h3 id="🐙Docker作用"><a href="#🐙Docker作用" class="headerlink" title="🐙Docker作用"></a>🐙Docker作用</h3><p>Docker为了解决上述问题</p><p>java — apk —发布（应用商店）— 小呆鸟使用apk — 安装即可</p><p>java —jar(环境) —- 打包项目带上环境（镜像）—- （Docker仓库：商店）— 下载我们发布的镜像 — 直接运行即可。</p><p><img src="https://img-blog.csdnimg.cn/aaafb15a9de64a49b7ad2028821e095f.png" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/8699fcd5329f4db4925dbbb024d698cc.png" alt="在这里插入图片描述"></p><h3 id="🐙Docker思想"><a href="#🐙Docker思想" class="headerlink" title="🐙Docker思想"></a>🐙Docker思想</h3><ul><li>它来自于集装箱！</li><li>隔离：Docker的核心思想！将每个软件及依赖打包装箱，每一个箱子都是互相隔离的。</li><li>在一条船上，有俩个箱子，一个是水果，一个是生化武器。docker就是使得这俩个箱子隔离，互不干扰。</li></ul><h3 id="🐙Docker-VS-虚拟机"><a href="#🐙Docker-VS-虚拟机" class="headerlink" title="🐙Docker VS 虚拟机"></a>🐙Docker VS 虚拟机</h3><ul><li>虚拟机：在windows 中装一个Vmware,通过这个软件可以虚拟出来一台或者多台电脑！笨重！</li><li>虚拟机属于虚拟化技术，Docker容器技术，也是一种虚拟化技术</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vmware :linux centos原生镜像(虚拟出一台电脑) 隔离，需要开启多个虚拟机！    几个G   几分钟</span><br><span class="line">docker :隔离，镜像（最核心环境 4m + jdk + mysql）十分小巧，运行镜像就可以！ 几个M或者KB 秒级</span><br></pre></td></tr></table></figure><h2 id="🐳3-Docker能做什么"><a href="#🐳3-Docker能做什么" class="headerlink" title="🐳3. Docker能做什么"></a>🐳3. Docker能做什么</h2><h3 id="🐙虚拟机技术"><a href="#🐙虚拟机技术" class="headerlink" title="🐙虚拟机技术"></a>🐙虚拟机技术</h3><p><img src="https://img-blog.csdnimg.cn/56fa1259d672483ab7d6e40f7825d834.png" alt="在这里插入图片描述"></p><p><strong>虚拟机技术缺点：</strong></p><ol><li>资源占用十分多（一个虚拟机占用20G）</li><li>冗余步骤多</li><li>启动非常慢</li></ol><h3 id="🐙Docker容器化技术"><a href="#🐙Docker容器化技术" class="headerlink" title="🐙Docker容器化技术"></a>🐙Docker容器化技术</h3><p><code>容器化技术不是模拟一个完整的操作系统</code>：例如你打开了一个虚拟机，里面装有linux系统，打开后，里面会有一些自带的浏览器，一些插件，但是docker里面什么也没有。</p><p><img src="https://img-blog.csdnimg.cn/4c2b8d67a8974eda93c8fa563faf4c49.png" alt="在这里插入图片描述"></p><h3 id="🐙Docker-和虚拟机技术的不同"><a href="#🐙Docker-和虚拟机技术的不同" class="headerlink" title="🐙Docker 和虚拟机技术的不同"></a>🐙Docker 和虚拟机技术的不同</h3><ul><li>传统的虚拟机，虚拟机一个硬件，运行一个完整的操作系统，然后再这个系统上安装和运行软件。</li><li>容器内的应用直接运行在宿主主机，容器是没有自己的内核的，也没有虚拟我们的硬件，所以轻便</li><li>每个容器是相互隔离，每个容器内部都有一个属于自己的文件系统，互不影响。</li></ul><h3 id="🐙DevOps-开发、运维"><a href="#🐙DevOps-开发、运维" class="headerlink" title="🐙DevOps(开发、运维)"></a>🐙DevOps(开发、运维)</h3><p><strong>应用更快速的交付和部署</strong></p><ul><li><p>传统： 一堆帮助文档，安装程序</p></li><li><p>Docker: 打包镜像发布测试，一键运行</p></li></ul><p><strong>更便捷的升级和扩缩容</strong></p><ul><li><p>使用了Docker之后，我们的部署应用就和搭积木一样！项目打包为一个镜像，扩展 服务器A ! 服务器B</p></li><li><p>传统 ：我要升级APP（redia, mysql, tomcat），此时我要把mysql,redis等APP需要的软件，都要升级</p></li><li>Docker: 我只需要把这个镜像升级一下。(把（redia, mysql, tomcat）做成一个镜像)。</li></ul><p><strong>更简单的系统运维</strong></p><ul><li>在容器化之后，我们的开发，测试环境都是高度一致的</li></ul><p><strong>更高效的计算资源利用</strong></p><ul><li>Docker 是内核级别的虚拟化，可以在一个物理机上运行很多容器实例！ 服务器的性能可以极大提高</li></ul><h2 id="🐳4-Docker名词概念"><a href="#🐳4-Docker名词概念" class="headerlink" title="🐳4. Docker名词概念"></a>🐳4. Docker名词概念</h2><p><img src="https://img-blog.csdnimg.cn/b83c64a2df8847468430e6e78500d37c.png" alt="在这里插入图片描述"></p><h3 id="🐙镜像-image"><a href="#🐙镜像-image" class="headerlink" title="🐙镜像(image):"></a>🐙镜像(image):</h3><p>docker镜像就好比一个模板(class类)，可以通过这个模板来创建容器服务(根据class类，来创建对象)， tomcat镜像==&gt;  run ==&gt; tomcat01容器 （提供服务）。</p><h3 id="🐙容器：-container"><a href="#🐙容器：-container" class="headerlink" title="🐙容器：(container)"></a>🐙容器：(container)</h3><p>Docker利用容器技术，独立运行一个或者一组应用，通过镜像来创建</p><p>启动、停止、删除、基本命令！</p><h3 id="🐙仓库-repository"><a href="#🐙仓库-repository" class="headerlink" title="🐙仓库(repository):"></a>🐙仓库(repository):</h3><p>仓库就是存放镜像的地方！</p><p>仓库分为公有仓库和私有仓库！</p><p>Docker Hub(默认是国外的)</p><p>阿里云等都有容器服务器（配置镜像加速！）</p><p><strong>流程</strong>:用客户端来启动Docker里面的一个容器，这个容器要去服务器上下载。</p>]]></content>
      
      
      <categories>
          
          <category> 云原生 </category>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 云原生 </tag>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c++字符串、向量和数组</title>
      <link href="/2022/04/24/post3/"/>
      <url>/2022/04/24/post3/</url>
      
        <content type="html"><![CDATA[<blockquote><p>💛本文摘要💛</p><p>&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;</p><p><strong><code>c++  系列文章</code></strong></p><p><a href="https://blog.csdn.net/weixin_45043334/article/details/125380065">第2章 变量和基本类型</a><br><a href="https://blog.csdn.net/weixin_45043334/article/details/125402340">第3章 字符串、向量和数组</a><br><a href="https://blog.csdn.net/weixin_45043334/article/details/125449009">第4章 表达式</a><br><a href="https://blog.csdn.net/weixin_45043334/article/details/125647293">第5章 语句</a><br><a href="https://blog.csdn.net/weixin_45043334/article/details/125751253">第6章 函数</a><br><a href="https://blog.csdn.net/weixin_45043334/article/details/125850838">第8章 IO库</a><br><a href="https://blog.csdn.net/weixin_45043334/article/details/125947865">第9章 顺序容器</a><br><a href="https://blog.csdn.net/weixin_45043334/article/details/126002739">第10章 泛型算法</a><br><a href="https://blog.csdn.net/weixin_45043334/article/details/126246260">第11章 关联容器</a><br><a href="https://blog.csdn.net/weixin_45043334/article/details/126297355">第12章 动态内存</a><br><a href="https://blog.csdn.net/weixin_45043334/article/details/126394732">第13章 拷贝控制</a><br><a href="https://blog.csdn.net/weixin_45043334/article/details/126679427">第 14章 重载运算符</a><br><a href="https://blog.csdn.net/weixin_45043334/article/details/126728175?spm=1001.2014.3001.5502">第15章 面向对象程序设计</a><br><a href="https://blog.csdn.net/weixin_45043334/article/details/126808177">第 16章 模板与泛型编程</a></p><h1 id="🍇第3章-字符串、向量和数组"><a href="#🍇第3章-字符串、向量和数组" class="headerlink" title="🍇第3章 字符串、向量和数组"></a>🍇第3章 字符串、向量和数组</h1><p>String、vector是俩种最重要的标准库类型，String支持<code>可变长字符串</code>,vector支持<code>可变长的集合</code></p></blockquote><p>迭代器是一种与 string 和 vector 配套的标准库类型。常用于访问string中的字符或vector中的元素</p><p>内置数组是一种基础的类型，string和vector都是对它的某种抽象。</p><h2 id="🍌3-1-命名空间的-using-声明"><a href="#🍌3-1-命名空间的-using-声明" class="headerlink" title="🍌3.1 命名空间的 using 声明"></a>🍌3.1 命名空间的 using 声明</h2><ul><li>使用某个命名空间：例如 using std::cin表示使用命名空间std中的名字cin。</li><li>头文件中不应该包含using声明。这样使用了该头文件的源码也会使用这个声明，对于某些程序来说，可能会名字冲突，带来风险。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">using <span class="built_in">std</span>::<span class="built_in">cin</span>;</span><br></pre></td></tr></table></figure></li></ul><h2 id="🍌3-2-标准库类型string"><a href="#🍌3-2-标准库类型string" class="headerlink" title="🍌3.2 标准库类型string"></a>🍌3.2 标准库类型string</h2><ul><li>标准库类型string表示可变长的字符序列。</li><li>string定义在命名空间std中。<code>(包含头文件)</code></li><li>string对象：不同于字符串字面值。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line">using <span class="built_in">std</span>::<span class="built_in">string</span></span><br></pre></td></tr></table></figure><h3 id="🍑3-2-1-定义和初始化string对象"><a href="#🍑3-2-1-定义和初始化string对象" class="headerlink" title="🍑3.2.1 定义和初始化string对象"></a>🍑3.2.1 定义和初始化string对象</h3><p>string 默认初始化是一个空字符串<br>初始化<code>string</code>对象的方式：</p><div class="table-container"><table><thead><tr><th>初始化方式</th><th>解释</th></tr></thead><tbody><tr><td>string s1</td><td>默认初始化，s1 是个空字符串</td></tr><tr><td>string s2(s1)</td><td>s2 是 s1 的副本</td></tr><tr><td>string s2 = s1</td><td>等价于 s2( s1 )，s2 是 s1 的副本</td></tr><tr><td>string s3(“value”)</td><td>s3 是字面值 “value” 的副本，除了字面值最后的那个空字符外</td></tr><tr><td>string s3 = “value”</td><td>等价于 s3(“value”)，s3 是字面值 “value” 的副本</td></tr><tr><td>string s4(n, ‘c’)</td><td>把 s4 初始化为由连续 n 个字符 c 组成的串</td></tr></tbody></table></div><p>注意：</p><ul><li>在进行拷贝操作时，是不包含最后一个空字符串的</li><li>使用字符串字面值或字符数组初始化 string 对象时，string 对象中是不包含末尾的空字符的，它会将字符数组中末尾的空字符去掉。</li></ul><p><strong>初始化方式</strong></p><ul><li>拷贝初始化</li><li>直接初始化</li><li>列表初始化<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> s5 = <span class="string">&quot;hello&quot;</span>;           <span class="comment">//拷贝初始化</span></span><br><span class="line"><span class="built_in">string</span> <span class="title function_">s6</span><span class="params">(<span class="string">&quot;hello&quot;</span>)</span>;            <span class="comment">//直接初始化</span></span><br><span class="line"><span class="built_in">string</span> s7&#123;hello&#125;;              <span class="comment">//列表初始化</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="🍑3-2-2-string对象上的操作"><a href="#🍑3-2-2-string对象上的操作" class="headerlink" title="🍑3.2.2 string对象上的操作"></a>🍑3.2.2 string对象上的操作</h3><p><strong>string 常用操作</strong><br>|    <strong>string 常用操作</strong>             |         |<br>| —————————— | —————————————————————————————— |<br>| getline(is, s)     | 从is中读取一行赋给s，返回is       (is 是输入流)                     |<br>| s.empty()          | s 为空返回true，否则返回false                           |<br>| s.size()        | 返回 s 中字符的个数                                          |<br>| s[n]              | 返回 s 中第 n 个字符的引用，位置 n 从0计起                   |<br>| s1+s2              | 返回 s1 和 s2 连接后的结果                                   |<br>| s1=s2              | 用 s2 的副本代替 s1 中原来的字符                             |<br>| s1==s2            | 如果 s1 和 s2 中所含的字符完全一样，则它们相等；string对象的相等性判断对字母的大小写敏感 |<br>| s1!=s2            | 同上                                                         |<br>| &lt;, &lt;=, &gt;, &gt;= | 利用字符在字典中的顺序进行比较，且对字母的大小写敏感（对第一个不相同的位置进行比较） |</p><p><code>注意</code>:</p><ul><li>通过<code>cin &gt;&gt; string</code>,在读取string对象时，string对象会自动忽略开头的空白（空格、换行符、等）并从第一个真正的字符串开始读，知道遇见下一个空白为止，因此不能使用 <code>cin 读取句子</code>，但是可以<code>读取单词</code>；</li><li>字符串字面值与 string 是两种不同的类型<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> s;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; s;             <span class="comment">//输入hello world</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; s &lt;&lt; <span class="built_in">endl</span>;    <span class="comment">//输出为hello</span></span><br><span class="line"> </span><br></pre></td></tr></table></figure></li></ul><p><strong>读写string对象</strong></p><p>使用<code>cin</code> 和 <code>cout</code>来读写string对象</p><p><strong>使用getline 函数读取一行</strong></p><ul><li><code>getline()</code>函数定义在<code>头文件string</code>中</li><li>getline()参数是一个输入流和一个string对象，函数从给定的输入流中读取内容，知道遇到换行符位置（<code>注意是换行符和上面空白字符不一样</code>）</li><li>读取到文件末尾结束<br><code>注意</code>:getline 会将换行符也读入，但是不将换行符存入 string 对象。触发 getline() 函数返回的那个换行符实际上被丢弃掉了。得到的string对象中不包含换行符。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> s;                <span class="comment">//读取到文件末尾结束</span></span><br><span class="line"><span class="keyword">while</span>(getline(<span class="built_in">cin</span>, s))   <span class="comment">//输入为hello world</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; s &lt;&lt; <span class="built_in">endl</span>;     <span class="comment">//输出为hello world</span></span><br></pre></td></tr></table></figure></li></ul><p><strong>string::size_type 类型</strong></p><ul><li>string 中的size() 返回值类型是<code>string:: size_type</code></li><li>string::size_type是一个无符号值，能够存下任何string对象的大小，所以用于存放string类的size函数返回值的变量，都应该是string::size_type类型的</li><li>c++11规定允许使用<code>auto</code>和 <code>declltype</code>来获取此类型</li><li>在具体使用时，通过作用域操作符来表明 size_type 是在类 string 中定义的。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> len = s.size();<span class="comment">// len 的类型是 string::size_type</span></span><br></pre></td></tr></table></figure></li></ul><p><code>注意：</code>在一条表达式中已经有了size()函数，就不要使用int了，这样可以避免混用int 和 unsigned可能会带来问题。</p><p><strong>俩个string对象相加</strong></p><ul><li>俩个string对象相加得到一个新的string对象，其内容是把左侧的运算符对象与右侧的运算符对象串接而成<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> s1 = <span class="string">&quot;hello,&quot;</span>;</span><br><span class="line"><span class="built_in">string</span> s2 = <span class="string">&quot;world&quot;</span>;</span><br><span class="line"><span class="built_in">string</span> s3 = s1 + s2;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; s3 &lt;&lt; <span class="built_in">endl</span>;   <span class="comment">//hello,world</span></span><br></pre></td></tr></table></figure></li></ul><p><strong>字面值和string对象相加</strong></p><ul><li><code>切记字面值和string是不一样的</code></li><li>字面值分为：字符字面值和字符串字面值</li></ul><p><strong>俩个string对象相加</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> s1 = <span class="string">&quot;hello,&quot;</span>;</span><br><span class="line"><span class="built_in">string</span> s2 = <span class="string">&quot;world&quot;</span>;</span><br><span class="line"><span class="built_in">string</span> s3 = s1 + s2;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; s3 &lt;&lt; <span class="built_in">endl</span>;   <span class="comment">//hello,world</span></span><br></pre></td></tr></table></figure></p><p><strong>string对象和字符字面值相加</strong></p><ul><li>当把string对象和字符字面值混在一起的时候，必须保证每个加法运算（+）的俩侧的运算对象<code>至少有一个是string</code><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> s4 = s1 + <span class="string">&quot;,&quot;</span>               <span class="comment">//正确，左侧为string对象，右侧为字符字面值</span></span><br><span class="line"><span class="built_in">string</span> s5 = <span class="string">&quot;hello&quot;</span> + <span class="string">&quot;,&quot;</span>          <span class="comment">//错误，左右俩侧都是字符字面值</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> s6 = s1 + <span class="string">&quot;,&quot;</span> + <span class="string">&quot;world&quot;</span>     <span class="comment">//正确</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> s7 = <span class="string">&quot;hello&quot;</span> + <span class="string">&quot;,&quot;</span> + s1     <span class="comment">//错误，俩个字面值不能相加</span></span><br><span class="line"><span class="comment">//等价于string s7 = (&quot;hello&quot; + &quot;,&quot;) + s1</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="🍑3-2-3-处理string对象中的字符"><a href="#🍑3-2-3-处理string对象中的字符" class="headerlink" title="🍑3.2.3 处理string对象中的字符"></a>🍑3.2.3 处理string对象中的字符</h3><p>cctype 头文件中有下列标准库函数来处理 string 中的字符。<br>| cctype头文件中的函数            |                   解释                                   |<br>| ——————- | —————————————————————————————— |<br>| <code>isalnum(c)</code>  | 当<code>c</code>是字母或数字时为真                                      |<br>| <code>isalpha(c)</code>  | 当<code>c</code>是字母时为真                                            |<br>| <code>iscntrl(c)</code>  | 当<code>c</code>是控制字符时为真                                        |<br>| <code>isdigit(c)</code>  | 当<code>c</code>是数字时为真                                            |<br>| <code>isgraph(c)</code>  | 当<code>c</code>不是空格但可以打印时为真                                |<br>| <code>islower(c)</code>  | 当<code>c</code>是小写字母时为真                                        |<br>| <code>isprint(c)</code>  | 当<code>c</code>是可打印字符时为真                                      |<br>| <code>ispunct(c)</code>  | 当<code>c</code>是标点符号时为真                                        |<br>| <code>isspace(c)</code>  | 当<code>c</code>是空白时为真（空格、横向制表符、纵向制表符、回车符、换行符、进纸符） |<br>| <code>isupper(c)</code>  | 当<code>c</code>是大写字母时为真                                        |<br>| <code>isxdigit(c)</code> | 当<code>c</code>是十六进制数字时为真                                    |<br>| <code>tolower(c)</code>  | 当<code>c</code>是大写字母，输出对应的小写字母；否则原样输出<code>c</code>         |<br>| <code>toupper(c)</code>  | 当<code>c</code>是小写字母，输出对应的大写字母；否则原样输出<code>c</code>         |</p><p><code>建议</code>：使用 c++ 版本的标准库头文件，即 cname 而非 name.h 类型的头文件。cname 头文件中的名字都从属于命名空间 std；</p><p><strong>范围for循环</strong></p><ul><li>for (auto c : str)</li><li>for (auto &amp;c : str)  </li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> <span class="title function_">str</span><span class="params">(<span class="string">&quot;hello world&quot;</span>)</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> c:str)         <span class="comment">// 对于str中的每个字符</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; c &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">// 输出当前字符，后面紧跟一个换行符 hello world</span></span><br></pre></td></tr></table></figure><ul><li>当要<code>改变 string 对象中的值</code>时，需要把循环变量定义成<code>引用类型</code>。必须通过显示添加 &amp; 符号来声明引用类型。</li><li>不能在范围 for 语句中改变所遍历序列的大小。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> &amp;c:s)</span><br><span class="line">    c = <span class="built_in">toupper</span>(c);     <span class="comment">// 小写转换为大写</span></span><br></pre></td></tr></table></figure></li></ul><p><strong>访问string中的某一个字符，有俩种方式 1. 可以通过[ ]， 2.可以通过迭代器</strong></p><ul><li>s[0] 表示第一个字符</li><li>s[size() - 1] 表示最后一个字符</li><li>string对象的下标是从 0 开始到 size() - 1 结束</li><li>索引必须大于等于 0 小于 size，使用索引前最好用 if(!s.empty()) 判断一下字符串是否为空。</li><li>任何表达式只要是整型值就可以作为索引。索引是无符号类型 size_type；</li></ul><h2 id="🍌3-3-标准库类型-vector"><a href="#🍌3-3-标准库类型-vector" class="headerlink" title="🍌3.3 标准库类型 vector"></a>🍌3.3 标准库类型 vector</h2><ul><li>vector 是一个<code>类模板</code>而非类型，vector<int>是一个类型。</li><li>vector同时也是一个<code>容器</code>，可以容纳各种数据类型</li><li>本身是一个类模板，但是可以实例化出一个类</li></ul><h3 id="🍑3-3-1-定义和初始化vector对象"><a href="#🍑3-3-1-定义和初始化vector对象" class="headerlink" title="🍑3.3.1 定义和初始化vector对象"></a>🍑3.3.1 定义和初始化vector对象</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span> &lt;<span class="type">int</span>&gt;  v1;                 <span class="comment">//vector默认初始化是一个0.</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title function_">v2</span><span class="params">(v1)</span>;            <span class="comment">// v2=v1</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; v2 = v1;           <span class="comment">//等价于v2(v1)</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title function_">v3</span><span class="params">(<span class="number">10</span>,<span class="string">&quot;dainian&quot;</span>)</span>;  <span class="comment">// 10个string</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title function_">v4</span><span class="params">(<span class="number">10</span>)</span>;            <span class="comment">// 10个空string</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; v5&#123;<span class="string">&quot;a&quot;</span>,<span class="string">&quot;hahah&quot;</span>&#125;;    <span class="comment">// 列表初始化</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; v5 = &#123;<span class="string">&quot;a&quot;</span>,<span class="string">&quot;hahah&quot;</span>&#125;; <span class="comment">//等价上面</span></span><br></pre></td></tr></table></figure><p><strong>列表初始化</strong></p><ul><li>使用一对<code>&#123;&#125;</code>来表示列表初始化，初始化过程会尽量把花括号内的值当作一个初始值列表来处理。</li><li>如果花括号内的值不能用来列表初始化，比如对一个 string 的 vector 初始化，但是花括号内的值为整型<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; v &#123;<span class="number">10</span>&#125;;              <span class="comment">// v 有 10 个默认初始化的元素</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; v &#123;<span class="number">10</span>, <span class="string">&quot;hello&quot;</span>&#125;;  <span class="comment">// v 有 10 个值为 &quot;hi&quot; 的元素</span></span><br></pre></td></tr></table></figure><strong>值初始化</strong></li></ul><p>如果vector 对象的元素是内置类型，比如int 则元素初始值为0，如果是类类型，则由类默认初始化。</p><h3 id="🍑3-3-2-像vector对象中添加元素"><a href="#🍑3-3-2-像vector对象中添加元素" class="headerlink" title="🍑3.3.2 像vector对象中添加元素"></a>🍑3.3.2 像vector对象中添加元素</h3><ul><li>v.push_back(e) 在尾部增加元素。</li><li>为了可以使得vector高效增长，通常先定义一个空 vector，然后在添加元素会更快速。</li><li>如果插入的vector中的初始值值都是一样的此时初始化时确定大小与值会更快，如果初始值值不一样，即使已知大小，最好也先定义一个空的 vector，再添加元素。</li></ul><h3 id="🍑3-3-3-其他vector操作"><a href="#🍑3-3-3-其他vector操作" class="headerlink" title="🍑3.3.3 其他vector操作"></a>🍑3.3.3 其他vector操作</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">v.size();            <span class="comment">//返回v中元素的个数</span></span><br><span class="line">v.empty();           <span class="comment">//如果v不含有任何元素，返回真；否则返回假</span></span><br><span class="line">v.push_back(t);      <span class="comment">//向v的尾端添加一个值为t的元素</span></span><br><span class="line">v[n]                 <span class="comment">//返回v中第n个位置上元素的引用</span></span><br><span class="line">v1 = v2 <span class="comment">//用v2中的元素拷贝替换v1中的元素</span></span><br><span class="line">v1 = &#123;a,b,c...&#125;      <span class="comment">//用列表中元素的拷贝替换v1中的元素</span></span><br><span class="line">v1 == v2             <span class="comment">//v1和v2相等当且仅当它们的元素数量相同且对应位置的元素值都相同</span></span><br><span class="line">v1 != v2</span><br><span class="line">&lt;,&lt;=,&gt;, &gt;=         <span class="comment">//以字典顺序进行比较</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>可以用范围 for 语句处理 vector 序列的元素，范围for语句内不应该改变其遍历序列的大小。</li><li>vector对象（以及string对象）的下标运算符，只能对确知已存在的元素执行下标操作<code>(只能访问元素，或者更改已经存在的元素)</code>，但是<code>不能用于添加元素。</code></li></ul><h2 id="🍌3-4-迭代器介绍"><a href="#🍌3-4-迭代器介绍" class="headerlink" title="🍌3.4 迭代器介绍"></a>🍌3.4 迭代器介绍</h2><ul><li>所有标准库容器都可以使用迭代器，但是只有少数几种才同时支持下标操作，<code>如果是容器，尽量都采用迭代器进行操作</code></li><li>类似于指针类型，迭代器也提供了对对象的间接访问。(可以访问某个元素，也可以移动迭代器，<code>好比指针</code>)</li><li>迭代器分为有效和无效。</li></ul><h3 id="🍑3-4-1-使用迭代器"><a href="#🍑3-4-1-使用迭代器" class="headerlink" title="🍑3.4.1 使用迭代器"></a>🍑3.4.1 使用迭代器</h3><ul><li>begin 返回指向第一个元素的迭代器</li><li>end 返回指向最后一个元素的下一位的迭代器（通常被称为尾后迭代器）<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> b = v.begin(), e = v.end()    <span class="comment">//返回的是iterator类型</span></span><br><span class="line"><span class="keyword">auto</span> c = v.cbegin(), f = v.cend()   <span class="comment">//返回的是const_iterator类型</span></span><br></pre></td></tr></table></figure>注意：如果容器为空，则begin和end返回的是同一个迭代器，都是尾后迭代器</li></ul><p><strong>迭代器运算符</strong><br>| 运算符           | 解释                                   |<br>| ———————— | ——————————————————— |<br>| <em>iter          | 返回迭代器iter所指向的<strong>元素的引用</strong> |<br>| iter-&gt;mem      | 等价于(</em>iter).mem                    |<br>| ++iter         | 令iter指示容器中的下一个元素         |<br>| - -iter         | 令iter指示容器中的上一个元素         |<br>| iter1 == iter2 | 判断两个迭代器是否相等                 |<br>| iter1 != iter2 | 判断两个迭代器是否不相等               |</p><p><strong>迭代器类型</strong></p><p>迭代器分为俩种类型:</p><ul><li>terator </li><li>const_iterator</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;::iterator it;       <span class="comment">//it能读写</span></span><br><span class="line"><span class="built_in">string</span>::iterator it;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;::const_iterator it; <span class="comment">//it只能读</span></span><br><span class="line"><span class="built_in">string</span>::const_iterator;</span><br></pre></td></tr></table></figure><p><strong>begin和end返回值类型</strong></p><ul><li>begin 和 end返回值具体类型由对象是否是常量来决定，如果对象是常量则，begin和end返回const_iterator，否则相反。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; v;</span><br><span class="line"><span class="type">const</span> <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; v1;</span><br><span class="line"><span class="keyword">auto</span> it = v.begin();  <span class="comment">//it类型是iterator</span></span><br><span class="line"><span class="keyword">auto</span> it1 = v1.begin(); <span class="comment">//it1类型为const_iterator</span></span><br></pre></td></tr></table></figure><p><strong>注意:凡是使用了迭代器进行循环，都不要向迭代器所属的容器中添加或者删除元素，可以更改元素，都则，迭代器不知道指向哪个元素，迭代器会失效</strong></p><p> <strong>迭代器运算</strong><br> string 和 vector支持的迭代运算。注意不能将俩个迭代器相加。<br> <code>vector</code>和<code>string</code>迭代器支持的运算：</p><div class="table-container"><table><thead><tr><th>运算符</th><th>解释</th></tr></thead><tbody><tr><td>iter + n</td><td>迭代器加上一个整数值仍得到一个迭代器，迭代器指示的新位置和原来相比向前移动了若干个元素。结果迭代器或者指示容器内的一个元素，或者指示容器尾元素的下一位置。</td></tr><tr><td>iter - n</td><td>迭代器减去一个证书仍得到一个迭代器，迭代器指示的新位置比原来向后移动了若干个元素。结果迭代器或者指向容器内的一个元素，或者指示容器尾元素的下一位置。</td></tr><tr><td>iter1 += n</td><td>迭代器加法的复合赋值语句，将<code>iter1</code>加n的结果赋给<code>iter1</code></td></tr><tr><td>iter1 -= n</td><td>迭代器减法的复合赋值语句，将<code>iter2</code>减n的加过赋给<code>iter1</code></td></tr><tr><td>iter1 - iter2</td><td>两个迭代器相减的结果是它们之间的距离，也就是说，将运算符右侧的迭代器向前移动差值个元素后得到左侧的迭代器。参与运算的两个迭代器必须指向的是同一个容器中的元素或者尾元素的下一位置。</td></tr><tr><td>&gt;、&gt;=、&lt;、&lt;=</td><td>迭代器的关系运算符，如果某迭代器        </td></tr></tbody></table></div><ul><li>difference_type：保证足够大以存储任何两个迭代器对象间的距离，可正可负。</li><li>迭代器只有相减，没有相加。<h2 id="🍌3-5-数组"><a href="#🍌3-5-数组" class="headerlink" title="🍌3.5 数组"></a>🍌3.5 数组</h2></li><li>数组的大小，长度固定，不可以变，相当于vector的低级版    </li></ul><h3 id="🍑3-5-1-定义和初始化内置数组"><a href="#🍑3-5-1-定义和初始化内置数组" class="headerlink" title="🍑3.5.1 定义和初始化内置数组"></a>🍑3.5.1 定义和初始化内置数组</h3><ul><li>数组的维度必须是个常量表达式<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">0</span>];                    <span class="comment">//数组的维度必须是个常量表达式</span></span><br><span class="line"><span class="type">unsigned</span> cnt = <span class="number">42</span>            <span class="comment">//不是常量表达式</span></span><br><span class="line">constexpr <span class="type">unsigned</span> cnt = <span class="number">42</span>; <span class="comment">//是常量表达式</span></span><br><span class="line"><span class="built_in">string</span> strs[get_size()];     <span class="comment">//当get_size()是constexpr时，是常量表达式</span></span><br></pre></td></tr></table></figure></li><li>数组和vector的元素必须是对象，不能是引用</li><li>数组不能用auto关键由初始值列表推断类型</li></ul><p><strong>字符数组的特殊性</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> a1[] = &#123;<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;+&#x27;</span>, <span class="string">&#x27;+&#x27;</span> &#125;;   <span class="comment">//列表初始化，没有空字符，维度是3</span></span><br><span class="line"><span class="type">char</span> a2[] = <span class="string">&quot;c ++&quot;</span>;            <span class="comment">//有空字符串，维度是4；</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> a4[<span class="number">3</span>] = <span class="string">&quot;c++&quot;</span>;      <span class="comment">//错误，没有空间存放空字符</span></span><br></pre></td></tr></table></figure></p><p>不能用数组为另一个数组赋值或拷贝。可以按元素一个一个拷贝，但不能直接拷贝整个数组。</p><p><strong>理解复杂的数组声明</strong></p><p>因为数组本身是一个对象，所以允许定义数组的指针以及数组的引用。</p><p><code>从数组的名字开始右内向外的顺序比较好理解</code><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *ptr[<span class="number">10</span>];           <span class="comment">// ptrs是一个含有10个整型指针的数组</span></span><br><span class="line"><span class="type">int</span> (*ptr)[<span class="number">10</span>] = &amp;arr;  <span class="comment">// ptrs是一个指针，指向一个含有10个整数的数组</span></span><br><span class="line"><span class="type">int</span> (&amp;ptr)[<span class="number">10</span>] = &amp;arr;  <span class="comment">// ptrs是一个引用，引用一个含有10个整数的数组</span></span><br></pre></td></tr></table></figure><br>例如：</p><ul><li>先读（），<em>ptr是一个指针，在往右看，这个指针指向一个数组，在往左看，这个数组是 int 型的， 所以int `(</em>ptr)[10] = &amp;arr`;  ptrs是一个指针，指向一个含有10个整数的数组</li></ul><h3 id="🍑3-5-2-访问数组元素"><a href="#🍑3-5-2-访问数组元素" class="headerlink" title="🍑3.5.2 访问数组元素"></a>🍑3.5.2 访问数组元素</h3><ul><li>数组的元素可以使用范围<code>for语句</code>或者<code>下标运算符</code>来进行访问</li><li>在使用数组下标时候，通常定义为<code>size_t类型</code>(是一种无符号类型，他被设计的足够大以便能表示内存中任意对象的大小)</li></ul><p><strong>数组相比vector的缺点是什么</strong></p><ul><li>数组的大小是确定的。</li><li>不能随意增加元素。</li><li>不允许拷贝和赋值。<br>数组不能直接拷贝，而是需要每个元素拷贝。而vector可以直接拷贝<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//数组需要每个元素进行拷贝</span></span><br><span class="line">   <span class="type">int</span> arr[<span class="number">10</span>];</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) arr[i] = i;</span><br><span class="line">   <span class="type">int</span> arr2[<span class="number">10</span>];</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) arr2[i] = arr[i];</span><br><span class="line">   </span><br><span class="line">   <span class="comment">//vector可以直接拷贝</span></span><br><span class="line">   <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; <span class="title function_">v</span><span class="params">(<span class="number">10</span>)</span>;</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i != <span class="number">10</span>; ++i) v[i] = arr[i];</span><br><span class="line">   <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; <span class="title function_">v2</span><span class="params">(v)</span>;</span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">auto</span> i : v2) <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br></pre></td></tr></table></figure></li></ul><h3 id="🍑3-5-3-指针和数组"><a href="#🍑3-5-3-指针和数组" class="headerlink" title="🍑3.5.3 指针和数组"></a>🍑3.5.3 指针和数组</h3><ul><li>在大多数情况，使用数组类型的对象其实是使用一个指向该数组首元素的指针</li><li>标准库类型（如 string、vector 等）的下标都是无符号类型，而数组内置的下标没有这个要求。</li><li>指向数组元素的指针等价于 vector 中的迭代器</li><li>指针访问数组：在表达式中使用数组名时，名字会自动转换成指向数组的第一个元素的指针。</li><li>使用数组时，编译器一般会把它转换成指针。</li></ul><h3 id="🍑3-5-4-c风格字符串"><a href="#🍑3-5-4-c风格字符串" class="headerlink" title="🍑3.5.4 c风格字符串"></a>🍑3.5.4 c风格字符串</h3><ul><li>c++是由c继承过来的c风格字符串</li><li>c 风格字符串<code>不是一种类型，而是一种写法</code>，是为了表达和使用字符串而形成的一种约定俗成的写法。</li><li>按此习惯书写的字符串存放在字符数组中并以<code>空字符（&#39;\0&#39;）</code>结束。</li><li>c++ 支持 c 风格字符串，但是最好不要使用，极易引发程序漏洞,对大多数应用来说，使用标准库 string比使用C风格字符串更安全、更高效。</li></ul><div class="table-container"><table><thead><tr><th>函数</th><th>介绍</th></tr></thead><tbody><tr><td>strlen(p1)</td><td>返回<code>p1</code>的长度，空字符不计算在内</td></tr><tr><td>strcmp(p1, p2)</td><td>比较<code>p1</code>和<code>p2</code>的相等性。如果<code>p1==p2</code>，返回0；如果<code>p1&gt;p2</code>，返回一个正值；如果<code>p1&lt;p2</code>，返回一个负值。</td></tr><tr><td>strcat(p1, p2)</td><td>将<code>p2</code>附加到<code>p1</code>之后，返回<code>p1</code></td></tr><tr><td>strcpy(p1, p2)</td><td>将<code>p2</code>拷贝给<code>p1</code>，返回<code>p1</code>                     </td></tr></tbody></table></div><ul><li>上述表中所列的函数不负责验证其字符串参数</li><li>传入参数的指针必须指向以空字符结束的数组。必须确保数组足够大。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> ca[] = &#123;<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>&#125;   <span class="comment">//不以空字符结束</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">strlen</span>(ca) &lt;&lt; <span class="built_in">endl</span>;      <span class="comment">//错误：ca没有以空字符结束</span></span><br></pre></td></tr></table></figure><code>对于 string，可以使用 s = s1 + s2，s1 &gt; s2 等加和与比较，而 c 风格字符串不行，因为他们实际上是指针。</code></li></ul><h3 id="🍑3-5-5与旧代码的接口"><a href="#🍑3-5-5与旧代码的接口" class="headerlink" title="🍑3.5.5与旧代码的接口"></a>🍑3.5.5与旧代码的接口</h3><p><strong>string对象和C风格字符串的混用</strong></p><ul><li><p>可以使用字符串字面值来初始化 string 对象或与 string 对象加和，所有可以用字符串字面值的地方都可以使用以空字符结束的字符数组来代替。</p></li><li><p>反过来不能使用 string 对象初始化字符数组，必须要用 <strong>c_str()</strong> 函数将 string 对象转化为 c 风格字符串</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> <span class="title function_">s</span> <span class="params">(<span class="string">&quot;hello world&quot;</span>)</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *str = s;          <span class="comment">//错误，不能用string对象初始化char* </span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* cp = s.c_str();  <span class="comment">// s.c_str() 返回一个指向以空字符结束的字符数组的指针。              </span></span><br></pre></td></tr></table></figure><p>​                </p><p><strong>使用数组初始化 vector 对象</strong></p><ul><li>不允许使用一个数组为另一个内置类型的数组赋值</li><li>可以使用数组来初始化 vector 对象，用两个指针来表明范围（左闭合区间）</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr[] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;; </span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; <span class="title function_">ivec</span><span class="params">(begin(arr), end(arr))</span>;              </span><br></pre></td></tr></table></figure><p>​<br><strong>建议不要使用 c 风格字符串和内置数值，都使用标准库容器</strong></p><h2 id="🍌3-6-多维数组"><a href="#🍌3-6-多维数组" class="headerlink" title="🍌3.6 多维数组"></a>🍌3.6 多维数组</h2><p>严格来说 C++ 中没有多维数组，那实际是数组的数组。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr[<span class="number">20</span>][<span class="number">30</span>][<span class="number">40</span>]   <span class="comment">//将所有元素初始化为 0</span></span><br></pre></td></tr></table></figure></p><p><strong>多维数组的初始化</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//显示初始化所有元素</span></span><br><span class="line"><span class="type">int</span> a[<span class="number">3</span>][<span class="number">4</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>&#125;</span><br><span class="line"><span class="type">int</span> a[<span class="number">3</span>][<span class="number">4</span>] = &#123;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;,&#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;,&#123;<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;,&#123;<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>&#125;&#125;  <span class="comment">//与上面等价</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//显示初始化部分元素</span></span><br><span class="line"><span class="type">int</span> a[<span class="number">3</span>][<span class="number">4</span>] = &#123;&#123;<span class="number">0</span>&#125;,&#123;<span class="number">1</span>&#125;,&#123;<span class="number">2</span>&#125;&#125;;  <span class="comment">//只是初始化了每一行的第一个元素</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></p><p><strong>多维数组的下标引用</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr[<span class="number">3</span>][<span class="number">4</span>];</span><br><span class="line">arr[<span class="number">0</span>];<span class="comment">//这是一个有四个元素的一维数组</span></span><br><span class="line">arr[<span class="number">0</span>][<span class="number">0</span>];<span class="comment">//第一行第一列的元素</span></span><br></pre></td></tr></table></figure></p><p><strong>使用范围 for 语句处理多维数组</strong></p><ul><li>c ++11中可以使用范围 for 语句处理多维数组。</li><li><code>注意范围 for 语句中改变元素值要显示使用 &amp; 符号声明为引用类型。</code></li><li><code>注意使用范围 for 循环处理多维数组时，除了最内层的循环外，其他所有循环的控制变量都应该是引用类型。</code></li><li>因为如果不声明为引用类型，编译器会自动将控制变量转换为指向数组首元素的指针，就不能在内层继续使用范围 for 循环处理该控制变量了。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">constexpr <span class="type">size_t</span> rowCnt = <span class="number">3</span>, colCnt = <span class="number">4</span>;</span><br><span class="line"><span class="type">int</span> ia [rowCnt][colCnt];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span>&amp; row : arr)          <span class="comment">//给每一行赋值</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> col : row)       <span class="comment">//给每一列进行赋值，例如先赋值[0][0],[0][1],[0][2]</span></span><br></pre></td></tr></table></figure><p>输出 arr 的元素有四种方法</p><ul><li>范围 for 语句-不使用类型别名</li><li>范围 for 语句-使用类型别名</li><li>普通 for 循环</li><li>指针<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 范围 for 语句-不使用类型别名</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">const</span> <span class="type">int</span> (&amp;row)[<span class="number">4</span>] : arr)</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> col : row)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; col &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 范围 for 语句-使用类型别名</span></span><br><span class="line">using int_array = <span class="type">int</span>[<span class="number">4</span>];</span><br><span class="line"><span class="keyword">for</span> (int_array &amp;p : ia)</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> q : p)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; q &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 普通 for 循环</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i != <span class="number">3</span>; ++i)</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> j = <span class="number">0</span>; j != <span class="number">4</span>; ++j)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; arr[i][j] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指针</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> (*row)[<span class="number">4</span>] = arr; row != arr + <span class="number">3</span>; ++row)</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> *col = *row; col != *row + <span class="number">4</span>; ++col)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *col &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><strong>指针vs引用</strong></li><li>引用总是指向某个对象，定义引用时没有初始化是错的。</li><li>给引用赋值，修改的是该引用所关联的对象的值，而不是让引用和另一个对象相关联</li></ul><p><strong>动态数组</strong></p><ul><li>使用 <code>new</code>和 <code>delete</code>表达和c中<code>malloc</code>和<code>free</code>类似的功能，即在堆（自由存储区）中分配存储空间。</li><li>定义： <code>int *pia = new int[10];</code>10可以被一个变量替代。</li><li>释放： <code>delete [] pia;</code>，注意不要忘记[]。</li></ul>]]></content>
      
      
      <categories>
          
          <category> c++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>shell脚本编程</title>
      <link href="/2022/04/23/post2/"/>
      <url>/2022/04/23/post2/</url>
      
        <content type="html"><![CDATA[<h3 id="第1章-Shell概述"><a href="#第1章-Shell概述" class="headerlink" title="第1章 Shell概述"></a>第1章 Shell概述</h3><ul><li>shell是一个<a href="https://so.csdn.net/so/search?q=命令行&amp;spm=1001.2101.3001.7020">命令行</a>解释器，它接收应用程序/用户命令，然后调用操作系统内核</li></ul><h3 id="第2章-Shell-解析器"><a href="#第2章-Shell-解析器" class="headerlink" title="第2章 Shell 解析器"></a>第2章 Shell 解析器</h3><ul><li><p>linux 提供的Shell 解析器有很多，最常用的俩个解析器为：sh和bash。</p></li><li><p>Centos默认的解析器是bash</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@zjh home]<span class="meta"># echo $SHELL</span></span><br><span class="line">/bin/bash</span><br></pre></td></tr></table></figure></li></ul><h3 id="第3章-Shell脚本入门"><a href="#第3章-Shell脚本入门" class="headerlink" title="第3章 Shell脚本入门"></a>第3章 Shell脚本入门</h3><ul><li><p><strong>脚本格式</strong></p><p>脚本以#!/bin/bash 开头（指定解析器）</p></li><li><p><strong>第一个Shell 脚本：helloworld</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># 创建脚本</span><br><span class="line">[root@zjh home]<span class="meta"># cat helloworld.sh </span></span><br><span class="line">#!/bin/bash</span><br><span class="line">echo <span class="string">&quot;hello zjh&quot;</span></span><br><span class="line"></span><br><span class="line"># 执行脚本方式<span class="number">1</span></span><br><span class="line">[root@zjh home]<span class="meta"># bash helloworld.sh </span></span><br><span class="line">hello zjh</span><br><span class="line"></span><br><span class="line"># 执行脚本方式<span class="number">2</span></span><br><span class="line">[root@zjh home]# ./helloworld.sh</span><br><span class="line">-bash: ./helloworld.sh: 权限不够</span><br></pre></td></tr></table></figure><p><strong>方式1，本质是bash解析器帮你执行脚本，所以脚本本身不需要执行权限；</strong></p><p><strong>方式2，本质是脚本自己需要执行，所以需要执行权限</strong></p></li></ul><ul><li><p><strong>第二个Shell 脚本：多命令处理</strong></p><p>需求 ：在linux家目录下创建一个bangzhang.txt并在文件中写入”I IOVE YOU”字符.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@zjh home]<span class="meta"># touch batch.sh</span></span><br><span class="line">[root@zjh home]<span class="meta"># vim batch.sh</span></span><br><span class="line"></span><br><span class="line">#!/bin/bash</span><br><span class="line">cd /home/linux/</span><br><span class="line">touch banzhang.txt</span><br><span class="line">echo <span class="string">&quot;I LOVE YOU&quot;</span> &gt;&gt; banzhang.txt</span><br></pre></td></tr></table></figure></li></ul><h3 id="第4章-Shell中的变量"><a href="#第4章-Shell中的变量" class="headerlink" title="第4章 Shell中的变量"></a>第4章 Shell中的变量</h3><h4 id="4-1-系统变量"><a href="#4-1-系统变量" class="headerlink" title="4.1 系统变量"></a>4.1 系统变量</h4><ul><li><p>常用系统变量 $HOME $PWD $SHELL $USER</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@zjh home]<span class="meta"># echo $HOME</span></span><br><span class="line">/home/linux</span><br><span class="line">[root@zjh home]<span class="meta"># echo $PWD</span></span><br><span class="line">/home/linux/datas</span><br><span class="line">[root@zjh home]<span class="meta"># echo $SHELL</span></span><br><span class="line">/bin/bash</span><br><span class="line">[root@zjh home]<span class="meta"># echo $USER</span></span><br><span class="line">linux</span><br></pre></td></tr></table></figure></li></ul><h4 id="4-2自定义变量"><a href="#4-2自定义变量" class="headerlink" title="4.2自定义变量"></a>4.2自定义变量</h4><ul><li><p><strong>1.基本语法</strong></p><p>定义变量：变量=值 <strong>等号两边不能留有空格</strong></p><p>撤销变量：unset 变量</p><p>输出变量：echo $变量</p><p>声明静态变量： readonly 变量，==注意：不能unset==</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[root@zjh home]# A=<span class="number">1</span></span><br><span class="line">[root@zjh home]<span class="meta"># echo $A</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line">[root@zjh home]<span class="meta"># unset A</span></span><br><span class="line">    </span><br><span class="line"><span class="meta"># readonly 变量，注意：不能unset</span></span><br><span class="line">[root@zjh home]<span class="meta"># readonly B=2</span></span><br><span class="line">[root@zjh home]<span class="meta"># echo $B</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line">    </span><br><span class="line">[root@zjh home]# B=<span class="number">9</span></span><br><span class="line">-bash : B: readonly variable</span><br><span class="line">    </span><br><span class="line">    </span><br></pre></td></tr></table></figure></li></ul><ul><li><p><strong>2.变量定义规则</strong></p><ol><li><p>变量名称可以由字母，数字和下划线组成，不能以数字开头，==环境变量名建议大写==</p></li><li><p>==等号两侧不能有空格==</p></li><li><p>在bash中，变量默认类型都是字符串类型，无法直接进行数值运算</p></li><li><p>变量的值如果有空格，需要使用双引号或单引号括起来</p></li></ol></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@zjh home]# D=<span class="string">&quot;A B C&quot;</span></span><br><span class="line">[root@zjh home]<span class="meta"># echo $D</span></span><br><span class="line">A B C</span><br><span class="line">    </span><br><span class="line">[root@zjh home]# C=<span class="number">1</span>+<span class="number">2</span></span><br><span class="line">[root@zjh home]<span class="meta"># echo $c</span></span><br><span class="line"><span class="number">1</span>+<span class="number">2</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>可把变量提升为全局变量，可供其他shell程序使用:<br>export 变量</li></ul><h4 id="4-3-特殊变量：-n"><a href="#4-3-特殊变量：-n" class="headerlink" title="4.3 特殊变量：$n"></a>4.3 特殊变量：$n</h4><ul><li>$n——n为数字，$0 代表脚本名称，10以内参数用$1-$9表示，10以上需要用大括号${10}.</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">echo <span class="string">&quot;$0&quot;</span> <span class="string">&quot;$1&quot;</span> <span class="string">&quot;$2&quot;</span> <span class="string">&quot;$3&quot;</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@zjh home]<span class="meta"># sh parameter.sh</span></span><br><span class="line">parameter.sh</span><br><span class="line">  </span><br><span class="line">[root@zjh home]<span class="meta"># sh parameter.sh 10 lal 20</span></span><br><span class="line">parameter.sh <span class="number">10</span> lal <span class="number">20</span></span><br></pre></td></tr></table></figure><h4 id="4-4-特殊变量："><a href="#4-4-特殊变量：" class="headerlink" title="4.4 特殊变量：$"></a>4.4 特殊变量：$</h4><ul><li>$#——获取所有输入参数个数，常用于循环</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@zjh home]<span class="meta"># vim parameter.sh</span></span><br><span class="line">#!/bin/bash</span><br><span class="line">echo <span class="string">&quot;$0&quot;</span> <span class="string">&quot;$1&quot;</span> <span class="string">&quot;$2&quot;</span></span><br><span class="line">echo $#</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@zjh home]<span class="meta"># bash parameter.sh</span></span><br><span class="line">parameter.sh</span><br><span class="line"><span class="number">0</span></span><br><span class="line">[root@zjh home]<span class="meta"># bash parameter.sh 10 lala 20</span></span><br><span class="line">parameter.sh <span class="number">10</span> lala <span class="number">20</span></span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure><h4 id="4-5-特殊变量：-和"><a href="#4-5-特殊变量：-和" class="headerlink" title="4.5 特殊变量：$* 和$@"></a>4.5 特殊变量：$* 和$@</h4><ul><li><p>$* ——代表命令行中所有的参数，把所有参数看成一个整体</p></li><li><p>$@ ——也代表命令行中所有的参数，不过把每个参数区分对待</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@zjh home]<span class="meta"># vim parameter.sh</span></span><br><span class="line">echo <span class="string">&quot;$0&quot;</span> <span class="string">&quot;$1&quot;</span> <span class="string">&quot;$2&quot;</span> <span class="string">&quot;$3&quot;</span></span><br><span class="line">echo $<span class="meta">#</span></span><br><span class="line"><span class="meta">echo $*</span></span><br><span class="line">echo #@</span><br></pre></td></tr></table></figure>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@zjh home]<span class="meta"># sh parameter.sh 1 2 3</span></span><br><span class="line">parameter.sh <span class="number">1</span> <span class="number">2</span> <span class="number">3</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span></span><br></pre></td></tr></table></figure><h4 id="4-6-特殊变量：-？"><a href="#4-6-特殊变量：-？" class="headerlink" title="4.6 特殊变量：$？"></a>4.6 特殊变量：$？</h4><ul><li><p>$?——最后一个执行的命令的返回状态。如果这个变量的值为0，则最后一个命令正确执行</p><p>​            如果这个值为非0（具体哪一个数，由命令自己来决定），则证明上一个命令执行不正确</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">[root@zjh home]<span class="meta"># sh parameter.sh 1 2 3</span></span><br><span class="line">parameter.sh <span class="number">1</span> <span class="number">2</span> <span class="number">3</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span></span><br><span class="line">    </span><br><span class="line">[root@zjh home]# $?                          执行失败返回非<span class="number">0</span></span><br><span class="line">-bash:<span class="number">0</span> : command <span class="keyword">not</span> found</span><br><span class="line">[root@zjh home]<span class="meta">#  echo $?</span></span><br><span class="line"><span class="number">127</span></span><br><span class="line">    </span><br><span class="line">[root@zjh home]<span class="meta">#  sh parameter.sh 1 2 3       执行成功返回0</span></span><br><span class="line">parameter.sh <span class="number">1</span> <span class="number">2</span> <span class="number">3</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span></span><br><span class="line">    </span><br><span class="line">[root@zjh home]<span class="meta"># echo $?</span></span><br><span class="line"><span class="number">0</span></span><br></pre></td></tr></table></figure><h3 id="第5章-运算符"><a href="#第5章-运算符" class="headerlink" title="第5章 运算符"></a>第5章 运算符</h3><h4 id="5-1-基本语法"><a href="#5-1-基本语法" class="headerlink" title="5.1 基本语法"></a>5.1 基本语法</h4><ul><li>$((运算式))  或者  $[运算式]</li><li>expr +. -, *, /, %  加，减，乘，除，取余<br>  ==注意：expr运算符间要有空格==</li></ul><h4 id="5-2-实例实操"><a href="#5-2-实例实操" class="headerlink" title="5.2  实例实操"></a>5.2  实例实操</h4><p>计算3+2的值</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@zjh home]<span class="meta"># expr 2 + 3</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line">[root@zjh home]<span class="meta"># expr 2+3</span></span><br><span class="line">error</span><br></pre></td></tr></table></figure><p>计算（2+3）x4的值</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@zjh home]<span class="meta"># expr `expr 2 + 3` \* 4</span></span><br><span class="line"><span class="number">20</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@zjh home]<span class="meta">#  a=$[(2+3)*4]</span></span><br><span class="line">[root@zjh home]<span class="meta">#  echo $a</span></span><br><span class="line"><span class="number">20</span></span><br></pre></td></tr></table></figure><h3 id="第6章条件判断"><a href="#第6章条件判断" class="headerlink" title="第6章条件判断"></a>第6章条件判断</h3><h4 id="6-1基本语法"><a href="#6-1基本语法" class="headerlink" title="6.1基本语法"></a>6.1基本语法</h4><p>[ condition ] ==(注意 condition前后要有空格)==</p><p>注意：条件非空即为true,  [atguigu] 返回 true, []返回false</p><h4 id="6-2常用条件判断"><a href="#6-2常用条件判断" class="headerlink" title="6.2常用条件判断"></a>6.2常用条件判断</h4><div class="table-container"><table><thead><tr><th style="text-align:center">符号</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">-lt</td><td style="text-align:center">(less than)        小于</td></tr><tr><td style="text-align:center">-le</td><td style="text-align:center">(less equal)      小于等于</td></tr><tr><td style="text-align:center">-eq</td><td style="text-align:center">(equal)              等于</td></tr><tr><td style="text-align:center">-gt</td><td style="text-align:center">(greater than)  大于</td></tr><tr><td style="text-align:center">-ge</td><td style="text-align:center">(greater equal) 大于等于</td></tr><tr><td style="text-align:center">-ne</td><td style="text-align:center">(no eqeual)       不等于</td></tr></tbody></table></div><h5 id="文件权限判断"><a href="#文件权限判断" class="headerlink" title="文件权限判断"></a>文件权限判断</h5><ul><li>-r 有读的权限</li><li>-w 有写的权限</li><li>-x 有执行的权限</li></ul><h5 id="文件类型判断"><a href="#文件类型判断" class="headerlink" title="文件类型判断"></a>文件类型判断</h5><ul><li>-f 文件存在并且是一个常规文件  (file)</li><li>-e 文件存在                                   (exixtence)</li><li>-d 文件存在病是一个目录            (directory)</li></ul><h4 id="6-3-案例实操"><a href="#6-3-案例实操" class="headerlink" title="6.3 案例实操"></a>6.3 案例实操</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"># 判断<span class="number">23</span>是否大于<span class="number">2</span></span><br><span class="line">[root@zjh home]# $ [ <span class="number">23</span> -gt <span class="number">2</span> ]</span><br><span class="line">[root@zjh home]<span class="meta"># echo $?</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"></span><br><span class="line">[root@zjh home]# $ [ <span class="number">23</span> -le <span class="number">2</span> ]   </span><br><span class="line">[root@zjh home]<span class="meta"># echo $?           #返回值非0说明上一条指令执行错误，也就是[ 23 -le 2 ] </span></span><br><span class="line"><span class="number">1</span>                                  #是错误的</span><br><span class="line">    </span><br><span class="line"># 判断helloworld.sh是否有写入权限</span><br><span class="line">[root@zjh home]#  [ -w hellowrld.sh ]</span><br><span class="line">[root@zjh home]<span class="meta">#  echo $?</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"></span><br><span class="line"># 判断目录中文件是否存在</span><br><span class="line">[root@zjh home]#  [ -e /home/linux/datas ]</span><br><span class="line">[root@zjh home]<span class="meta">#  echo $?</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">#多条件判断</span><br><span class="line">[root@zjh home]# [ condition ] &amp;&amp; echo OK || echo notok </span><br><span class="line">OK</span><br><span class="line">[root@zjh home]# [ condition ] &amp;&amp; [] || echo notol</span><br><span class="line">notok</span><br></pre></td></tr></table></figure><h3 id="第7章-流程控制（重点）"><a href="#第7章-流程控制（重点）" class="headerlink" title="第7章 流程控制（重点）"></a>第7章 流程控制（重点）</h3><h4 id="7-1-if语句"><a href="#7-1-if语句" class="headerlink" title="7.1 if语句"></a>7.1 if语句</h4><ul><li><p>==注意事项==：[ 条件判断 ]，中括号和条件判断之间必须有空格。</p></li><li><p>if 后要有空格</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[root@zjh home]<span class="meta"># cat <span class="keyword">if</span>.sh</span></span><br><span class="line">#!/bin/bash</span><br><span class="line"><span class="keyword">if</span> [ $<span class="number">1</span> -eq <span class="number">1</span> ]</span><br><span class="line">then</span><br><span class="line">echo <span class="string">&quot;我最帅&quot;</span></span><br><span class="line">elif [ $<span class="number">1</span> -eq <span class="number">2</span> ]</span><br><span class="line">then</span><br><span class="line">echo <span class="string">&quot;我最好看&quot;</span></span><br><span class="line">fi</span><br><span class="line">    </span><br><span class="line">[root@zjh home]<span class="meta"># bash <span class="keyword">if</span>.sh 2</span></span><br><span class="line">我最好看</span><br></pre></td></tr></table></figure><h4 id="7-2-case语句"><a href="#7-2-case语句" class="headerlink" title="7.2 case语句"></a>7.2 case语句</h4><p><strong>注意事项</strong>：</p><ul><li>case 行尾必须为单词”in”, 每一个模式匹配必须以右括号“）”结束。</li><li>双分号“；；” 表示命令序列结束，相当于java中的break.</li><li>最后的“*）” 表示默认模式，相当于java中的default.</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[root@zjh home]<span class="meta"># cat case.sh</span></span><br><span class="line">#!/bin/bash</span><br><span class="line"><span class="keyword">case</span> $<span class="number">1</span> in</span><br><span class="line"><span class="number">1</span>)</span><br><span class="line">echo <span class="string">&quot;班长&quot;</span></span><br><span class="line">;;</span><br><span class="line"><span class="number">2</span>)</span><br><span class="line">echo <span class="string">&quot;学委&quot;</span></span><br><span class="line">;;</span><br><span class="line"><span class="number">3</span>)</span><br><span class="line">echo <span class="string">&quot;体委&quot;</span></span><br><span class="line">;;</span><br><span class="line">*) </span><br><span class="line">    exho <span class="string">&quot;人妖&quot;</span></span><br><span class="line">esac</span><br><span class="line">[root@zjh home]<span class="meta"># bash case.sh 4</span></span><br><span class="line">人妖</span><br></pre></td></tr></table></figure><h4 id="7-3-for循环"><a href="#7-3-for循环" class="headerlink" title="7.3 for循环"></a>7.3 for循环</h4><h5 id="语法1"><a href="#语法1" class="headerlink" title="语法1"></a>语法1</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@zjh home]<span class="meta"># cat for.sh</span></span><br><span class="line">#!/bin/bash</span><br><span class="line">s=<span class="number">0</span></span><br><span class="line"><span class="keyword">for</span>((i=<span class="number">1</span>;i&lt;=<span class="number">100</span>;i++))</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">s=$[$s+$i]</span><br><span class="line">done</span><br><span class="line">echo $s</span><br><span class="line">[root@zjh home]<span class="meta"># bash for.sh</span></span><br><span class="line"><span class="number">5050</span></span><br></pre></td></tr></table></figure><h5 id="语法2"><a href="#语法2" class="headerlink" title="语法2"></a>语法2</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[root@zjh home]<span class="meta"># cat for2.sh</span></span><br><span class="line">#!/bin/bash</span><br><span class="line"><span class="keyword">for</span> i in $*</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">echo $i</span><br><span class="line">done</span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> i in $@</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    echo $j</span><br><span class="line">done</span><br><span class="line">    </span><br><span class="line">[root@zjh home]<span class="meta"># bash for2.sh 1 2              <span class="comment">//看不出什么区别</span></span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[root@zjh home]<span class="meta"># cat for2.sh</span></span><br><span class="line">#!/bin/bash</span><br><span class="line"><span class="keyword">for</span> i in <span class="string">&quot;$*&quot;</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">echo $i</span><br><span class="line">done</span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> i in <span class="string">&quot;$@&quot;</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    echo $j</span><br><span class="line">done</span><br><span class="line">    </span><br><span class="line">[root@zjh home]<span class="meta"># bash for2.sh 1 2             <span class="comment">//能看出明显区别</span></span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span>                                           <span class="comment">//$* 是把输入的看成一个整体全部赋给i</span></span><br><span class="line"><span class="number">1</span>                                             <span class="comment">//$@ 是把输入分开传送，依次循环赋给j</span></span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure><h4 id="7-4-while-循环"><a href="#7-4-while-循环" class="headerlink" title="7.4 while 循环"></a>7.4 while 循环</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[root@zjh home]<span class="meta"># cat while.sh</span></span><br><span class="line">#!/bin/bash</span><br><span class="line">s=<span class="number">0</span></span><br><span class="line">i=<span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> [ $i -le <span class="number">100</span> ]    <span class="comment">//i是变量，我们这里使用的是i的值i的值为$i</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">s=$[$s + $i]</span><br><span class="line">i=$[$i + <span class="number">1</span>]</span><br><span class="line">done</span><br><span class="line">echo $s</span><br><span class="line"></span><br><span class="line">[root@zjh home]<span class="meta"># bash while.sh</span></span><br><span class="line"><span class="number">5050</span></span><br></pre></td></tr></table></figure><h3 id="第8章-read读取控制台输入"><a href="#第8章-read读取控制台输入" class="headerlink" title="第8章 read读取控制台输入"></a>第8章 read读取控制台输入</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">read</span>(选项)(参数)</span><br></pre></td></tr></table></figure><ul><li>-p 指定读取值时的提示符</li><li>-t 指定读取值时等待的时间（秒）</li></ul><p>参数：</p><p>变量：指定读取值得变量名</p><p><strong>实际上就是把选项输入的值，赋给变量（参数）</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># 提示<span class="number">7</span>秒内，读取控制台输入的名称</span><br><span class="line">[root@zjh home]<span class="meta"># cat read.sh</span></span><br><span class="line">#!/bin/bash</span><br><span class="line">read -t <span class="number">7</span> -p <span class="string">&quot;input your name&quot;</span> NAME</span><br><span class="line">echo $NAME</span><br><span class="line">    </span><br><span class="line">[root@zjh home]<span class="meta"># bash read.sh            <span class="comment">//如果7秒没有输入自动结束</span></span></span><br><span class="line">[root@zjh home]<span class="meta"># bash read.sh</span></span><br><span class="line">input your name   zjh</span><br><span class="line">zjh</span><br></pre></td></tr></table></figure><h3 id="第9章-函数"><a href="#第9章-函数" class="headerlink" title="第9章 函数"></a>第9章 函数</h3><h4 id="9-1-系统函数"><a href="#9-1-系统函数" class="headerlink" title="9.1 系统函数"></a>9.1 系统函数</h4><ul><li><p><strong>basename 基本语法</strong></p><p>basename[string / pathname] [suffix] ——basename命令会删掉所有的前缀包括最后一个（’/‘）字符，然后将字符串显示出来。</p><p><strong>选项：</strong></p><p>suffix 为后缀，如果suffix被指定了，basename会将pathname或string中的suffix去掉</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 方式<span class="number">1</span></span><br><span class="line">[root@zjh home]<span class="meta"># basename /home/linux/banzhang.txt</span></span><br><span class="line">banzhang.txt</span><br><span class="line"></span><br><span class="line"># 方式<span class="number">2</span></span><br><span class="line">[root@zjh home]<span class="meta"># basename /home/linux/banzhang.txt .txt</span></span><br><span class="line">banzhang</span><br></pre></td></tr></table></figure></li><li><p><strong>dirname基本语法</strong></p><p>dirname 文件绝对路径——从给定的包含绝对路径的文件名中去除文件名（非目录的部分），然后返回剩下的路径（目录的部分）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@zjh home]<span class="meta"># dirname /home/linux/banzhang.txt</span></span><br><span class="line">/home/linux</span><br></pre></td></tr></table></figure></li></ul><h4 id="9-2-自定义函数"><a href="#9-2-自定义函数" class="headerlink" title="9.2 自定义函数"></a>9.2 自定义函数</h4><ul><li>```c++<h1 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h1>[function] funname[()]     //[function] 选择项可写，可不写<br>{<pre><code>Action;[return int;]</code></pre>}<br>funname<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- **经验技巧**</span><br><span class="line"></span><br><span class="line">  - 必须在调用函数之前，先声明函数，shell脚本是逐步运行。不会像其他语言一样先编译。</span><br><span class="line"></span><br><span class="line">  - 函数返回值，只能通过$?系统变量获得，可以显示加：return 返回，如果不加，将以最后一条命令运行结果，作为返回值。return后跟数值n(0-255).</span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">```c++</span><br><span class="line"># DESC 计算输入两个参数的值</span><br><span class="line">[root@zjh home]# cat sum.sh</span><br><span class="line">#!/bin/bash</span><br><span class="line">function sum()&#123;</span><br><span class="line">s=0;</span><br><span class="line">s=$[$1 + $2]</span><br><span class="line">echo $s</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">read -p &quot;input your sum1:&quot; P1</span><br><span class="line">read -p &quot;input your sum2:&quot; P2</span><br><span class="line">sum $P1 $P2</span><br><span class="line">    </span><br><span class="line">[root@zjh home]# bash sum.sh</span><br><span class="line">input your sum1:1</span><br><span class="line">input your sum2:2</span><br><span class="line">3</span><br></pre></td></tr></table></figure></li></ul><h3 id="第10章-Shell工具（重点）"><a href="#第10章-Shell工具（重点）" class="headerlink" title="第10章 Shell工具（重点）"></a>第10章 Shell工具（重点）</h3><h4 id="10-1-cut"><a href="#10-1-cut" class="headerlink" title="10.1 cut"></a>10.1 cut</h4><p>cut命令从文件的每一行剪切字节，字符和字段并将这些字节，字符和字段输出。<br>cut [选项参数] filename</p><p>说明：默认分隔符是制表符</p><ul><li>-f 列号，提取第几列</li><li>-d 分隔符，按照指定分隔符分隔列</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># DESC 切割cut.txt第一列</span><br><span class="line">[root@zjh home]<span class="meta"># cat cut.txt</span></span><br><span class="line">dong shen</span><br><span class="line">guan zhen</span><br><span class="line">wo wo</span><br><span class="line">lai lai</span><br><span class="line">le le</span><br><span class="line">[root@zjh home]<span class="meta">#cut -d <span class="string">&quot; &quot;</span> -f 1 cut.txt</span></span><br><span class="line">dong</span><br><span class="line">guan</span><br><span class="line">wo</span><br><span class="line">lai</span><br><span class="line">le</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#在cut.txt文件中切割出guan</span><br><span class="line">[root@zjh home]<span class="meta"># cat cut.txt</span></span><br><span class="line">dong shen</span><br><span class="line">guan zhen</span><br><span class="line">wo wo</span><br><span class="line">lai lai</span><br><span class="line">le le</span><br><span class="line">[root@zjh home]<span class="meta"># cat cut.txt | grep guan</span></span><br><span class="line">guan zhen</span><br><span class="line">[root@zjh home]<span class="meta"># cat cut.txt | grep guan | cut -d <span class="string">&quot; &quot;</span> -f 1</span></span><br><span class="line">guan</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#选取系统PATH变量值，第<span class="number">2</span>个“：”开始后的所有路径</span><br><span class="line">[root@zjh home]<span class="meta"># echo $PATH</span></span><br><span class="line">/usr/lib64/qt<span class="number">-3.3</span>/bin:/usr/local/bin:/bin:/usr/bin:/usr/local/sbin:/</span><br><span class="line">usr/sbin:/sbin:/home/atguigu/bin</span><br><span class="line"></span><br><span class="line">[root@zjh home]<span class="meta"># echo $PATH | cut -d : -f 3-              <span class="comment">//不加-表示第三列，加=表示第三列之后</span></span></span><br><span class="line">/usr/bin:/usr/local/sbin:/usr/sbin:/sbin:/home/atguigu/bin</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#切割ifconfig后打印IP地址</span><br><span class="line">[root@zjh ~]<span class="meta"># ifconfig ens33</span></span><br><span class="line">ens33: flags=<span class="number">4163</span>&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu <span class="number">1500</span></span><br><span class="line">        inet:<span class="number">192.168</span><span class="number">.56</span><span class="number">.137</span>  netmask:<span class="number">255.255</span><span class="number">.255</span><span class="number">.0</span>  broadcast:<span class="number">192.168</span><span class="number">.56</span><span class="number">.255</span></span><br><span class="line">        inet6 fe80::<span class="number">5</span>da3:<span class="number">53</span>d8:<span class="number">5</span>d87:<span class="number">598</span>c  prefixlen <span class="number">64</span>  scopeid <span class="number">0x20</span>&lt;link&gt;</span><br><span class="line">        ether <span class="number">00</span>:<span class="number">0</span>c:<span class="number">29</span>:ad:<span class="number">3</span>d:<span class="number">0f</span>  txqueuelen <span class="number">1000</span>  (Ethernet)</span><br><span class="line">        RX packets <span class="number">1818</span>  bytes <span class="number">139153</span> (<span class="number">135.8</span> KiB)</span><br><span class="line">        RX errors <span class="number">0</span>  dropped <span class="number">0</span>  overruns <span class="number">0</span>  frame <span class="number">0</span></span><br><span class="line">        TX packets <span class="number">301</span>  bytes <span class="number">28358</span> (<span class="number">27.6</span> KiB)</span><br><span class="line">        TX errors <span class="number">0</span>  dropped <span class="number">0</span> overruns <span class="number">0</span>  carrier <span class="number">0</span>  collisions <span class="number">0</span></span><br><span class="line"></span><br><span class="line">[root@zjh ~]<span class="meta"># ifconfig ens33 | grep inet</span></span><br><span class="line">        inet:<span class="number">192.168</span><span class="number">.56</span><span class="number">.137</span>  netmask:<span class="number">255.255</span><span class="number">.255</span><span class="number">.0</span>  broadcast:<span class="number">192.168</span><span class="number">.56</span><span class="number">.255</span></span><br><span class="line">            </span><br><span class="line">[root@zjh ~]<span class="meta"># ifconfig ens33 | grep inet | cut -d : -f 2       </span></span><br><span class="line"><span class="number">192.168</span><span class="number">.56</span><span class="number">.137</span> netmask</span><br><span class="line"></span><br><span class="line">[root@zjh ~]<span class="meta"># ifconfig ens33 | grep inet | cut -d : -f 2 | cut -d <span class="string">&quot; &quot;</span> -f 1</span></span><br><span class="line"><span class="number">192.168</span><span class="number">.56</span><span class="number">.137</span></span><br></pre></td></tr></table></figure><h4 id="10-2-sed"><a href="#10-2-sed" class="headerlink" title="10.2 sed"></a>10.2 sed</h4><p><strong>1. 基本用法</strong></p><ul><li>sed是一种<strong>流编辑器</strong>，它一次处理一行内容，处理时，把当前处理的行存储在临时缓冲区中，成为“模式空间”,接着sed命令处理缓冲区中的内容，处理完成后，把缓冲区的内容送往屏幕，接着处理下一行，这样不断重复，知道文件末尾，<strong>文件内容并没有改变</strong>，除非你使用重定向存储输出。</li></ul><p><strong>2.选项参数说明</strong></p><ul><li><p>sed [选项参数]   ‘command’   filename</p><ul><li>-e     直接在指令列模式上进行sed的动作编辑</li></ul></li></ul><p><strong>3. 命令功能描述</strong></p><ul><li><p>a      新增，a的后面可以接字符串，在下一行出现</p></li><li><p>d      删除</p></li><li><p>s      查找并替换</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># DESC 在第二行后增加mei nv字符</span><br><span class="line">[root@zjh ~]<span class="meta"># sed  <span class="string">&quot;2a mei nv&quot;</span> sed.txt   <span class="comment">//2a表示第二行</span></span></span><br><span class="line">dong zhen                                <span class="comment">//单个一个需求命令的话，不需要-e，后面再说</span></span><br><span class="line">guan zhen</span><br><span class="line">mei nv</span><br><span class="line">wo wo</span><br><span class="line">lai lai</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#删除set.txt文件所有包含wo的行</span><br><span class="line">[root@zjh ~]# sed &#x27;/wo/d&#x27; sed.txt</span><br><span class="line">dong zhen                                </span><br><span class="line">guan zhen</span><br><span class="line"></span><br><span class="line">lai lai</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#将sed.txt文件中wo替换为ni</span><br><span class="line">[root@zjh ~]<span class="meta"># sed  <span class="string">&quot;s/wo/ni/g&quot;</span> sed.txt     g代表全局变量，把所有的wo替换为ni</span></span><br><span class="line">dong zhen                               </span><br><span class="line">guan zhen</span><br><span class="line">ni ni</span><br><span class="line">lai lai</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#将sed.txt文件中的第二行删除并将wo替换成ni</span><br><span class="line">[root@zjh ~]<span class="meta"># sed -e <span class="string">&quot;2d&quot;</span> -e <span class="string">&quot;s/wo/ni/g&quot;</span>  sed.txt</span></span><br><span class="line">dong zhen                               </span><br><span class="line">ni ni</span><br><span class="line">lai lai</span><br></pre></td></tr></table></figure><h4 id="10-3-awk"><a href="#10-3-awk" class="headerlink" title="10.3 awk"></a>10.3 awk</h4><p>awk 一个强大文件分析工具，把文件逐行的读入，以空格为默认分隔符将每行切片，切开的部分再进行分析处理。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk [选项参数] <span class="string">&#x27;pattern1 &#123;action1&#125; pattern2&#123;action2&#125;..&#x27;</span> filename</span><br></pre></td></tr></table></figure><ul><li>-F 指定输入文件分隔符</li><li>-v 赋值一个用户定义变量</li></ul><h4 id="10-4-sort"><a href="#10-4-sort" class="headerlink" title="10.4 sort"></a>10.4 sort</h4><p>sort 命令是在Linux里非常有用，它将文件进行排序，并将排序结果标准输出</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sort [选项] (参数)</span><br></pre></td></tr></table></figure><div class="table-container"><table><thead><tr><th style="text-align:center">参数</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">-n</td><td style="text-align:center">依照数值大小排序</td></tr><tr><td style="text-align:center">-r</td><td style="text-align:center">以相反的顺序排序</td></tr><tr><td style="text-align:center">-t</td><td style="text-align:center">设置排序时使用的分隔字符</td></tr><tr><td style="text-align:center">-k</td><td style="text-align:center">指定需要排序的列</td></tr></tbody></table></div><p>hen</p><p>lai lai<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">```c++</span><br><span class="line">#将sed.txt文件中wo替换为ni</span><br><span class="line">[root@zjh ~]# sed  &quot;s/wo/ni/g&quot; sed.txt     g代表全局变量，把所有的wo替换为ni</span><br><span class="line">dong zhen                               </span><br><span class="line">guan zhen</span><br><span class="line">ni ni</span><br><span class="line">lai lai</span><br></pre></td></tr></table></figure></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#将sed.txt文件中的第二行删除并将wo替换成ni</span><br><span class="line">[root@zjh ~]<span class="meta"># sed -e <span class="string">&quot;2d&quot;</span> -e <span class="string">&quot;s/wo/ni/g&quot;</span>  sed.txt</span></span><br><span class="line">dong zhen                               </span><br><span class="line">ni ni</span><br><span class="line">lai lai</span><br></pre></td></tr></table></figure><h4 id="10-3-awk-1"><a href="#10-3-awk-1" class="headerlink" title="10.3 awk"></a>10.3 awk</h4><p>awk 一个强大文件分析工具，把文件逐行的读入，以空格为默认分隔符将每行切片，切开的部分再进行分析处理。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk [选项参数] <span class="string">&#x27;pattern1 &#123;action1&#125; pattern2&#123;action2&#125;..&#x27;</span> filename</span><br></pre></td></tr></table></figure><ul><li>-F 指定输入文件分隔符</li><li>-v 赋值一个用户定义变量</li></ul><h4 id="10-4-sort-1"><a href="#10-4-sort-1" class="headerlink" title="10.4 sort"></a>10.4 sort</h4><p>sort 命令是在Linux里非常有用，它将文件进行排序，并将排序结果标准输出</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sort [选项] (参数)</span><br></pre></td></tr></table></figure><div class="table-container"><table><thead><tr><th style="text-align:center">参数</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">-n</td><td style="text-align:center">依照数值大小排序</td></tr><tr><td style="text-align:center">-r</td><td style="text-align:center">以相反的顺序排序</td></tr><tr><td style="text-align:center">-t</td><td style="text-align:center">设置排序时使用的分隔字符</td></tr><tr><td style="text-align:center">-k</td><td style="text-align:center">指定需要排序的列</td></tr></tbody></table></div>]]></content>
      
      
      <categories>
          
          <category> shell </category>
          
      </categories>
      
      
        <tags>
            
            <tag> shell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c++变量和基本类型</title>
      <link href="/2022/04/22/post1/"/>
      <url>/2022/04/22/post1/</url>
      
        <content type="html"><![CDATA[<blockquote><p>💛本文摘要💛</p><p><strong><code>c++  系列文章</code></strong></p><p><a href="https://blog.csdn.net/weixin_45043334/article/details/125380065">第2章 变量和基本类型</a><br><a href="https://blog.csdn.net/weixin_45043334/article/details/125402340">第3章 字符串、向量和数组</a><br><a href="https://blog.csdn.net/weixin_45043334/article/details/125449009">第4章 表达式</a><br><a href="https://blog.csdn.net/weixin_45043334/article/details/125647293">第5章 语句</a><br><a href="https://blog.csdn.net/weixin_45043334/article/details/125751253">第6章 函数</a><br><a href="https://blog.csdn.net/weixin_45043334/article/details/125850838">第8章 IO库</a><br><a href="https://blog.csdn.net/weixin_45043334/article/details/125947865">第9章 顺序容器</a><br><a href="https://blog.csdn.net/weixin_45043334/article/details/126002739">第10章 泛型算法</a><br><a href="https://blog.csdn.net/weixin_45043334/article/details/126246260">第11章 关联容器</a><br><a href="https://blog.csdn.net/weixin_45043334/article/details/126297355">第12章 动态内存</a><br><a href="https://blog.csdn.net/weixin_45043334/article/details/126394732">第13章 拷贝控制</a><br><a href="https://blog.csdn.net/weixin_45043334/article/details/126679427">第 14章 重载运算符</a><br><a href="https://blog.csdn.net/weixin_45043334/article/details/126728175?spm=1001.2014.3001.5502">第15章 面向对象程序设计</a><br><a href="https://blog.csdn.net/weixin_45043334/article/details/126808177">第 16章 模板与泛型编程</a></p></blockquote><h1 id="🍪第2章-变量和基本类型"><a href="#🍪第2章-变量和基本类型" class="headerlink" title="🍪第2章 变量和基本类型"></a>🍪第2章 变量和基本类型</h1><p>概述 c ++定义了几种基本的内置类型（如字符、整型、浮点数等），同时提供自动以数据类型的机制。</p><h2 id="🍮2-1-基本内置类型"><a href="#🍮2-1-基本内置类型" class="headerlink" title="🍮2.1 基本内置类型"></a>🍮2.1 基本内置类型</h2><p>基本内置类型包括算数类型和空类型。算数类型包括字符、整型数、浮点数和布尔值。</p><h3 id="🍭2-1-1-算术类型"><a href="#🍭2-1-1-算术类型" class="headerlink" title="🍭2.1.1 算术类型"></a>🍭2.1.1 算术类型</h3><div class="table-container"><table><thead><tr><th>类型</th><th>含义</th><th>最小尺寸</th></tr></thead><tbody><tr><td><code>bool</code></td><td>布尔类型</td><td>8bits</td></tr><tr><td><code>char</code></td><td>字符</td><td>8bits</td></tr><tr><td><code>wchar_t</code></td><td>宽字符</td><td>16bits</td></tr><tr><td><code>char16_t</code></td><td>Unicode字符</td><td>16bits</td></tr><tr><td><code>char32_t</code></td><td>Unicode字符</td><td>32bits</td></tr><tr><td><code>short</code></td><td>短整型</td><td>16bits</td></tr><tr><td><code>int</code></td><td>整型</td><td>16bits (在32位机器中是32bits)</td></tr><tr><td><code>long</code></td><td>长整型</td><td>32bits</td></tr><tr><td><code>long long</code></td><td>长整型</td><td>64bits （是在C++11中新定义的）</td></tr><tr><td><code>float</code></td><td>单精度浮点数</td><td>6位有效数字</td></tr><tr><td><code>double</code></td><td>双精度浮点数</td><td>10位有效数字</td></tr><tr><td><code>long double</code></td><td>扩展精度浮点数</td><td>10位有效数字</td></tr></tbody></table></div><p><strong>类型选择</strong></p><ol><li>当明确知道数值不为负时，选用无符号类型</li><li>在实际应用中，一般选用<code>int 类型</code>，如果大的话选用<code>long long</code>类型，一般short与 long不用</li><li>算术运算符，不要使用<code>char</code>和<code>bool</code>.因为char类型在一些机器上有符号，而到了另外机械就无符号。如果需要使用char，就指明是<code>signed char</code>或者<code>unsigned char</code></li><li>浮点数用<code>double</code>,因为float精度可能不够。long double没必要，消耗内存。<h3 id="🍭2-1-2-类型转换"><a href="#🍭2-1-2-类型转换" class="headerlink" title="🍭2.1.2 类型转换"></a>🍭2.1.2 类型转换</h3><strong>概述几种类型转换：</strong></li><li>非布尔值赋给布尔型，初始值为0则结果为false，否则为true。</li><li>浮点数转换为整数，结果<code>仅保留小数点前面的部分。</code></li><li>给无符号类型赋值时，如果超出它的表示范围，则<code>结果是初始值对无符号类型表示数值总数取模后的余数</code>,例如-1 赋给 8 位 unsigned char 的结果是 255。</li><li>给带符号类型赋值超出它的表达式，结果是<code>未定义</code>的，程序可能会崩掉<br>建议：尽量避免无法预知和依赖实际环境的行为</li></ol><p><strong>取模与取余区别：</strong><br><code>取余运算在取c值时，向0方向舍入，而取模运算在取c时，向负无穷方向舍入</code></p><ol><li>求整数商：c = [a / b]</li><li>计算模： r = a - c  * b;<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 举例 那题目当中的-1 举例</span><br><span class="line">-1 MOD 256</span><br><span class="line">第一步求商：</span><br><span class="line">c = [a / b] = -1 / 256 = -1 //结果为-0.0039,向负无穷取整为1</span><br><span class="line">第二步求模：</span><br><span class="line">r = a - c * b  =  (-1) - (-1) * 256  = 255</span><br><span class="line"></span><br><span class="line">//或者这样理解</span><br><span class="line"></span><br><span class="line">计算机在存储-1时是存储的-1的补码，对于8位unsigned char来说-1的原码为1000 0001，它的反码为（符号位不变，其他位置取反）1111 1110,则补码为（补码= 反码+1），1111 1111，换成十进制整数为255</span><br><span class="line"></span><br></pre></td></tr></table></figure><strong>含有无符号的整数</strong></li><li>一个表达式中既有无符号数又有int值时，int会被转换成无符号数。</li><li>无符号减无符号数，结果还是无符号数，如果是负值就等于取模后的值</li></ol><p><code>总结：无符号参与运算时，结果肯定不是负数，如果是负数则需要对结果取模</code></p><h3 id="🍭2-1-3-字面值常量"><a href="#🍭2-1-3-字面值常量" class="headerlink" title="🍭2.1.3 字面值常量"></a>🍭2.1.3 字面值常量</h3><p><strong>整型和浮点型字面值</strong><br><code>整型字面值中 0 开头的整数是 8 进制，0x 开头的整数是十六进制。</code></p><p>浮点型字面值可以用小数或科学计数法表示，科学计数法中的指数部分用 E 或 e 标识。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3.1415926</span>   <span class="number">0.</span>  <span class="number">0e0</span>  <span class="number">.001</span>  <span class="number">3.14159E2</span></span><br></pre></td></tr></table></figure><br><strong>字符和字符串字面值</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;c&#x27;</span>            字符字面值</span><br><span class="line"><span class="string">&quot;Hell world&quot;</span>   字符串字面值比实际值多<span class="number">1</span>，因为它的最后多一个<span class="string">&#x27;\0&#x27;</span>（空字符）</span><br><span class="line">               hello world被看做一个整体，只要字符串字面值位置仅有空格、缩进、换行符分隔，就看做一个整体</span><br></pre></td></tr></table></figure><br><strong>转义序列</strong></p><div class="table-container"><table><thead><tr><th>换行符：\n</th><th>横向制表符：\t</th><th>报警符：\a</th></tr></thead><tbody><tr><td>纵向制表符：\v</td><td>退格符：\b</td><td><strong>双引号：\“</strong></td></tr><tr><td><strong>反斜线：\\</strong></td><td><strong>单引号：\‘</strong></td><td><strong>问号：\?</strong></td></tr><tr><td>回车符：\r</td><td>进纸符：\f</td></tr></tbody></table></div><p><strong>布尔字面值和指针字面值</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">true</span> <span class="literal">false</span>    是布尔类型的字面值</span><br><span class="line">nullptr       是指针字面值</span><br></pre></td></tr></table></figure></p><h2 id="🍮2-2-变量"><a href="#🍮2-2-变量" class="headerlink" title="🍮2.2 变量"></a>🍮2.2 变量</h2><p>变量 ：提供一个具名的、可供程序操作的存储空间<br>对象  ：一块能存储数据并具有某种类型的内存<br><code>对于c++,而言变量和对象可以互换使用</code></p><h3 id="🍭2-2-1-变量的定义"><a href="#🍭2-2-1-变量的定义" class="headerlink" title="🍭2.2.1 变量的定义"></a>🍭2.2.1 变量的定义</h3><p><strong>初始化</strong></p><p>对象在创建的过程中就获得了一个值，此时这个对象被初始化。</p><p><code>初始化和赋值的区别：</code></p><ul><li>初始化不是赋值，初始化是创建一个变量时赋予其一个初始值</li><li>赋值是把对象的当前值擦除，而以一个新值来代替。</li></ul><p><strong>列表初始化</strong><br>用一对{ }来表示列表初始化<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">0</span>; </span><br><span class="line"><span class="type">int</span> i = &#123;<span class="number">0</span>&#125;; </span><br><span class="line"><span class="type">int</span> i &#123;<span class="number">0</span>&#125;; </span><br><span class="line"><span class="type">int</span> <span class="title function_">i</span> <span class="params">(<span class="number">0</span>)</span>;</span><br></pre></td></tr></table></figure><br><code>特点</code>:如果使用列表初始化，且初始值存在，丢失情况，则编译器会报错<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="type">double</span> ld = <span class="number">3.141592</span>；</span><br><span class="line"><span class="type">int</span> a&#123;ld&#125;；                <span class="comment">//错误，信息丢失，精度问题，转换失败</span></span><br><span class="line"><span class="type">int</span> c(ld), d=ld;           <span class="comment">//正确</span></span><br></pre></td></tr></table></figure></p><p><strong>默认初始化</strong></p><ul><li>定义在函数体内的内置类型的对象没有初始化，则其值为未定义。</li><li>定义在函数体外的内置类型的对象没有初始化，则其值为0（string为空，int型为0）</li></ul><p>全局变量没有初始化，系统会自动初始化为0，局部变量没有初始化，未定义，会报错。<br><code>建议初始化每一个内置类型的变量。</code></p><h3 id="🍭2-2-2-变量声明和定义"><a href="#🍭2-2-2-变量声明和定义" class="headerlink" title="🍭2.2.2 变量声明和定义"></a>🍭2.2.2 变量声明和定义</h3><p>声明：使得名字让程序知道     (不申请存储空间)<br>定义：创建与名字关联的实体（也就是初始化，需要申请存储空间）</p><p><code>要声明一个变量加 extern，声明变量不能赋值。</code><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">int</span> i;     <span class="comment">// 声明 i</span></span><br><span class="line"><span class="type">int</span> j;            <span class="comment">// 声明并定义j；</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> i = <span class="number">1</span>; <span class="comment">// 定义 i，初始化抵消了 extern 的作用。</span></span><br></pre></td></tr></table></figure><br>变量能且只能被定义一次，但是可以被多次声明<br><code>c++是静态类型语言，其含义是在编译阶段检查类型。</code></p><h3 id="🍭2-2-3-标识符"><a href="#🍭2-2-3-标识符" class="headerlink" title="🍭2.2.3 标识符"></a>🍭2.2.3 标识符</h3><p><code>标识符组成：字母、数字、下划线。不能以数字开头，对大小写敏感。标识符的长度没有限制。</code></p><p>变量命名规范：</p><ul><li>标识符要体现其实际含义。</li><li>变量名一般用小写字母，index,不要使用Index或INDEX</li><li>用户自定义的类型一般以大写字母开头。Sales_item</li><li>包含多个单词的标识符，使用驼峰命名法或使用下划线连接不同单词。</li><li>对于嵌套作用域，可以在内层作用域中重新定义外层作用域已有的名字，但是最好不要这样做。<h3 id="🍭2-2-4-名字作用域"><a href="#🍭2-2-4-名字作用域" class="headerlink" title="🍭2.2.4 名字作用域"></a>🍭2.2.4 名字作用域</h3></li><li>第一次使用变量时再定义它。</li><li>嵌套作用域，作用域一旦声明了，那么它所嵌套的所有作用域中都能访问该名字，允许在内层作用域中重新定义外层已有的作用域</li></ul><p><code>实际就是：局部变量覆盖全局变量</code></p><h2 id="🍮2-3-复合类型"><a href="#🍮2-3-复合类型" class="headerlink" title="🍮2.3 复合类型"></a>🍮2.3 复合类型</h2><p>复合类型是基于其他类型定义的类型，例如<code>指针和引用</code></p><h3 id="🍭2-3-1-引用"><a href="#🍭2-3-1-引用" class="headerlink" title="🍭2.3.1 引用"></a>🍭2.3.1 引用</h3><p><code>引用就是给对象起别名</code></p><p><strong>引用的本质就是指针常量，指针常量就是指针所指对象的值可以变，但是指针所指的对象不可以变，因此他和一个对象绑定好后，通过引用来改变值，但是不可以在重新绑定到另一个对象上</strong></p><p><strong>引用总结</strong></p><ul><li><code>引用必须初始化</code></li><li><code>引用的初始值必须是一个对象，不能是字面值，如果想要是字面值需要加const</code></li><li><code>引用不是对象，所以不能定义引用的引用，也不能定义引用的指针</code></li><li>对引用的所有操作都对与之绑定的对象的操作</li><li><code>引用必须绑定一个对象上，且不能重新绑定到另一个对象上</code></li><li>引用的类型与绑定的类型要匹配</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">0</span>；</span><br><span class="line"><span class="type">int</span> &amp;r = i;</span><br></pre></td></tr></table></figure><h3 id="🍭2-3-2-指针"><a href="#🍭2-3-2-指针" class="headerlink" title="🍭2.3.2 指针"></a>🍭2.3.2 指针</h3><p><code>在块作用域内，指针如果没有被初始化，值将不确定。</code><br>指针类型被用于指定它所指向的对象的类型，二者要匹配<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="type">double</span> *dp = &amp;i;   <span class="comment">// 错误</span></span><br><span class="line"><span class="type">int</span> *ip = i;       <span class="comment">// 错误，但 int *ip = 0; 是正确的</span></span><br><span class="line"><span class="type">int</span> *p = &amp;i;       <span class="comment">//正确</span></span><br></pre></td></tr></table></figure><br><strong><code>指针与引用区别</code></strong></p><ul><li>指针是一个对象而引用不是</li><li>指针可以重定向，引用不可以；</li><li>有指向指针的指针，没有指向引用的引用；</li><li>指针不需要在定义时赋初值而引用需要。</li><li>不能定义指向引用的指针。可以定义指向指针的引用。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *p; </span><br><span class="line"><span class="type">int</span>* &amp;r = p;      <span class="comment">// r是对指针p的引用（指针的引用）</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> &amp;r = i;</span><br><span class="line"><span class="type">int</span>&amp; *p = &amp;r      <span class="comment">//指向引用的指针，错误的，因为r不是对象，没有地址。</span></span><br></pre></td></tr></table></figure><p>利用解引用符（<em>）可以访问指针指向的对象。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">42</span>;</span><br><span class="line"><span class="type">int</span> *p = &amp;i;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *p &lt;&lt;<span class="built_in">endl</span>;  结果为<span class="number">42</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><br><em>*空指针</em></em><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *p = nullptr; <span class="comment">// 推荐这种</span></span><br><span class="line"><span class="type">int</span> *p = <span class="number">0</span>; </span><br><span class="line"><span class="type">int</span> *p = <span class="literal">NULL</span>;    <span class="comment">// NULL 是在头文件 cstdlib 中定义的预处理变量，值为 0。</span></span><br></pre></td></tr></table></figure><br><code>建议初始化所有指针</code></p><p><strong>赋值和指针</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">42</span>;</span><br><span class="line"><span class="type">int</span>  *p = &amp;i;</span><br><span class="line">*p = <span class="number">30</span>;</span><br></pre></td></tr></table></figure><br>说明：</p><ul><li>指针所指的对象变了（i 的值变了）</li><li>指针本身并没有变化 （i 的地址没变），<code>指针指的是地址，而不是值</code></li></ul><p><strong>void*指针</strong><br>void* 指针是特殊的指针类型，可以存放任意对象的地址。它的用处比较有限。(不使用)</p><h3 id="🍭2-3-3-理解复合类型的声明"><a href="#🍭2-3-3-理解复合类型的声明" class="headerlink" title="🍭2.3.3 理解复合类型的声明"></a>🍭2.3.3 理解复合类型的声明</h3><p>一条声明语句是由一个基本数据类型和后面的声明符列表组成的。</p><p>引用符 &amp; 和指针符 <em> 都是类型说明符，类型说明符是声明符的一部分。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">1024</span>, *p = &amp;i, &amp;r = i;</span><br><span class="line"><span class="type">int</span> *p, p2;   <span class="comment">//p是指向int的指针，p2是int</span></span><br></pre></td></tr></table></figure><br><em>*指向指针的指针</em></em><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i  = <span class="number">1024</span>;</span><br><span class="line"><span class="type">int</span> *p = &amp;i;      <span class="comment">//p指向一个int 型数</span></span><br><span class="line"><span class="type">int</span> **p1 = &amp;p;    <span class="comment">//p1指向一个int 型指针</span></span><br></pre></td></tr></table></figure><br><img src="https://img-blog.csdnimg.cn/9910119c45a6472a87272c28931eaab0.png" alt="在这里插入图片描述"></p><p><strong>指向指针的引用</strong></p><p><code>引用本身不是一个对象，所以没有指向引用的指针,但是指针是对象，存在对指针的引用</code><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i =  <span class="number">42</span>;</span><br><span class="line"><span class="type">int</span> *p ;       <span class="comment">//p是int型指针</span></span><br><span class="line"><span class="type">int</span> *&amp;r = p;  <span class="comment">//指向指针的引用</span></span><br><span class="line"></span><br><span class="line">-------------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> &amp;r = i;</span><br><span class="line"><span class="type">int</span>&amp; *p = &amp;r      <span class="comment">//指向引用的指针，错误的，因为r不是对象，没有地址。</span></span><br></pre></td></tr></table></figure><br>想要理解r的类型到底是什么，可以<code>从右往左读</code>，离变量最近的符号（本例中是&amp;r符号）<code>，因此r是一个</code>引用<code>，声明符以外的部分可以确定</code>r引用的类型<code>是什么。本例中</code>&amp;左边是*<code>，所以r引用的是一个</code>指针`</p><h2 id="🍮2-4-const限定符"><a href="#🍮2-4-const限定符" class="headerlink" title="🍮2.4 const限定符"></a>🍮2.4 const限定符</h2><ul><li><code>const对象必须初始化</code>，因为const对象一旦创建，其值不能改变</li><li>const指向的对象，不能改变，但是仍然可以和int一样，进行<code>运算</code></li><li>默认情况下，const对象<code>只在文件内有效</code></li><li>如果想要在不同文件中<code>共享const</code>，必须在定义变量之前添加<code>exten关键字</code></li></ul><h3 id="🍭2-4-1-const的引用"><a href="#🍭2-4-1-const的引用" class="headerlink" title="🍭2.4.1 const的引用"></a>🍭2.4.1 const的引用</h3><ul><li><code>引用必须初始化</code>，因此常量引用也必须初始化。</li><li>常量引用是对 const 的引用，对象可以是<code>常量</code>也可以是<code>非常量</code></li><li>不能用非常量引用指向一个常量对象。可以用常量引用指向一个非常量对象。</li><li>引用的类型必须与其所引用对象的类型一致，<code>有俩种情况特殊，下面详细说</code></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">42</span>;           <span class="comment">//非常量</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> j  = <span class="number">42</span>;    <span class="comment">//常量</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;p  = i;   <span class="comment">//正确</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;p  = j;   <span class="comment">//正确,常量引用的对象既可以是常量也可以是非常量 </span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;p =  <span class="number">10</span>;  <span class="comment">//正确</span></span><br><span class="line"><span class="type">int</span> &amp;p = <span class="number">10</span>;         <span class="comment">//错误      </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//非常量引用不能指向常量对象</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> p = <span class="number">66</span>;</span><br><span class="line"><span class="type">int</span> &amp;r = p;         <span class="comment">//错误</span></span><br></pre></td></tr></table></figure><p><strong>引用的类型必须与其所引用对象的类型一致，<code>有俩种情况特殊，下面详细说</code></strong></p><ol><li>初始化常量引用时允许用任意表达式作为初始值（包括常量表达式），只要该表达式结果可以转换为引用的类型。</li><li>当用常量引用绑定一个非常量对象时，不能通过引用改变引用对象的值，但是可以通过其他方式改变值。常量指针也一样。</li></ol><p><strong>举例</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> val = <span class="number">3.1415</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;p = val;   <span class="comment">//正确</span></span><br></pre></td></tr></table></figure><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i  =<span class="number">42</span>;</span><br><span class="line"><span class="type">int</span> &amp;r1 = i;         <span class="comment">//引用r1绑定对象i</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;r2 = i;  <span class="comment">//常量引用r2 绑定i,此时不允许通过r2来修改i的值，但是可以用r1来修改i 的值</span></span><br><span class="line"></span><br><span class="line">r1 = <span class="number">0</span>;     <span class="comment">//正确，i 的值修改为0</span></span><br><span class="line">r2 = <span class="number">0</span>;    <span class="comment">//错误</span></span><br></pre></td></tr></table></figure></p><h3 id="🍭2-4-2-指针和const"><a href="#🍭2-4-2-指针和const" class="headerlink" title="🍭2.4.2 指针和const"></a>🍭2.4.2 指针和const</h3><ul><li>指向常量的指针和指向常量的引用用法相似，既可以指向常量，也可以指向非常量，如果指向非常量，那莫这个非常量对象的值不可以不可以通过指针，来改变，可以通过其他途径改变。</li></ul><p><strong>指针常量与常量指针区别</strong></p><ul><li>指针常量：指针所指的对象值<code>可以变</code>，但是指针所指的<code>地址不可以变</code>    int * const p = &amp;r</li><li>常量指针：指针所指的对象的值<code>不可以变</code>，但是指针所指的<code>地址可以变</code> const int * p = &amp;r</li></ul><h3 id="🍭2-4-3-顶层const"><a href="#🍭2-4-3-顶层const" class="headerlink" title="🍭2.4.3 顶层const"></a>🍭2.4.3 顶层const</h3><ul><li><code>顶层const表示指针常量</code>，指针本身是一个常量，地址不能变，但是值可以修改。</li><li><code>底层const表示常量指针</code>， 指针所指的值是一个常量，不可以修改，但是地址可以变。</li><li>顶层const的指针，表示该指针是const对象，因此必须初始化，而底层const不需要初始化。</li><li><code>顶层const对任意数据类型都适用，但是底层const只用于引用和指针</code></li></ul><p><strong>指针类型既可以是顶层 const 也可以是底层 const，因为引用只能是底层 const，常量引用为底层 const，不存在顶层 const 的引用。</strong><br><br/><br><strong>怎么区分是顶层const还是底层const,最简单的方法</strong></p><ul><li>对于指针和引用来说，顶层const在右边，底层const在左边。对于其他类型来说，全部都是顶层cosnt.(<code>记住就能理解了</code>)<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span>* <span class="type">const</span> p1 = p2; <span class="comment">// 从右向左读，右侧const是顶层const，表明p3是一个常量，左侧const是底层const，表明指针所指的对象是一个常量</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span>* p3 = &amp;c;       <span class="comment">// 这是一个底层const，允许改变 p2 的值（常量指针）----const在左边为底层</span></span><br><span class="line"><span class="type">int</span>* <span class="type">const</span> p4 = &amp;i;       <span class="comment">// 这是一个顶层const，不能改变 p1 的值（指针常量）----cosnt在右边为顶层</span></span><br></pre></td></tr></table></figure></li></ul><p>执行对象的拷贝操作时，不能将底层 const 拷贝给非常量，反之可以，非常量将会转化为常量。</p><h3 id="🍭2-4-4-constexpr和常量表达式"><a href="#🍭2-4-4-constexpr和常量表达式" class="headerlink" title="🍭2.4.4 constexpr和常量表达式"></a>🍭2.4.4 constexpr和常量表达式</h3><p><code>常量表达式是指值不会改变并且在编译过程就能得到计算结果的表达式。</code><br><code>字面值属于常量表达式，由常量表达式初始化的 const 对象也是常量表达式。</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> i = <span class="number">32</span>              <span class="comment">//常量表达式</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> j = i + <span class="number">1</span>           <span class="comment">// 常量表达式</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> sum = get_size()    <span class="comment">//不是常量表达式，尽管 sum 是常量，但它的具体值等到运行时才知道。</span></span><br></pre></td></tr></table></figure><p><strong>constexpr变量</strong></p><ul><li>在一个复杂的系统中，很难分辨一个初始值到底是不是常量表达式，此时通过把变量声明为<code>constexpr</code>类型，使得编译器自动帮我们验证。</li><li><code>由 constexpr 声明的变量一定是常量不能是普通函数，必须用常量表达式初始化。</code></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">constexpr <span class="type">int</span> sz = size(); <span class="comment">//只有当 size() 是一个 constexpr 函数时这才是一条正确的声明语句。</span></span><br><span class="line">constexpr <span class="type">int</span> mf = <span class="number">20</span>;     <span class="comment">//常量表达式</span></span><br><span class="line">constexpr <span class="type">int</span> limit = mf + <span class="number">1</span>;   <span class="comment">// mf + 1是常量表达式</span></span><br></pre></td></tr></table></figure><p><strong>字面值类型</strong></p><ul><li>算术类型、引用、指针都属于字面值类型，自定义类则不属于。</li><li>cosntexpr 指针的初始值必须是<code>nullptr 或 0 或存储于固定地址的对象</code>。</li><li>函数体之外的对象和静态变量的地址都是固定不变的.,可以用constexpr初始化，而函数体内的变量不能用contexpr.</li></ul><p><strong>指针和constexpr</strong></p><p><code>contexpr所定义的对象都是顶层const</code>，仅对指针有效<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> *p = nullptr;     <span class="comment">// p 是一个指向整型常量的指针(指针常量)底层const</span></span><br><span class="line">constexpr <span class="type">int</span> *q = nullptr; <span class="comment">// q 是一个指向整数的常量指针(常量指针)定义成了顶层const</span></span><br></pre></td></tr></table></figure></p><p><strong>const与constexpr区别</strong></p><ul><li>constexpr限定了变量是编译器常量，即变量在编译过程中就可以得到结果。</li><li>const 未区分是编译器常量还是运行期常量。即 const 变量可以在运行期间初始化，只不过是初始化后的值就不能再改变了。</li><li>constexpr 变量是真正的“常量”，而 const 现在一般只用来表示 “只读”。</li></ul><h2 id="🍮2-5-处理类型"><a href="#🍮2-5-处理类型" class="headerlink" title="🍮2.5 处理类型"></a>🍮2.5 处理类型</h2><h3 id="🍭2-5-1-类型别名"><a href="#🍭2-5-1-类型别名" class="headerlink" title="🍭2.5.1 类型别名"></a>🍭2.5.1 类型别名</h3><p>目前有俩种方法来定义类型别名</p><ul><li>typedef</li><li>using<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> wages;  <span class="comment">// 使用 typedef 关键字</span></span><br><span class="line">using wages = <span class="type">int</span>;  <span class="comment">// 使用 using 关键字进行别名声明</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> wages base, *p; <span class="comment">// base 是 double 的别名，p 是 double* 的别名。</span></span><br></pre></td></tr></table></figure></li></ul><p><strong>指针、常量和类型别名</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">char</span>* pstring; </span><br><span class="line"><span class="type">const</span> pstring cstr = <span class="number">0</span>; <span class="comment">// 注意：const 是一个指向 char 的常量指针。不能采用直接替换的方式将其理解为 const char* cstr = 0，这是错误的。</span></span><br></pre></td></tr></table></figure></p><h3 id="🍭2-5-2-auto类型说明符"><a href="#🍭2-5-2-auto类型说明符" class="headerlink" title="🍭2.5.2 auto类型说明符"></a>🍭2.5.2 auto类型说明符</h3><ul><li>auto让编译器自动帮你识别，表达式所属的类型</li><li>但是与int 不同的是，auto让编译器通过初始值来推算变量的类型，所以<code>auto 必须要有初始值</code></li><li>auto 可以在一条语句中声明多个变量，但是多个变量必须是同一个基本数据类型（整型与整型指针和整型引用算一个类型）。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> vall, sum;</span><br><span class="line"><span class="keyword">auto</span> item = vall + sum  <span class="comment">//自动推断为int类型</span></span><br></pre></td></tr></table></figure><p><strong>复合类型、常量和auto</strong></p><p><strong>编译器推断出的 auto 类型有时和初始值并不一样，编译器会进行适当的调整：</strong></p><ul><li>auto 根据引用来推断类型时会以引用对象的类型作为 auto 的类型。</li><li>auto 一般会忽略掉顶层 const，因此对于非指针类型的常量对象，auto 推断出的结果是不含 const 的。如果希望 auto 是一个顶层 const，需要明确指出。</li><li>auto 会保留底层 const。</li></ul><p><code>概括一下就是 auto 会忽略引用与顶层 const。</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> ci = <span class="number">1</span>, cr = ci;</span><br><span class="line"><span class="keyword">auto</span> b = ci;       <span class="comment">// b 是一个普通的 int。</span></span><br><span class="line"><span class="keyword">auto</span> c = cr;       <span class="comment">// c 是一个普通的 int。</span></span><br><span class="line"><span class="type">const</span> <span class="keyword">auto</span> d = ci; <span class="comment">// d 是一个 const int</span></span><br><span class="line"><span class="keyword">auto</span> &amp;e = ci;      <span class="comment">// e 是一个常量引用（常量引用是底层 const）。注意这个微妙的地方。</span></span><br><span class="line"><span class="keyword">auto</span> f = &amp;ci;      <span class="comment">// f 是一个 const int*（位于左边的 const 是底层 const）</span></span><br></pre></td></tr></table></figure><p>int 与 int *、int &amp; 是一个基本数据类型，而 const int 与 int 不是一种类型。<br>用 auto 定义引用时，必须用 &amp; 指明要定义的是引用。</p><h3 id="🍭2-5-3-decltype类型指示符"><a href="#🍭2-5-3-decltype类型指示符" class="headerlink" title="🍭2.5.3 decltype类型指示符"></a>🍭2.5.3 decltype类型指示符</h3><ul><li>希望从表达式的类型推断出要定义的变量的类型。但是不需要进行初始化时，可以使用decltype。</li><li>如果如果 decltype 使用的表达式是一个变量，则它返回<code>该变量的类型（包括顶层 const 和引用在内）。</code></li><li>decltype与auto不同，decltype不会忽略引用和顶层const</li><li>引用从来都是作为对象的别名出现，只有在 decltype 处是例外。</li></ul><p><code>当获得的对象类型是引用时，必须初始化</code><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> ci = <span class="number">0</span>, &amp;cj = ci;</span><br><span class="line">decltype(ci) x = <span class="number">0</span>;  <span class="comment">// x 的类型是 const int</span></span><br><span class="line">decltype(cj) y = x;  <span class="comment">// y 的类型是 const int&amp;</span></span><br><span class="line">decltype(cj) z;      <span class="comment">//错误 z 是一个引用，必须初始化</span></span><br></pre></td></tr></table></figure></p><p><strong>decltype和引用</strong></p><ul><li>如果decltype使用的表达式不是一个变量，则decltype返回表达式结果对应的类型</li><li>如果表达式的内容是解引用操作，那么decltype将得到引用类型</li><li>decltype((variable))—-双层括号的结果永远是引用<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">6</span>, &amp;r = i, *p;</span><br><span class="line">decltype(r+<span class="number">0</span>) b;      <span class="comment">// b 的类型是 int，因为 r+0 的结果类型是 int。</span></span><br><span class="line">decltype(*p) c = i;   <span class="comment">// c 的类型是 int&amp;。</span></span><br><span class="line">decltype((i)) d = i;  <span class="comment">// d 的类型是 int&amp;。</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="🍮2-6-自定义数据结构"><a href="#🍮2-6-自定义数据结构" class="headerlink" title="🍮2.6 自定义数据结构"></a>🍮2.6 自定义数据结构</h2><h3 id="🍭2-6-1-定义Sales-data类型"><a href="#🍭2-6-1-定义Sales-data类型" class="headerlink" title="🍭2.6.1 定义Sales_data类型"></a>🍭2.6.1 定义Sales_data类型</h3><p><code>struct+类名+类体+分号。类体可以为空。</code><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Sales_data</span>&#123;</span>&#125;;      <span class="comment">//结尾注意有分号</span></span><br><span class="line"></span><br><span class="line">对象定义有俩种方式</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Sales_data</span>&#123;</span>&#125; students;   <span class="comment">//方式1</span></span><br><span class="line">Sales_data students;            <span class="comment">//方式2</span></span><br></pre></td></tr></table></figure></p><p><code>定义类时可以给数据成员提供类内初始值以进行初始化。没有类内初始值的成员则被默认初始化。</code><br><code>类内初始值可以放在花括号中或等号的右边，不能使用圆括号。</code></p><h3 id="🍭2-6-2-使用Sales-data类（没东西，暂时省略hhh）"><a href="#🍭2-6-2-使用Sales-data类（没东西，暂时省略hhh）" class="headerlink" title="🍭2.6.2 使用Sales_data类（没东西，暂时省略hhh）"></a>🍭2.6.2 使用Sales_data类（没东西，暂时省略hhh）</h3><h3 id="🍭2-6-3-编写自己的头文件"><a href="#🍭2-6-3-编写自己的头文件" class="headerlink" title="🍭2.6.3 编写自己的头文件"></a>🍭2.6.3 编写自己的头文件</h3><ul><li>类通常定义在头文件中，类所在头文件的名字应与类的名字一样。</li><li>头文件通常定义那些只能被定义一次的实体，比如类、const、constexpr 等。</li><li>头文件一旦改变，相关的源文件必须重新编译以获取更新过的声明。</li></ul><p><strong>预处理器概述</strong></p><p>确保头文件多次包含仍能安全工作的常用技术是预处理器。</p><p><code>预处理变量有两种状态：已定义和未定义。一般把预处理变量的名字全部大写。</code></p><p><code>整个程序中的预处理变量包括头文件保护符必须唯一，通常基于头文件中类的名字来构建保护符的名字，以确保其唯一性。</code></p><p>c++ 中包含三个头文件保护符：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- <span class="meta">#<span class="keyword">define</span>：把一个名字设定为预处理变量`</span></span><br><span class="line">- <span class="meta">#<span class="keyword">ifdef</span>  :当且仅当变量已定义时为真。`</span></span><br><span class="line">- <span class="meta">#<span class="keyword">ifndef</span>：当且仅当变量已定义时为真，一旦检查结果为真，则执行后续操作直到遇到 #<span class="keyword">endif</span> 为止</span></span><br><span class="line">- <span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><br>预处理变量无视作用域的规则，作用范围是文件内</p>]]></content>
      
      
      <categories>
          
          <category> c++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
