<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>MVCC-多版本并发控制技术</title>
      <link href="/2022/05/15/post12/"/>
      <url>/2022/05/15/post12/</url>
      
        <content type="html"><![CDATA[<h2 id="快照读与当前读"><a href="#快照读与当前读" class="headerlink" title="快照读与当前读"></a>快照读与当前读</h2><p><code>快照读（普通select语句）通过MVCC方式解决幻读</code></p><ul><li>MVCC在MySQL InnoDB中的实现主要是为了提高数据库并发性能，用更好的方式去处理 <code>读-写冲突</code> ，做到即使有读写冲突时，也能做到 <code>不加锁 ， 非阻塞并发读</code> ，而这个读指的就是 <code>快照读（属于乐观锁）</code> , 而非 当前读 。</li></ul><p><code>当前读（select...for update等语句）通过next-key lock(记录锁+间隙锁)</code></p><ul><li><code>当前读</code>实际上是一种加锁的操作，是悲观锁的实现。而MVCC本质是采用乐观锁思想的一种方式。</li><li>当前读读取的是记录的<code>最新版本</code>（最新数据，而不是历史版本的数据），读取时还要保证其他并发事务不能修改当前记录，会对读取的记录进行加锁</li></ul><h2 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h2><p><strong>MySQL通过MVCC解决幻读，MVCC多版本并发控制结束，多版本通过<code>undolog</code>实现，管理通过<code>ReadView</code>实现</strong></p><ul><li>事务有四个隔离级别，可能存在三种并发问题：</li></ul><p><img src="https://img-blog.csdnimg.cn/6d1bc7e23fc74916b6dcaa34aefb5bbe.png" alt="在这里插入图片描述"></p><ul><li>但是在MySQL中，默认的隔离级别是可重复读，可以解决<code>脏读和不可重复读</code>，如果从定义来看，它不能解决幻读，只能采取<code>可串行化</code></li><li>但是MVCC可以不采用锁机制，而是通过<code>乐观锁</code>方式解决幻读，所以MySQL在可重复读也解决了幻读问题。<br><img src="https://img-blog.csdnimg.cn/dc5308e102424de89c127b78ce212f12.png" alt="在这里插入图片描述"></li></ul><h2 id="这四种隔离级别具体是如何实现的呢？"><a href="#这四种隔离级别具体是如何实现的呢？" class="headerlink" title="这四种隔离级别具体是如何实现的呢？"></a>这四种隔离级别具体是如何实现的呢？</h2><ul><li>对于「读未提交」隔离级别的事务来说，因为可以读到未提交事务修改的数据，所以直接读取最新的数据就好了；</li><li>对于「串行化」隔离级别的事务来说，通过加读写锁的方式来避免并行访问；</li><li><code>对于「读提交」和「可重复读」隔离级别的事务来说，它们是通过 Read View 来实现的，它们的区别在于创建 Read View 的时机不同，大家可以把 Read View 理解成一个数据快照，就像相机拍照那样，定格某一时刻的风景。「读提交」隔离级别是在「每个语句执行前」都会重新生成一个 Read View，而「可重复读」隔离级别是「启动事务时」生成一个 Read View，然后整个事务期间都在用这个 Read View。</code></li></ul><blockquote><p>注意，执行「开始事务」命令，并不意味着启动了事务。在 MySQL 有两种开启事务的命令，分别是：</p><ul><li>第一种：<code>begin/start transaction</code> 命令；</li><li>第二种：<code>start transaction with consistent snapshot</code> 命令；</li></ul><p>这两种开启事务的命令，事务的启动时机是不同的：</p><ul><li>执行了 begin/start transaction 命令后，并不代表事务启动了。只有在执行这个命令后，执行了增删查改操作的 SQL 语句，才是事务真正启动的时机；</li><li>执行了 start transaction with consistent snapshot 命令，就会马上启动事务。</li></ul></blockquote><p><code>总结</code>:</p><ul><li>MVCC读的是<code>快照</code>，也就是<code>乐观锁</code>的实现方式，幻读不会出现，相当于解决了幻读，但是并不是编程串行化了，串行化读是通过加锁，一个一个的进行解决。</li></ul><h2 id="隐藏字段、Undo-log版本链"><a href="#隐藏字段、Undo-log版本链" class="headerlink" title="隐藏字段、Undo log版本链"></a>隐藏字段、Undo log版本链</h2><ul><li>针对每一条记录（行格式），有三个隐藏字段<ul><li><code>UUID</code>：如果没有主键也没有唯一性索引，默认提供一个UUID隐藏字段</li><li><code>trx_id</code>:记录最近一个更新事务的ID(当一个事务对某条聚簇索引记录进行改动时，就会把该事务的事务 id 记录在 trx_id 隐藏列里)</li><li><code>roll_pointer</code>:回滚指针，是通过和undo log日志，旧版本写入到undo日志中，旧版本通过链表指针相连接，roll_point指向最近的undo log记录<br><img src="https://img-blog.csdnimg.cn/47a060ce0f284ff0b450c979c0d4e70b.png" alt="在这里插入图片描述"><h2 id="ReadView"><a href="#ReadView" class="headerlink" title="ReadView"></a>ReadView</h2></li></ul></li><li>使用 <code>READ COMMITTED</code> 和 <code>REPEATABLE READ</code> 隔离级别的事务，都必须保证读到 <code>已经提交了的</code> 事务修改过的记录。假如另一个事务已经修改了记录但是尚未提交，是不能直接读取最新版本的记录的</li><li><code>核心问题就是需要判断一下版本链中的哪个版本是当前事务可见的，这是ReadView要解决的主要问题</code></li></ul><blockquote><ol><li><code>creator_trx_id</code>，创建这个 Read View 的事务 ID。</li><li><code>m_ids</code>，表示在生成ReadView时当前系统中「活跃且未提交」的 <code>事务id列表</code>。<code>(“活跃事务”指的就是，启动了但还没提交的事务。)</code></li><li><code>min_trx_id</code> ，创建 Read View 时，当前数据库中「活跃事务且未提交的」事务中最小事务的事务 id </li><li><code>max_trx_id</code> ，表示生成ReadView时系统中应该分配给下一个事务的 id 值。max_trx_id 是系统最大的事务id值，这里要注意是系统中的事务id，需要区别于正在活跃的事务ID。<br><img src="https://img-blog.csdnimg.cn/614dd079bb0b4c90a14d347b3eb5f72a.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/99d5dcbf590745e79358cdaf1caf4173.png" alt="在这里插入图片描述"></li></ol></blockquote><p><img src="https://img-blog.csdnimg.cn/84591f35ecdc40ce9375f45294feed0d.png" alt="在这里插入图片描述"></p><h2 id="MVCC整体操作流程-如何解决幻读-重点"><a href="#MVCC整体操作流程-如何解决幻读-重点" class="headerlink" title="MVCC整体操作流程/如何解决幻读(重点)"></a>MVCC整体操作流程/如何解决幻读(<code>重点</code>)</h2><ol><li>首先获取事务自己的版本号，也就是事务 ID；</li><li>获取 ReadView；(在第一个查询语句后，会创建一个Read View后续的查询语句利用这个 Read View)</li><li>查询得到的数据，然后与 ReadView 中的事务版本号进行比较；</li><li>如果不符合 ReadView 规则，就需要从 Undo Log 中获取历史快照；</li><li>最后返回符合规则的数据。</li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>MVCC 在 <code>READ COMMITTD</code> 、 <code>REPEATABLE READ</code>这俩个隔离级别才有效，因为这俩个情况下考虑快照（读旧数据），而剩下的读为提交和串行化，读的都是最新数据</li><li>核心点在于 <code>ReadView</code> 的原理， <code>READ COMMITTD</code> 、 <code>REPEATABLE READ</code> 这两个隔离级别的一个很大不同<br>就是生成<code>ReadView</code>的时机不同：<ul><li><code>READ COMMITTD</code>在每一次进行普通<code>SELECT</code>操作前都会生成一个ReadView</li><li><code>REPEATABLE READ</code>只在第一次进行普通<code>SELECT</code>操作前生成一个<code>ReadView</code>，之后的查询操作都重复<br>使用这个<code>ReadView</code>就好了。</li></ul></li></ol><p><img src="https://img-blog.csdnimg.cn/6e2994154c2740bea20a1092e309dffd.png" alt="在这里插入图片描述"></p><h2 id="当前读是如何避免幻读的？"><a href="#当前读是如何避免幻读的？" class="headerlink" title="当前读是如何避免幻读的？"></a>当前读是如何避免幻读的？</h2><ul><li>MySQL 里除了普通查询是快照读，其他都是当前读，比如 update、insert、delete，这些语句执行前都会查询最新版本的数据，然后再做进一步的操作。</li><li>假设你要 update 一个记录，另一个事务已经 delete 这条记录并且提交事务了，这样不是会产生冲突吗，所以 update 的时候肯定要知道最新的数据。</li><li><code>使用间隙锁，对范围加锁使得插入或者删除或者更新无法操作</code></li></ul><p><img src="https://img-blog.csdnimg.cn/8f46c7b63a0a4b5e81e98b7856403f15.png" alt="在这里插入图片描述"></p><h2 id="幻读没有被完全解决？"><a href="#幻读没有被完全解决？" class="headerlink" title="幻读没有被完全解决？"></a>幻读没有被完全解决？</h2><p><code>场景一：</code></p><ul><li>在可重复读隔离级别下，事务 A 第一次执行普通的 select 语句时生成了一个 ReadView，之后事务 B 向表中新插入了一条 id = 5 的记录并提交。接着，事务 A 对 id = 5 这条记录进行了更新操作，在这个时刻，这条新记录的 trx_id 隐藏列的值就变成了事务 A 的事务 id，之后事务 A 再使用普通 select 语句去查询这条记录时就可以看到这条记录了，于是就发生了幻读。</li></ul><p><code>场景二：</code></p><ul><li>T1 时刻：事务 A 先执行「快照读语句」：select * from t_test where id &gt; 100 得到了 3 条记录。</li><li>T2 时刻：事务 B 往插入一个 id= 200 的记录并提交；</li><li>T3 时刻：事务 A 再执行「当前读语句」 select * from t_test where id &gt; 100 for update 就会得到 4 条记录，此时也发生了幻读现象。</li></ul><p>要避免这类特殊场景下发生幻读的现象的话，就是尽量在开启事务之后，马上执行 select … for update 这类当前读的语句，因为它会对记录加 next-key lock，从而避免其他事务插入一条新记录。</p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL 锁</title>
      <link href="/2022/05/10/post11/"/>
      <url>/2022/05/10/post11/</url>
      
        <content type="html"><![CDATA[<h1 id="1-锁的种类"><a href="#1-锁的种类" class="headerlink" title="1.锁的种类"></a>1.锁的种类</h1><ul><li>根据加锁的范围，可以分为<code>全局锁、表级锁和行锁</code>三类。<br><img src="https://img-blog.csdnimg.cn/8f0411f37f7f403da7ca7b91c3e87b29.png" alt="在这里插入图片描述"><h2 id="全局锁"><a href="#全局锁" class="headerlink" title="全局锁"></a>全局锁</h2></li><li><p>全局锁主要应用于做<code>全库逻辑备份</code>。这样在备份数据库期间，不会因为数据或表结构的更新，而出现备份文件的数据与预期的不一样。</p></li><li><p>缺点：</p><ul><li><p>整个数据库都是只读状态。 会造成业务停滞。</p></li><li><p>解决办法</p><ul><li>如果数据库的引擎支持的事务支持可重复读的隔离级别，那么在备份数据库之前先开启事务，会先创建 Read View，然后整个事务执行期间都在用这个 Read View，而且由于 MVCC 的支持，备份期间业务依然可以对数据进行更新操作。</li></ul></li></ul></li></ul><h1 id="2-表级锁"><a href="#2-表级锁" class="headerlink" title="2.表级锁"></a>2.表级锁</h1><h2 id="表锁"><a href="#表锁" class="headerlink" title="表锁"></a>表锁</h2><ul><li>针对数据库的表进行加锁。不会出现死锁，发生锁的冲突几率高，并发低。</li><li>MySQL表锁有俩个模式：<code>表共享读锁和表独占写锁</code></li><li><code>表级自增锁</code>，当为表的某一列添加AUTO_INCREAMENT属性后，插入数据可以不指定该字段，系统会自动为它赋值。此时获取自增值是需要AUTO_INC锁锁定的</li><li>MyISANM不适合做写为主表的引擎，因为它是表锁，当锁住后，其他的线程不能做任何操作，从而大量更新会使得查询很难得到锁，最终导致永久阻塞。</li><li><code>InnoDB 牛逼的地方在于实现了颗粒度更细的行级锁。</code></li></ul><h2 id="意向锁"><a href="#意向锁" class="headerlink" title="意向锁"></a>意向锁</h2><p>如果出现行锁的时候，想加表锁，那就只能进行全表遍历，看是否有加行锁。太浪费时间</p><ul><li><code>意向锁是则不需要进行遍历数据也可以直接判断是否可以给表加锁</code>。<ul><li><code>意向共享锁（IS锁）</code>：当事务给某行记录增加了S锁（共享锁）,同时给表加一个IS锁</li><li><code>意向独占锁（IX锁）</code>：当事务给某条记录增加X锁时（独占锁），同时给表加一个IX锁。</li></ul></li><li>意向锁是innodb自动加的，不用用户干预。</li></ul><blockquote><p>意向共享锁和意向独占锁是表级锁，不会和行级的共享锁和独占锁发生冲突，&gt;而且意向锁之间也不会发生冲突，只会和共享表锁（lock tables … read）和独占表锁（lock tables … write）发生冲突。</p></blockquote><h1 id="3-行级锁"><a href="#3-行级锁" class="headerlink" title="3.行级锁"></a>3.行级锁</h1><h2 id="行锁"><a href="#行锁" class="headerlink" title="行锁"></a>行锁</h2><ul><li>innodb既支持行锁，也支持表锁</li><li><code>行锁</code>开销大，会出现死锁，发生冲突几率小，并发高</li><li>MySQL的行锁是通过索引加载的，锁住的永远是索引，而非记录本身，即使没有索引innodb会在后台创建一个聚簇索引，行锁就会锁住聚簇索引，<code>但是如果一个SQL语句没有走任何索引，那么就会为它加上表锁，全表扫描。</code></li></ul><p><code>共享锁（读锁也叫S锁）/排他锁（写锁也叫X锁）</code></p><ul><li><code>共享锁（S锁）</code>：当一个事务给一条记录上共享锁后，其他的事务也可以对该事务上共享锁，但是该锁只是可以读，如果有事务想写，那么它就会阻塞，一直等待所有的锁释放。</li><li><code>排他锁（X锁）</code>：当一个事务给记录上锁后，可以进行读写，其他的事务不能够上任何锁。<h2 id="记录锁"><a href="#记录锁" class="headerlink" title="记录锁"></a>记录锁</h2></li><li><p>记录锁，锁住的是一条记录。而且记录锁是有 S 锁和 X 锁之分的：</p><h2 id="间隙锁"><a href="#间隙锁" class="headerlink" title="间隙锁"></a>间隙锁</h2><p>MySQL默认隔离级别是<code>可重复读</code>,而可重读读只能解决脏读，不可重复读。<code>解决不了幻读</code>,但是不同的一点是MySQL通过俩种机制来解决幻读：<code>一靠MVCC方案解决，二加锁方案解决</code>。然而事务加锁时，记录是不存在的，是无法加行锁，则需要靠间隙锁。<br><img src="https://img-blog.csdnimg.cn/649593a458d4436eac325cc6f38dd3eb.png" alt="在这里插入图片描述"></p></li><li><p>例如给 id=8 记录加 gap 锁，锁住（4,8）区间。另一事务想插入 id=6 的记录，会先定位到 id=8 的记录，然后发现存在一个 gap 锁，则阻塞直到 第一个事务将 gap 锁释放掉，才可以在（4,8）区间插入记录</p></li><li>gap lock 仅仅是为了防止插入幻影记录，并不会限制其他事务对记录继续加行锁 或者 gap 锁</li></ul><h2 id="临键锁"><a href="#临键锁" class="headerlink" title="临键锁"></a>临键锁</h2><ul><li>Next-Key Lock 称为临键锁，是 Record Lock + Gap Lock 的组合，锁定一个范围，并且锁定记录本身。<h2 id="插入意向锁"><a href="#插入意向锁" class="headerlink" title="插入意向锁"></a>插入意向锁</h2></li><li><p>一个事务在插入一条记录的时候，需要判断插入位置是否已被其他事务加了间隙锁（next-key lock 也包含间隙锁）。</p></li><li><p>如果有的话，插入操作就会发生阻塞，直到拥有间隙锁的那个事务提交为止（释放间隙锁的时刻），<code>在此期间会生成一个插入意向锁，表明有事务想在某个区间插入新记录，但是现在处于等待状态。</code></p></li><li><p>插入意向锁名字虽然有意向锁，但是它并不是意向锁，它是一种特殊的间隙锁，属于行级别锁。</p><h1 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h1><ul><li>每次拿<code>数据</code>都默认别人不会修改，所以不会上锁，在更新的时候会判断一下在此期间别人有没有去更新这个数据。 </li></ul></li><li><p><code>实现方式</code>：乐观锁一般会使用版本号机制或CAS<a href="">算法</a>实现。 </p></li><li><p><strong>MVCC (Multiversion Concurrency Control)，即多版本并发控制技术。</strong></p><ul><li><strong>MVCC在MySQL InnoDB中的实现主要是为了提高<a href="">数据</a>库并发性能，用更好的方式去处理读-写冲突，做到即使有读写冲突时，也能做到不加锁</strong></li></ul></li></ul><p><code>总结</code>：</p><ul><li><code>MVCC其本质就是看做是乐观锁的机制，而排他锁等则是悲观锁的实现。</code><h1 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h1></li><li>每次拿<a href="">数据</a>时都认为别人会修改，所以每次那<a href="">数据</a>时都会上锁，别人拿<a href="">数据</a>时会阻塞直到拿到锁。 </li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>goland结构体</title>
      <link href="/2022/05/06/post10/"/>
      <url>/2022/05/06/post10/</url>
      
        <content type="html"><![CDATA[<h1 id="五、结构体"><a href="#五、结构体" class="headerlink" title="五、结构体"></a>五、结构体</h1><h2 id="结构体普通变量初始化"><a href="#结构体普通变量初始化" class="headerlink" title="结构体普通变量初始化"></a><strong>结构体普通变量初始化</strong></h2><ul><li>结构体的成员必须初始化<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">    id <span class="type">int</span></span><br><span class="line">    name <span class="type">string</span></span><br><span class="line">    sex <span class="type">byte</span></span><br><span class="line">    age <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="string">&#x27;顺序初始化，每个成员必须初始化&#x27;</span></span><br><span class="line">    <span class="keyword">var</span> s1 Student = Student&#123;<span class="number">1</span>, <span class="string">&quot;mike&quot;</span>, <span class="string">&#x27;m&#x27;</span>, <span class="number">18</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="string">&#x27;指定成员初始化，没有初始化的成员，自动赋值为0&#x27;</span></span><br><span class="line">    s2 := Student&#123;name: <span class="string">&quot;mike&quot;</span>, sex: <span class="string">&#x27;m&#x27;</span>&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="结构体指针初始化"><a href="#结构体指针初始化" class="headerlink" title="结构体指针初始化"></a><strong>结构体指针初始化</strong></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">    id <span class="type">int</span></span><br><span class="line">    name <span class="type">string</span></span><br><span class="line">    sex <span class="type">byte</span></span><br><span class="line">    age <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="string">&#x27;顺序初始化，每个成员必须初始化&#x27;</span></span><br><span class="line">    <span class="keyword">var</span> s1 *Student = Student&#123;<span class="number">1</span>, <span class="string">&quot;mike&quot;</span>, <span class="string">&#x27;m&#x27;</span>, <span class="number">18</span>&#125;</span><br><span class="line">    fmt.Println(<span class="string">&quot;p1 = &quot;</span>, p1)</span><br><span class="line"></span><br><span class="line">    <span class="string">&#x27;指定成员初始化，没有初始化的成员，自动赋值为0&#x27;</span></span><br><span class="line">    s2 := &amp;Student&#123;name: <span class="string">&quot;mike&quot;</span>, sex: <span class="string">&#x27;m&#x27;</span>&#125;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;p2 type is %T\n&quot;</span>, p2)</span><br><span class="line">    fmt.Println(<span class="string">&quot;*p2 = &quot;</span>, *p2)</span><br><span class="line">&#125;</span><br><span class="line"><span class="string">&#x27;结果&#x27;</span></span><br><span class="line">p1 = &amp;&#123;<span class="number">1</span> mike m <span class="number">18</span>&#125;</span><br><span class="line">p2 <span class="keyword">type</span> is Student</span><br><span class="line">*p2 = &#123;<span class="number">0</span> mike m <span class="number">0</span>&#125;</span><br></pre></td></tr></table></figure><h2 id="结构体成员使用：普通成员"><a href="#结构体成员使用：普通成员" class="headerlink" title="结构体成员使用：普通成员"></a><strong>结构体成员使用：普通成员</strong></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s Student</span><br><span class="line">s.id = <span class="number">1</span></span><br><span class="line">s.name = <span class="string">&quot;mike&quot;</span></span><br><span class="line">s.sex = <span class="string">&#x27;m&#x27;</span></span><br><span class="line">s.age = <span class="number">18</span></span><br><span class="line">fmt.Println(<span class="string">&quot;s = &quot;</span>, s)</span><br></pre></td></tr></table></figure><h2 id="结构体成员使用：指针成员"><a href="#结构体成员使用：指针成员" class="headerlink" title="结构体成员使用：指针成员"></a><strong>结构体成员使用：指针成员</strong></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;1. 指针有合法指向后，才操作成员&#x27;</span></span><br><span class="line"><span class="keyword">var</span> s Student    <span class="comment">//定义一个普通结构体变量</span></span><br><span class="line"><span class="keyword">var</span> p1 *Student  <span class="comment">//定义一个指针变量，保存s的地址</span></span><br><span class="line">p1 = &amp;s</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过指针操作成员 p1.id和(*p1).id完全一样，只能使用.不能使用-&gt;</span></span><br><span class="line">p1.id = <span class="number">1</span></span><br><span class="line">(*p1).name = <span class="string">&quot;mike&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;2. 通过new申请一个结构体&#x27;</span></span><br><span class="line">p2 := <span class="built_in">new</span>(Student)</span><br></pre></td></tr></table></figure><h2 id="结构体比较与赋值"><a href="#结构体比较与赋值" class="headerlink" title="结构体比较与赋值"></a><strong>结构体比较与赋值</strong></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s1 Student = Student&#123;<span class="number">1</span>, <span class="string">&quot;mike&quot;</span>, <span class="string">&#x27;m&#x27;</span>, <span class="number">18</span>&#125;</span><br><span class="line"><span class="keyword">var</span> s2 Student = Student&#123;<span class="number">1</span>, <span class="string">&quot;mike&quot;</span>, <span class="string">&#x27;m&#x27;</span>, <span class="number">18</span>&#125;</span><br><span class="line"><span class="keyword">var</span> s3 Student = Student&#123;<span class="number">1</span>, <span class="string">&quot;mike&quot;</span>, <span class="string">&#x27;w&#x27;</span>, <span class="number">20</span>&#125;</span><br><span class="line">fmt.Println(<span class="string">&quot;s1 == s2&quot;</span>, s1 == s2)</span><br><span class="line">fmt.Println(<span class="string">&quot;s1 == s3&quot;</span>, s1 == s3)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> tmp Student</span><br><span class="line">tmp = s3</span><br></pre></td></tr></table></figure><h2 id="结构体值传递与地址传递"><a href="#结构体值传递与地址传递" class="headerlink" title="结构体值传递与地址传递"></a><strong>结构体值传递与地址传递</strong></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;值传递&#x27;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test01</span> <span class="params">(s Student)</span></span>&#123;</span><br><span class="line">    s.id = <span class="number">666</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;test01:&quot;</span>, s)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;地址传递&#x27;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test02</span> <span class="params">(p *Student)</span></span>&#123;</span><br><span class="line">    p.id = <span class="number">666</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;test02:&quot;</span>, s)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">s := Student&#123;<span class="number">1</span>, <span class="string">&quot;mike&quot;</span>, <span class="string">&#x27;m&#x27;</span>, <span class="number">18</span>&#125;</span><br><span class="line">    test01(s)   <span class="comment">//值传递，形参无法改变实参</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;main:&quot;</span>, s)</span><br><span class="line"></span><br><span class="line">    test02(&amp;s)  <span class="comment">//地址传递（引用传递），形参可以改变实参</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;main:&quot;</span>, s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="go语言的可见性test"><a href="#go语言的可见性test" class="headerlink" title="go语言的可见性test"></a><strong>go语言的可见性</strong><br />test</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> test</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//如果首字母小写，只能在同一个包里面使用</span></span><br><span class="line"><span class="keyword">type</span> stu <span class="keyword">struct</span>&#123;</span><br><span class="line">    id <span class="type">int</span>  <span class="comment">//只能在同一个包使用</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> stu <span class="keyword">struct</span>&#123;</span><br><span class="line">    Id <span class="type">int</span>  <span class="comment">//可以在不同包使用</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">myFunc</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;只能在同一个包使用&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">MyFunc</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;不同包中可以使用&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>main<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;test&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">//包名.函数名</span></span><br><span class="line">    test.MyFunc()</span><br><span class="line"></span><br><span class="line">    <span class="comment">//包名.结构体里类型名</span></span><br><span class="line">    <span class="keyword">var</span> s test.Stu</span><br><span class="line">    s.Id = <span class="number">666</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> goland </category>
          
      </categories>
      
      
        <tags>
            
            <tag> goland </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>goland复合类型</title>
      <link href="/2022/05/04/post9/"/>
      <url>/2022/05/04/post9/</url>
      
        <content type="html"><![CDATA[<h1 id="四、复合类型"><a href="#四、复合类型" class="headerlink" title="四、复合类型"></a>四、复合类型</h1><p><a name="SIM8Z"></a></p><h2 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h2><p><strong>变量地址</strong><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> a <span class="type">int</span> = <span class="number">10</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;a = %d\n&quot;</span>, a)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;&amp;a = %v\n&quot;</span>, &amp;a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><strong>指针变量基本使用</strong><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> a <span class="type">int</span> = <span class="number">10</span></span><br><span class="line">    <span class="keyword">var</span> p *<span class="type">int</span></span><br><span class="line">    p = &amp;a  <span class="comment">//指针变量指向谁，就把谁的地址赋给指针变量</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;p = %v&quot;</span>, &amp;a = %v\n ,p, &amp;a)</span><br><span class="line"></span><br><span class="line">    *p = <span class="number">666</span> <span class="comment">//*p操作的不是p的内存，是p所指向的内存（也就是a）</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;*p = %v&quot;</span>, a = %v\n ,*p, a)  <span class="comment">//*p = 666 a = 666</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><img src="https://cdn.nlark.com/yuque/0/2023/png/29618862/1679467149136-621970ff-7d0d-49a2-8ea5-57934626e238.png#averageHue=%23faf7f7&amp;clientId=u7d93236d-ed98-4&amp;from=paste&amp;height=119&amp;id=u823a6bc3&amp;originHeight=179&amp;originWidth=238&amp;originalType=binary&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;size=9557&amp;status=done&amp;style=none&amp;taskId=ub7338a52-e20a-4ca6-8ad6-cbd6a49f8cb&amp;title=&amp;width=158.66666666666666" alt="1679467139192.png"><br /><strong>不要操作不合法的内存</strong><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> p *<span class="type">int</span></span><br><span class="line">    p = <span class="literal">nil</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;p =&quot;</span>, p)</span><br><span class="line">    <span class="comment">// *p = 666   err,因为p没有合法指向</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> a <span class="type">int</span></span><br><span class="line">    p = &amp;a    <span class="comment">//p指向a</span></span><br><span class="line">    *p = <span class="number">666</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;a = &quot;</span>, a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><strong>new函数</strong><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    a := <span class="number">10</span></span><br><span class="line">    <span class="keyword">var</span> p *<span class="type">int</span></span><br><span class="line">    p = <span class="built_in">new</span>(<span class="type">int</span>)  <span class="comment">//p是*int，指向int类型</span></span><br><span class="line">    *p = <span class="number">666</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;*p = &quot;</span>, p)</span><br><span class="line"></span><br><span class="line">    q := <span class="built_in">new</span>(<span class="type">int</span>) <span class="comment">//自动推导类型</span></span><br><span class="line">    *q = <span class="number">777</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;*q = &quot;</span>, *q)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><strong>值传递</strong><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">swap</span><span class="params">(a, b <span class="type">int</span>)</span></span>&#123;</span><br><span class="line">    a, b = b, a</span><br><span class="line">    fmt.Println(<span class="string">&quot;swap: a = %d, b = %d\n&quot;</span>, a, b)  <span class="comment">//a = 20 b = 10</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    a, b := <span class="number">10</span>, <span class="number">20</span></span><br><span class="line">    <span class="comment">//通过一个函数交换a和b的内容</span></span><br><span class="line">    swap(a, b) <span class="comment">//变量本身传递，值传递（相当于将实参拷贝了一份，传递给了形参，在拷贝的那份上进行交换，而实参没变）</span></span><br><span class="line">fmt.Println(<span class="string">&quot;swap: a = %d, b = %d\n&quot;</span>, a, b)   <span class="comment">//a = 10 b = 20</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><img src="https://cdn.nlark.com/yuque/0/2023/png/29618862/1679470292660-9669fa77-03b4-4f97-b2da-1d2f196dda79.png#averageHue=%23fcfaf9&amp;clientId=u7d93236d-ed98-4&amp;from=paste&amp;height=184&amp;id=u3f7aeeec&amp;originHeight=276&amp;originWidth=691&amp;originalType=binary&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;size=26328&amp;status=done&amp;style=none&amp;taskId=u1c67dd1b-0369-4f18-9abd-d40f005b5de&amp;title=&amp;width=460.6666666666667" alt="1679470282240.png"><br /><strong>地址传递</strong><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">swap</span><span class="params">(p1, p2 *<span class="type">int</span>)</span></span>&#123;</span><br><span class="line">    *p1, *p2 = *p2, *p1</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    a, b := <span class="number">10</span>, <span class="number">20</span></span><br><span class="line">    <span class="comment">//通过一个函数交换a和b的内容</span></span><br><span class="line">    swap(&amp;a, &amp;b) <span class="comment">//地址传递</span></span><br><span class="line">fmt.Println(<span class="string">&quot;main: a = %d, b = %d\n&quot;</span>, a, b)   <span class="comment">//a = 20 b = 10</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><a name="IcPn7"></a></p><h2 id=""><a href="#" class="headerlink" title=""></a><img src="https://cdn.nlark.com/yuque/0/2023/png/29618862/1679470533075-4a1dd0a1-0c48-4ba3-b9bf-8bffc15c18ac.png#averageHue=%23fcf8f7&amp;clientId=u7d93236d-ed98-4&amp;from=paste&amp;height=199&amp;id=uf28512af&amp;originHeight=299&amp;originWidth=556&amp;originalType=binary&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;size=33948&amp;status=done&amp;style=none&amp;taskId=uddfffa8e-1bef-4421-bce6-678b34d1ef9&amp;title=&amp;width=370.6666666666667" alt="1679470526993.png"></h2><p><a name="gPCjd"></a></p><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> id [<span class="number">50</span>]<span class="type">int</span>  <span class="comment">//数组，同一个类型的集合</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(id); i ++ &#123;   <span class="comment">//通过下标操作数组，从0开始，到len() - 1</span></span><br><span class="line">    id[i] = i + <span class="number">1</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;id[%d] = %d\n&quot;</span>, i, id[i])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>一维数组初始化</strong><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a [<span class="number">5</span>]<span class="type">int</span> = [<span class="number">5</span>]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">b := [<span class="number">5</span>]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125; <span class="comment">//全部初始化</span></span><br><span class="line"></span><br><span class="line">c := [<span class="number">5</span>]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;       <span class="comment">//部分初始化，没有初始化的元素，自动赋值为0</span></span><br><span class="line">d := [<span class="number">5</span>]<span class="type">int</span>&#123;<span class="number">2</span>: <span class="number">10.</span> <span class="number">4</span>: <span class="number">20</span>&#125;  <span class="comment">//指定某个元素初始化</span></span><br></pre></td></tr></table></figure><br><strong>二维数组</strong><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a [<span class="number">3</span>][<span class="number">4</span>]<span class="type">int</span></span><br><span class="line">k := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i ++&#123;</span><br><span class="line">    <span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="number">4</span>; j ++&#123;</span><br><span class="line">        k ++</span><br><span class="line">        a[i][j] = k</span><br><span class="line">        fmt.Printf(<span class="string">&quot;a[%d][%d] = %d&quot;</span>, i, j, a[i][j])</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><strong>二维数组初始化</strong><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">b := [<span class="number">3</span>][<span class="number">4</span>]<span class="type">int</span>&#123;&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;, &#123;<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>&#125;,&#123;<span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>&#125;&#125;</span><br><span class="line">c := [<span class="number">3</span>][<span class="number">4</span>]<span class="type">int</span>&#123;&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;, &#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;&#125;  <span class="comment">//部分初始化</span></span><br><span class="line">d := [<span class="number">3</span>][<span class="number">4</span>]<span class="type">int</span>&#123;<span class="number">1</span>: &#123;<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>&#125;&#125;       <span class="comment">//指定初始化某一个</span></span><br></pre></td></tr></table></figure><br><strong>二维数组比较和赋值</strong><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;支持比较，只支持 == 或 !=,比较是不是每一个元素都一样，2个元素要同类型&#x27;</span></span><br><span class="line">a := [<span class="number">5</span>]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">b := [<span class="number">5</span>]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">c := [<span class="number">5</span>]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">fmt.Println(<span class="string">&quot;a == b&quot;</span>, a == b)</span><br></pre></td></tr></table></figure><br><strong>随机数</strong><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置种子，只需要一次</span></span><br><span class="line"><span class="comment">//如果种子的参数一样，每次运行程序产生的随机数都一样rand.Seed(666)  </span></span><br><span class="line">rand.Seed(time.Now().UnixNano())  <span class="comment">//以当前系统时间作为种子参数</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i ++ &#123;</span><br><span class="line">    <span class="comment">//产生随机数</span></span><br><span class="line">    <span class="comment">//fmt.Println(&quot;rand = &quot;, rand.Int())      随机很大的数</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;rand = &quot;</span>, rand.Intn(<span class="number">100</span>))  <span class="comment">//限制在100内的数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><strong>数组做函数参数是值拷贝(形参数组是实参数组的拷贝)</strong><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">modify</span><span class="params">(a [5]<span class="type">int</span>)</span></span>&#123;</span><br><span class="line">    a[<span class="number">0</span>] = <span class="number">666</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;modify: a =&quot;</span>, a)   <span class="comment">//modify: a = &#123;666,2,3,4,5&#125;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    a := [<span class="number">5</span>]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">modify(a)</span><br><span class="line">fmt.Println(<span class="string">&quot;main: a =&quot;</span>, a)         <span class="comment">//main: a = &#123;1,2,3,4,5&#125;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><br><strong>数组指针做函数参数</strong><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//p指向实现数组a，它是指向数组，他是数组指针</span></span><br><span class="line"><span class="comment">//*p代表指针所指向的内存，就是是实参a</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">modify</span><span class="params">(p *[5]<span class="type">int</span>)</span></span>&#123;</span><br><span class="line">    (*p)[<span class="number">0</span>] = <span class="number">666</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;modify: *a =&quot;</span>, *p)   <span class="comment">//modify: a = &#123;666,2,3,4,5&#125;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    a := [<span class="number">5</span>]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">    modify(&amp;a)</span><br><span class="line">    fmt.Println(<span class="string">&quot;main: a =&quot;</span>, a)         <span class="comment">//main: a = &#123;666,2,3,4,5&#125;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><br><a name="eVthD"></a></p><h2 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h2><ul><li>数组长度定义后无法修改，数组是值类型，每次传递都将产生一份副本。（太麻烦）</li><li>切片不是数组或数组指针，他通过内部指针和相关属性引用数组片段，以实现变长方案</li><li>slice并不是动态数组，而是一个引用类型。slice总是指向一个底层array.它不需要长度</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2023/png/29618862/1679907201081-490edaf4-7206-44e5-9094-e76bc9fc0b39.png#averageHue=%23eeeeee&amp;clientId=u7d93236d-ed98-4&amp;from=paste&amp;height=173&amp;id=u348d6995&amp;originHeight=260&amp;originWidth=622&amp;originalType=binary&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;size=47306&amp;status=done&amp;style=none&amp;taskId=u3cab35f9-ed6f-4fde-ba8c-bc8c6d6ace1&amp;title=&amp;width=414.6666666666667" alt="1679907196632.png"><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[low:high:max]</span><br><span class="line">low: 下标的起点</span><br><span class="line">high: 下标的终点（不包括此下标）,[a[low]m a[high]) 左闭右开</span><br><span class="line">       <span class="built_in">len</span> = high - low, 长度</span><br><span class="line"><span class="built_in">cap</span> = max - low, 容量</span><br></pre></td></tr></table></figure><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    a := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">    s := a[<span class="number">0</span>:<span class="number">3</span>:<span class="number">5</span>]</span><br><span class="line">    fmt.Println(<span class="string">&quot;s =&quot;</span>, s)              <span class="comment">//s = [1 2 3]</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;len(s) =&quot;</span>, <span class="built_in">len</span>(s))    <span class="comment">//len(s) = 3</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;cap(s) = &quot;</span>, <span class="built_in">cap</span>(s))   <span class="comment">//cap(s) = 3</span></span><br><span class="line"></span><br><span class="line">    s = a[<span class="number">1</span>:<span class="number">4</span>:<span class="number">5</span>]</span><br><span class="line">    fmt.Println(<span class="string">&quot;s =&quot;</span>, s)              <span class="comment">//s = [2 3 4]</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;len(s) =&quot;</span>, <span class="built_in">len</span>(s))   <span class="comment">//len(s) = 4-1=3</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;cap(s) = &quot;</span>, <span class="built_in">cap</span>(s))  <span class="comment">//cap(s) = 5-1=4</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><strong>切片和数组区别</strong><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//数组[]里面的长度是固定的一个常量，数组不能修改长度，len和cap永远都是5</span></span><br><span class="line">a := [<span class="number">5</span>]<span class="type">int</span>&#123;&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;len = %d, cap = %d\n&quot;</span>, <span class="built_in">len</span>(a), <span class="built_in">cap</span>(a)) </span><br><span class="line"></span><br><span class="line"><span class="comment">//切片，[]里面是空的，或者为...切片的长度或容易可以不固定</span></span><br><span class="line">s := []<span class="type">int</span>&#123;&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;l: len = %d, cap = %d\n&quot;</span>, <span class="built_in">len</span>(s), <span class="built_in">cap</span>(s))</span><br><span class="line"></span><br><span class="line">s = <span class="built_in">append</span>(s, <span class="number">11</span>) <span class="comment">//给切片末尾追加一个成员</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;append: len = %d, cap = %d\n&quot;</span>, <span class="built_in">len</span>(s), <span class="built_in">cap</span>(s))</span><br></pre></td></tr></table></figure><br><strong>切片的创建</strong><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1. 自动推导类型，同时初始化</span></span><br><span class="line">s1 := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line">fmt.Println(<span class="string">&quot;s1 = &quot;</span>, s1)</span><br><span class="line"></span><br><span class="line"><span class="comment">//2. 借助make函数，格式make(切片类型，长度，容量)</span></span><br><span class="line">s2 := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">5</span>, <span class="number">10</span>)</span><br><span class="line">fmt.Printf(<span class="string">&quot;len = %d, cap = %d\n&quot;</span>, <span class="built_in">len</span>(s2), <span class="built_in">cap</span>(s2))</span><br><span class="line"></span><br><span class="line"><span class="comment">//3. 没有指定容量，默认容量和长度一样</span></span><br><span class="line">s3 := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">5</span>)</span><br><span class="line">fmt.Printf(<span class="string">&quot;len = %d, cap = %d\n&quot;</span>, <span class="built_in">len</span>(s3), <span class="built_in">cap</span>(s3))</span><br></pre></td></tr></table></figure><br><strong>切片的截取</strong><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">array := []<span class="type">int</span>&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;</span><br><span class="line"><span class="comment">//[low:high:max] 取下标从low开始的元素，len=high-low, cap=max-low</span></span><br><span class="line">s1 := array[:] <span class="comment">//[0:len(array):len(array)]  不指定容量和长度一样</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//操作某一个元素和数组操作方式一样</span></span><br><span class="line">data := array[<span class="number">1</span>]</span><br><span class="line">fmt.Println(<span class="string">&quot;data = &quot;</span>, data)</span><br><span class="line"></span><br><span class="line">s2 := array[<span class="number">3</span>:<span class="number">6</span>:<span class="number">7</span>]  <span class="comment">//a[3], a[4], a[5] len = 6-3=3 cap=7-3=4</span></span><br><span class="line"></span><br><span class="line">s3 := array[:<span class="number">6</span>]     <span class="comment">//从0开始，去6个元素，容量也是6，常用</span></span><br><span class="line"></span><br><span class="line">s4 := array[<span class="number">3</span>:]     <span class="comment">//从下标为3开始，到结尾</span></span><br></pre></td></tr></table></figure><br> <strong>切片与底层数组关系</strong><br /><img src="https://cdn.nlark.com/yuque/0/2023/png/29618862/1679910304479-34e31c62-8156-4965-b3a6-20c4ea383fcd.png#averageHue=%23fefefe&amp;clientId=u7d93236d-ed98-4&amp;from=paste&amp;height=197&amp;id=u398f3d02&amp;originHeight=296&amp;originWidth=717&amp;originalType=binary&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;size=55356&amp;status=done&amp;style=none&amp;taskId=ue0c68e4c-f99c-42e2-be2c-ac61fe6d8a7&amp;title=&amp;width=478" alt="1679910300403.png"><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    a := []<span class="type">int</span>&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;</span><br><span class="line"><span class="comment">//新切片</span></span><br><span class="line">    s1 := a[<span class="number">2</span>:<span class="number">5</span>]  <span class="comment">//从a[2]开始， 取3个元素</span></span><br><span class="line">    s1[<span class="number">1</span>] = <span class="number">666</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;s1 =&quot;</span>, s1)</span><br><span class="line">    fmt.Println(<span class="string">&quot;a = &quot;</span>, a)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//另外的切片</span></span><br><span class="line">    s2 := s1[<span class="number">2</span>:<span class="number">7</span>]</span><br><span class="line">    s2[<span class="number">2</span>] = <span class="number">888</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;s2 = &quot;</span>, s2)</span><br><span class="line">    fmt.Println(<span class="string">&quot;a = &quot;</span>, a)</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><img src="https://cdn.nlark.com/yuque/0/2023/png/29618862/1679910492839-8105f50c-5525-4347-b674-326f4b21a6af.png#averageHue=%23111110&amp;clientId=u7d93236d-ed98-4&amp;from=paste&amp;height=40&amp;id=u1abc0075&amp;originHeight=60&amp;originWidth=296&amp;originalType=binary&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;size=15856&amp;status=done&amp;style=none&amp;taskId=ua28d72b5-fcfb-44bb-9c56-94d7528523d&amp;title=&amp;width=197.33333333333334" alt="1679910484977.png"><br /><strong>append</strong></p><ul><li>在切片末尾追加，返回新的slice对象</li><li><p>append函数会智能的底层数组的容量增长，一旦超过原底层数组容量，通常以2倍容量重新分配底层数组， 并复制原来的数据</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">s1 := []<span class="type">int</span>&#123;&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;len = %d, cap = %d\n&quot;</span>, <span class="built_in">len</span>(s1), <span class="built_in">cap</span>(s1))</span><br><span class="line">fmt.Println(<span class="string">&quot;s1 = &quot;</span>, s1)</span><br><span class="line"></span><br><span class="line"><span class="comment">//在原切片的末尾添加元素</span></span><br><span class="line">s1 = <span class="built_in">append</span>(s1, <span class="number">1</span>)</span><br><span class="line">s1 = <span class="built_in">append</span>(s2, <span class="number">1</span>)</span><br><span class="line">s1 = <span class="built_in">append</span>(s3, <span class="number">1</span>)</span><br><span class="line">fmt.Println(<span class="string">&quot;len = %d, cap = %d\n&quot;</span>, <span class="built_in">len</span>(s1), <span class="built_in">cap</span>(s1))</span><br><span class="line">fmt.Println(<span class="string">&quot;s1 =&quot;</span>, s1)</span><br><span class="line"></span><br><span class="line">s2 := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">fmt.Println(<span class="string">&quot;s2 = &quot;</span>, s2)</span><br><span class="line">s2 = <span class="built_in">append</span>(s1, <span class="number">5</span>)</span><br><span class="line">s2 = <span class="built_in">append</span>(s2, <span class="number">5</span>)</span><br><span class="line">s2 = <span class="built_in">append</span>(s2, <span class="number">5</span>)</span><br><span class="line">fmt.Println(<span class="string">&quot;s2 = &quot;</span>, s2)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2023/png/29618862/1679910977134-4138e644-3d45-4ae7-ab35-2aec649732e6.png#averageHue=%232d2b29&amp;clientId=u7d93236d-ed98-4&amp;from=paste&amp;id=u229e1ac9&amp;originHeight=87&amp;originWidth=201&amp;originalType=binary&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;size=14850&amp;status=done&amp;style=none&amp;taskId=ucd428055-9a87-4068-837e-3140f896fda&amp;title=" alt="1679910969931.png"><br /><strong>append增长的特点</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">//如果超过原来的容量，通常以2倍容量扩容</span></span><br><span class="line">    s := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>, <span class="number">1</span>)  <span class="comment">//容量为1</span></span><br><span class="line">    oldCap := <span class="built_in">cap</span>(s)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">8</span>; i++ &#123;</span><br><span class="line">        s = <span class="built_in">append</span>(s, i)</span><br><span class="line">        <span class="keyword">if</span> newCap := <span class="built_in">cap</span>(s); oldCap &lt; newCap &#123;</span><br><span class="line">            fmt.Printf(<span class="string">&quot;cap: %d ===&gt; %d\n&quot;</span>, oldCap, newCap)</span><br><span class="line">            oldCap = newCap</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2023/png/29618862/1679911432027-1f6969d8-08b0-45f4-b1ee-433274dfabdf.png#averageHue=%2333312f&amp;clientId=u7d93236d-ed98-4&amp;from=paste&amp;height=45&amp;id=u2d4f8446&amp;originHeight=68&amp;originWidth=152&amp;originalType=binary&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;size=12924&amp;status=done&amp;style=none&amp;taskId=u3671b185-1cc8-4efa-b117-1b633bf9489&amp;title=&amp;width=101.33333333333333" alt="1679911424544.png"><br /><strong>copy</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">srcSlice := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>&#125;</span><br><span class="line">dstSlice := []<span class="type">int</span>&#123;<span class="number">6</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">6</span>&#125;</span><br><span class="line"><span class="built_in">copy</span>(dstSlice, srcSlice)</span><br><span class="line">fmt.Println(<span class="string">&quot;dst = &quot;</span>, dstSlice)</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;结果&#x27;</span></span><br><span class="line">dst = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">6</span>&#125;</span><br></pre></td></tr></table></figure><p><strong>切片做函数参数：切片是引用传递，数组是值传递</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">InitData</span><span class="params">(s []<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    rand.Seed(time.Now().UnixNano())  <span class="comment">//随机种子</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(s); i ++ &#123;</span><br><span class="line">        s[i] = rand.Intn(<span class="number">100</span>)        <span class="comment">//100以内的随机数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BubbleSort</span><span class="params">(s []<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(s)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span> - <span class="number">1</span>; i ++ &#123;</span><br><span class="line">        <span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="built_in">len</span> - i - <span class="number">1</span>; j ++ &#123;</span><br><span class="line">            <span class="keyword">if</span> s[j] &gt; s[j + <span class="number">1</span>]</span><br><span class="line">                s[j], s[j + <span class="number">1</span>] = s[j + <span class="number">1</span>], s[j]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    n := <span class="number">10</span>;</span><br><span class="line">    s := <span class="built_in">make</span>([]<span class="type">int</span>, n)</span><br><span class="line"></span><br><span class="line">    InitData(s)</span><br><span class="line">    fmt.Println(<span class="string">&quot;排序前&quot;</span>, s)</span><br><span class="line">    BubbleSort(s)</span><br><span class="line">    fmt.Println(<span class="string">&quot;排序后&quot;</span>, s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="Knv2A"></a></p><h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2></li><li><p>Go中的map（映射、字典）是一个无序的key-value对集合</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">info := <span class="keyword">map</span>[<span class="type">int</span>]<span class="type">string</span>&#123;  <span class="comment">//int为key, string为value</span></span><br><span class="line"><span class="number">110</span>: <span class="string">&quot;mike&quot;</span>,</span><br><span class="line"><span class="number">111</span>: <span class="string">&quot;yoyo&quot;</span>,</span><br><span class="line"><span class="number">112</span>: <span class="string">&quot;lily&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>map格式为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">map</span>[keyType]valueType</span><br></pre></td></tr></table></figure></li><li><p>在map里所有的键都是唯一的，必须支持==和!=操作符，切片、函数以及包含切片的结构类型由于具有引用语义，不能作为映射的键，会出现错误</p></li><li>map中的value可以是任意类型</li><li>map的键和值类型可以不一样</li><li>map中所有的键的类型必须一样</li></ul><p>注意：map是无序的，无法决定返回顺序，每次打印结果可能不一样</p><p><strong>map创建</strong><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> m1 <span class="keyword">map</span>[<span class="type">int</span>]<span class="type">string</span>         <span class="comment">//只是声明一个map,并没有初始化</span></span><br><span class="line">fmt.Println(<span class="string">&quot;m1 = &quot;</span>, m1)</span><br><span class="line">fmt.Println(<span class="string">&quot;len =&quot;</span>, <span class="built_in">len</span>(m1)) <span class="comment">//对于map只有len没有cap</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;可以通过make创建&#x27;</span></span><br><span class="line">m2 := <span class="built_in">make</span>(<span class="keyword">map</span> [<span class="type">int</span>]<span class="type">string</span>)</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;并且指定长度，只是指定了容量，但是里面却是一个数据也没有&#x27;</span></span><br><span class="line">m3 := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]<span class="type">string</span>, <span class="number">2</span>))</span><br><span class="line">m3[<span class="number">1</span>] = <span class="string">&quot;mike&quot;</span></span><br><span class="line">m3[<span class="number">2</span>] = <span class="string">&quot;c++&quot;</span></span><br><span class="line">m3[<span class="number">3</span>] = <span class="string">&quot;lili&quot;</span>   <span class="comment">//虽然指定容量为2，但是不够的话会自动扩充</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;声明时直接初始化&#x27;</span></span><br><span class="line">m4 := <span class="keyword">map</span>[<span class="type">int</span>] <span class="type">string</span> &#123;<span class="number">1</span> : <span class="string">&quot;mike&quot;</span>, <span class="number">2</span> : <span class="string">&quot;go&quot;</span>, <span class="number">3</span> : <span class="string">&quot;c++&quot;</span>, <span class="number">1</span> : <span class="string">&quot;lalal&quot;</span>&#125; <span class="comment">//错误：键值应该唯一</span></span><br></pre></td></tr></table></figure><br><img src="https://cdn.nlark.com/yuque/0/2023/png/29618862/1680597916778-2da79570-fbcc-44e2-a66d-b46e99dc709d.png#averageHue=%23121010&amp;clientId=uad439440-e395-4&amp;from=paste&amp;height=67&amp;id=ue28aa395&amp;originHeight=100&amp;originWidth=239&amp;originalType=binary&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;size=22880&amp;status=done&amp;style=none&amp;taskId=u50d0a3f1-5f34-4c7c-9baf-c83cde08526&amp;title=&amp;width=159.33333333333334" alt="1680597911752.png"><br /><strong>map赋值</strong><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">m4 := <span class="keyword">map</span>[<span class="type">int</span>] <span class="type">string</span> &#123;<span class="number">1</span> : <span class="string">&quot;mike&quot;</span>, <span class="number">2</span> : <span class="string">&quot;go&quot;</span>&#125;</span><br><span class="line"><span class="comment">//如果已经存在的key值，修改内容</span></span><br><span class="line">m4[<span class="number">1</span>] = <span class="string">&quot;c++&quot;</span></span><br><span class="line">m4[<span class="number">3</span>] = <span class="string">&quot;java&quot;</span> <span class="comment">//没有的key则进行追加，map底层自动扩容，和append类似</span></span><br></pre></td></tr></table></figure><br><strong>map遍历</strong><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">m := <span class="keyword">map</span>[<span class="type">int</span>]<span class="type">string</span>&#123;<span class="number">1</span> : <span class="string">&quot;mike&quot;</span>, <span class="number">2</span> : <span class="string">&quot;yoyo&quot;</span>, <span class="number">3</span> : <span class="string">&quot;go&quot;</span>&#125;</span><br><span class="line"><span class="comment">//第一个返回的为key,第二个返回的为value，遍历结果无序</span></span><br><span class="line"><span class="keyword">for</span> key, value := <span class="keyword">range</span> m &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%d====&gt; %s\n&quot;</span>, key, value)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如何判断一个key值是否存在</span></span><br><span class="line"><span class="comment">//第一个返回值为key所对应的value，第二个返回值为key是否存在的条件，存在ok为true</span></span><br><span class="line">value, ok := m[<span class="number">1</span>]</span><br><span class="line"><span class="keyword">if</span> ok == <span class="literal">true</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;m[1] =&quot;</span>, value)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;key不存在&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><strong>map删除</strong><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">delete</span>(m ,<span class="number">1</span>) <span class="comment">//删除key = 1的</span></span><br></pre></td></tr></table></figure><br><strong>map做函数参数：是引用传递</strong><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">(m <span class="keyword">map</span>[<span class="type">int</span>]<span class="type">string</span>)</span></span> &#123;</span><br><span class="line">    <span class="built_in">delete</span>(m, <span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    m := <span class="keyword">map</span>[<span class="type">int</span>]<span class="type">string</span>&#123;<span class="number">1</span> : <span class="string">&quot;mike&quot;</span>, <span class="number">2</span> : <span class="string">&quot;yoyo&quot;</span>, <span class="number">3</span> : <span class="string">&quot;go&quot;</span>&#125;</span><br><span class="line">    test(m)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> goland </category>
          
      </categories>
      
      
        <tags>
            
            <tag> goland </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>goland函数类型</title>
      <link href="/2022/05/02/post8/"/>
      <url>/2022/05/02/post8/</url>
      
        <content type="html"><![CDATA[<h1 id="三、函数类型"><a href="#三、函数类型" class="headerlink" title="三、函数类型"></a>三、函数类型</h1><h2 id="函数类型"><a href="#函数类型" class="headerlink" title="函数类型"></a><strong>函数类型</strong></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Add</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123; <span class="keyword">return</span> a + b&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Minus</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;<span class="keyword">return</span> a - b&#125;</span><br><span class="line"><span class="keyword">type</span> FuncType <span class="function"><span class="keyword">func</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span></span> <span class="type">int</span>  <span class="comment">//没有函数名，没有&#123;&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> result <span class="type">int</span> </span><br><span class="line">    result = Add(<span class="number">1</span>, <span class="number">1</span>) <span class="comment">//普通调用</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> fTest FuncType</span><br><span class="line">    fTest = ADD</span><br><span class="line">    result = fTest(<span class="number">10</span>, <span class="number">20</span>) <span class="comment">//等价于Add(1, 1)</span></span><br><span class="line"></span><br><span class="line">    fTest = Minus</span><br><span class="line">    result = fTest(<span class="number">10</span>, <span class="number">20</span>) <span class="comment">//等价于Minus(10, 20)</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="ewtHA"></a></p><h2 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> FuncType <span class="function"><span class="keyword">func</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span></span> <span class="type">int</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Add</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123; <span class="keyword">return</span> a + b&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Minus</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;<span class="keyword">return</span> a - b&#125;</span><br><span class="line"><span class="comment">//回调函数，函数有一个参数是函数类型，这个函数就是回调函数</span></span><br><span class="line"><span class="comment">//多态，调用同一个接口，不同的表现，可以实现不同的功能，加减乘除</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Calc</span><span class="params">(a, b <span class="type">int</span>, fTest FuncType)</span></span> (result <span class="type">int</span>) &#123;</span><br><span class="line">    result = fTest(a, b) <span class="comment">//这个函数还没有实现，但是运行不出错</span></span><br><span class="line">    result = Add(a, b)  <span class="comment">//Add()必须先定义后，才能调用，否则就会出错</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    a := Calc(<span class="number">1</span>, <span class="number">1</span>, Add)</span><br><span class="line">    fmt.Println(<span class="string">&quot;a = &quot;</span>, a)</span><br><span class="line">    b := Calc(<span class="number">1</span>, <span class="number">1</span>, Minus)</span><br><span class="line">    fmt.Println(<span class="string">&quot;b = &quot;</span>, b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="of8R7"></a></p><h2 id="闭包（匿名函数）"><a href="#闭包（匿名函数）" class="headerlink" title="闭包（匿名函数）"></a>闭包（匿名函数）</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    a := <span class="number">10</span></span><br><span class="line">    str := <span class="string">&quot;Mike&quot;</span></span><br><span class="line"><span class="comment">//匿名函数，没有函数名字，函数定义，还没有调用</span></span><br><span class="line">    f1 := <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;a = &quot;</span>, a)</span><br><span class="line">    &#125;</span><br><span class="line">    f1 ()</span><br><span class="line"></span><br><span class="line">    <span class="string">&#x27;或者&#x27;</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;a = %d, str = %s\n&quot;</span>, a, str)</span><br><span class="line">    &#125;()  <span class="comment">//后面的()代表调用此匿名函数</span></span><br><span class="line"></span><br><span class="line">    <span class="string">&#x27;有参数&#x27;</span></span><br><span class="line">    f3 := <span class="function"><span class="keyword">func</span><span class="params">(i, j <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;i = %d, j = %d\n&quot;</span>, i, j)</span><br><span class="line">    &#125;</span><br><span class="line">    f3(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span><span class="params">(i, j <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">         fmt.Printf(<span class="string">&quot;i = %d, j = %d\n&quot;</span>, i, j)</span><br><span class="line">    &#125;(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    <span class="string">&#x27;匿名函数，有参数有返回值&#x27;</span></span><br><span class="line">    x, y := <span class="function"><span class="keyword">func</span><span class="params">(i, j <span class="type">int</span>)</span></span> (max, min <span class="type">int</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> i &gt; j &#123;</span><br><span class="line">            max = i</span><br><span class="line">            min = j</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            max = j</span><br><span class="line">            min = i</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">&#125;(<span class="number">10</span>, <span class="number">20</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="闭包捕获外部变量特点"><a href="#闭包捕获外部变量特点" class="headerlink" title="闭包捕获外部变量特点"></a><strong>闭包捕获外部变量特点</strong></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//闭包以引用方式捕获外部变量，最后发现内部和外部打印的结果都是a=666, str=go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    a := <span class="number">10</span></span><br><span class="line">    str := <span class="string">&quot;mike&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        a = <span class="number">666</span></span><br><span class="line">        str = <span class="string">&quot;go&quot;</span></span><br><span class="line">        fmt.Printf(<span class="string">&quot;内部:a = %d, str = %s\n&quot;</span>, a, str)</span><br><span class="line">    &#125;()  <span class="comment">//()代表直接调用</span></span><br><span class="line"></span><br><span class="line">    fmt.Printf(<span class="string">&quot;外部:a = %d, str = %s\n&quot;</span>, a, str)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="闭包特点"><a href="#闭包特点" class="headerlink" title="闭包特点"></a><strong>闭包特点</strong></h2><ul><li><p>它不关心这些捕获了的变量和常量是否已经超出了作用域，所以只有闭包还在使用它，这些变量就还会存在</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//函数的返回值时一个匿名函数，返回一个函数类型</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test02</span><span class="params">()</span></span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> x <span class="type">int</span>      <span class="comment">//没有初始化，值为0</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">int</span> &#123;</span><br><span class="line">        x ++</span><br><span class="line">        <span class="keyword">return</span> x * x</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test01</span><span class="params">()</span></span> <span class="type">int</span> &#123;</span><br><span class="line">     <span class="comment">//函数被调用时，x才会分配空间，才初始化为0</span></span><br><span class="line">    <span class="keyword">var</span> x <span class="type">int</span>       <span class="comment">//没有初始化，值为0</span></span><br><span class="line">    x++</span><br><span class="line">    <span class="keyword">return</span> x * x    <span class="comment">//函数调用完毕，x自动释放</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(test01()) <span class="comment">//1</span></span><br><span class="line">    fmt.Println(test01()) <span class="comment">//1</span></span><br><span class="line">    fmt.Println(test01()) <span class="comment">//1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回值是一个匿名函数，返回一个函数类型，通过f来调用返回的匿名函数，f来调用闭包函数</span></span><br><span class="line">    f := test02()  <span class="comment">//返回值是一个匿名函数</span></span><br><span class="line">    fmt.Println(f())  <span class="comment">//1</span></span><br><span class="line">    fmt.Println(f())  <span class="comment">//2</span></span><br><span class="line">    fmt.Println(f())  <span class="comment">//3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="dTtcl"></a></p><h2 id="延迟调用defer-只能出现在函数或方法的内部"><a href="#延迟调用defer-只能出现在函数或方法的内部" class="headerlink" title="延迟调用defer,只能出现在函数或方法的内部"></a>延迟调用defer,只能出现在函数或方法的内部</h2></li><li><p>defer延迟调用，main函数结束的一刹那前调用</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> fmt.Println(<span class="string">&quot;bbb&quot;</span>)</span><br><span class="line">    fmt.Println(<span class="string">&quot;aaa&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="string">&#x27;运行结果&#x27;</span></span><br><span class="line">aaa</span><br><span class="line">bbb</span><br></pre></td></tr></table></figure></li><li><p>多个defer一起调用，出现先进后出,哪怕函数或某个延迟调用发生村务，这些调用依旧会被执行</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">(x <span class="type">int</span>)</span></span> &#123;fmt.Println(<span class="number">100</span> / x)&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> fmt.Println(<span class="string">&quot;aaa&quot;</span>)</span><br><span class="line">    <span class="keyword">defer</span> fmt.Println(<span class="string">&quot;bbb&quot;</span>)</span><br><span class="line">    <span class="keyword">defer</span> test(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">defer</span> fmt.Println(<span class="string">&quot;ccc&quot;</span>)</span><br><span class="line">&#125;   <span class="comment">// ccc   bbb   aaa   崩掉了</span></span><br></pre></td></tr></table></figure></li><li><p>defer和匿名函数结合使用</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    a := <span class="number">10</span></span><br><span class="line">    b := <span class="number">20</span></span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;内部a = %d, b = %d\n&quot;</span>, a, b)    <span class="comment">//结果：外部a=111 b=222 | 内部a=111 b=222</span></span><br><span class="line">    &#125; ()  <span class="comment">//()代表调用此匿名函数</span></span><br><span class="line"></span><br><span class="line">     <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">(a ,b <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;内部a = %d, b = %d\n&quot;</span>, a, b)</span><br><span class="line">    &#125; (a, b)  <span class="comment">//()代表调用此匿名函数,把参数传递过去，已经先传递参数了，只是没有调用</span></span><br><span class="line">                                                   <span class="comment">//结果：外部a=111 b=222 | 内部a=10 b=20</span></span><br><span class="line">                                                   <span class="comment">//等价于defer func(a, b, int)&#123;</span></span><br><span class="line">                                                   <span class="comment">//        fmt.Println(&quot;内部a = %d, b = %d\n&quot;, a, b)</span></span><br><span class="line">                                                   <span class="comment">//     &#125;(10, 20)</span></span><br><span class="line">    a = <span class="number">111</span></span><br><span class="line">    b = <span class="number">222</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;外部a = %d, b = %d\n&quot;</span>, a, b)   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="获取命令行参数"><a href="#获取命令行参数" class="headerlink" title="获取命令行参数"></a><strong>获取命令行参数</strong></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;os&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    list := as.Args   <span class="comment">//返回是一个列表 []string</span></span><br><span class="line">    n := <span class="built_in">len</span>(list)</span><br><span class="line">    fmt.Println(<span class="string">&quot;n = &quot;</span>, n)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;list[%d] = %s\n&quot;</span>, i, list[i])</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i, data <span class="keyword">range</span> list &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;list[%d] = %s\n&quot;</span>, i, data)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="string">&#x27;运行&#x27;</span></span><br><span class="line"><span class="keyword">go</span> run main.<span class="keyword">go</span> a b</span><br><span class="line">n=<span class="number">3</span></span><br><span class="line">list[<span class="number">0</span>]=main.<span class="keyword">go</span></span><br><span class="line">list[<span class="number">1</span>]=a</span><br><span class="line">list[<span class="number">2</span>]=b</span><br></pre></td></tr></table></figure><p><a name="U0TSZ"></a></p><h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2></li><li><p><strong>全局变量</strong></p><ul><li>定义在函数外部的变量是全局变量，全局变量在任何地方都可以使用<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">fun test() &#123;fmt.Println(<span class="string">&quot;test a = &quot;</span>, a)&#125;</span><br><span class="line"><span class="keyword">var</span> a <span class="type">int</span>  <span class="comment">//正确</span></span><br><span class="line">a := <span class="number">10</span>    <span class="comment">//错误</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    a = <span class="number">10</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;a = &quot;</span>, a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>局部变量</strong></p><ul><li>执行到定义变量的那句话，才开始分配空间，离开作用域自动释放<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;定义在&#123;&#125;里面的变量就是局部变量，只能在&#123;&#125;里面有效&#x27;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span></span> &#123;a := <span class="number">10</span> fmt.Println(<span class="string">&quot;a =&quot;</span>, a)&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> flag := <span class="number">3</span>, flag == <span class="number">3</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;flag = &quot;</span>, flag)</span><br><span class="line">    &#125;</span><br><span class="line">        flag = <span class="number">4</span>  <span class="comment">//错误，未定义</span></span><br><span class="line">        a = <span class="number">5</span>     <span class="comment">//错误，未定义</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>局部变量与全局变量同名</strong></p><ul><li>就近原则<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a <span class="type">byte</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> a <span class="type">int</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;%T\n&quot;</span>, a)           <span class="comment">//int</span></span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> a <span class="type">float32</span></span><br><span class="line">        fmt.Printf(<span class="string">&quot;%T\n&quot;</span>, a)       <span class="comment">//float32</span></span><br><span class="line">    &#125;</span><br><span class="line">    test()</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span></span>&#123;fmt.Printf(<span class="string">&quot;%T\n&quot;</span>, a)&#125;  <span class="comment">//uint8</span></span><br></pre></td></tr></table></figure><a name="pD1dp"></a><h2 id="工程管理"><a href="#工程管理" class="headerlink" title="工程管理"></a>工程管理</h2><strong>工作区</strong></li></ul></li><li><p>go代码必须放在工作区</p></li></ul><p><strong>包</strong></p><ul><li>go是以包作为管理，go语言程序会组织成若干个包，这些包都可以被其他项目引用</li><li>import “包名”</li><li><p>每个包都有对应一个独立的名字空间 package main | package calc</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main   <span class="comment">//必须</span></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;this is a test&quot;</span>)</span><br><span class="line">    fmt.Println(<span class="string">&quot;os.Args = &quot;</span>, os.Args)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>点操作(调用函数，无需通过包名)</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main   <span class="comment">//必须</span></span><br><span class="line"><span class="keyword">import</span> . <span class="string">&quot;fmt&quot;</span>   </span><br><span class="line"><span class="keyword">import</span> . <span class="string">&quot;os&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    Println(<span class="string">&quot;this is a test&quot;</span>)</span><br><span class="line">    Println(<span class="string">&quot;os.Args = &quot;</span>, Args)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>别名操作(给包起别名)</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main   <span class="comment">//必须</span></span><br><span class="line"><span class="keyword">import</span> os <span class="string">&quot;fmt&quot;</span>   </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    os.Println(<span class="string">&quot;this is a test&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>忽略操作(_操作是引入包，而不直接使用包里面的函数，而是用来调用该包里面的init函数)</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> _ <span class="string">&quot;fmt&quot;</span></span><br></pre></td></tr></table></figure><p><strong>同级目录</strong></p></li><li><p>同一个目录，包名必须一样</p></li><li>同一个目录，调用别的文件的函数，直接调用即可，无需包名引用</li></ul><p>同一个文件下的俩个go程序：main.go和test.go<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;this is a test&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    test()   <span class="comment">//this is a test</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><strong>不同目录</strong></p><ul><li>不同目录，包名不一样package main | package calc</li><li>调用不同包里面的函数，格式：包名.函数名()  calc.Add(10, 20)</li><li>调用别的包函数，这个包函数名字如果首字母必须是大写 func Add()，才可以让别人调用<ul><li><strong>src目录下的main.go</strong><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;calc&quot;</span></span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;fmt.Println(<span class="string">&quot;this is main init&quot;</span>)&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    a := calc.Add(<span class="number">10</span>, <span class="number">20</span>)</span><br><span class="line">    fmt.Println(<span class="string">&quot;a = &quot;</span>, a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><ul><li><strong>src/calc目录下的calc.go</strong><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> calc</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;this is calc init&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Add</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><strong>init函数</strong><br /><img src="https://cdn.nlark.com/yuque/0/2023/png/29618862/1679456530811-9739809d-9e25-4d84-bf55-a57c6e567fb6.png#averageHue=%23f8f4f0&amp;clientId=u7d93236d-ed98-4&amp;from=paste&amp;height=337&amp;id=u230e231f&amp;originHeight=506&amp;originWidth=691&amp;originalType=binary&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;size=141616&amp;status=done&amp;style=none&amp;taskId=ub7d35d63-d5ac-4d9f-8f34-2b731631b5b&amp;title=&amp;width=460.6666666666667" alt="1679456525126.png"><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;运行结果&#x27;</span></span><br><span class="line">this is calc init</span><br><span class="line">this is main init</span><br><span class="line">a = <span class="number">30</span></span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> goland </category>
          
      </categories>
      
      
        <tags>
            
            <tag> goland </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>goland基础</title>
      <link href="/2022/04/27/post6/"/>
      <url>/2022/04/27/post6/</url>
      
        <content type="html"><![CDATA[<h1 id="一、基础"><a href="#一、基础" class="headerlink" title="一、基础"></a>一、基础</h1><p><strong>编译运行</strong></p><ul><li>go build xxx.go：编译go代码，生成可执行程序xxx,然后运行可执行程序 xxx</li><li>go run xxx.go：不生成程序，直接运行</li></ul><p><strong>变量名声明格式(var+变量名+类型)：</strong></p><ul><li>var a int（定义一个变量）</li><li>导入包必须使用否则报错</li><li>变量声明了必须使用否则报错</li><li>只是声明，没有初始化的变量，默认值为0</li><li>同一个{ }里，声明的变量名是唯一的</li><li>var b, c int（定义多个变量）</li></ul><p><strong>变量初始化方式</strong><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;方式1&#x27;</span></span><br><span class="line"><span class="keyword">var</span> b <span class="type">int</span> = <span class="number">10</span></span><br><span class="line">b = <span class="number">30</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;方式2(常用)：自动推导类型，必须初始化，通过初始化的值确定类型&#x27;</span></span><br><span class="line">c := <span class="number">30</span></span><br><span class="line"></span><br><span class="line">b=<span class="number">40</span>(赋值)</span><br><span class="line">b=<span class="number">50</span>(赋值)</span><br><span class="line">c := <span class="number">40</span>(错误)</span><br><span class="line">c = <span class="number">40</span>(正确)</span><br></pre></td></tr></table></figure></p><ul><li>赋值可以多次，但是类型推导只能使用一次，用于初始化那次</li></ul><p><strong>Println和Printf</strong><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fmt.Println(<span class="string">&quot;a = &quot;</span>, a, <span class="string">&quot;b = &quot;</span>, b, <span class="string">&quot;c = &quot;</span>, c)  <span class="comment">//一段一段出来，自动加换行</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;a = %d, b = %d, c = %d\n&quot;</span>, a, b, c) <span class="comment">//&quot;\n代表换行符&quot;</span></span><br></pre></td></tr></table></figure><br><strong>多重赋值与匿名变量</strong><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a, b := <span class="number">10</span>, <span class="number">20</span></span><br><span class="line">b,a = a, b     <span class="comment">//交换变量的值</span></span><br><span class="line">tmp, _ = i, j  <span class="comment">//将i赋值给tmp, j丢弃不处理</span></span><br></pre></td></tr></table></figure><br><strong>常量</strong></p><ul><li>const a int = 10 或者 const b = 11.2（正确）</li><li><p>const b := 10（错误）</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a <span class="type">int</span> = <span class="number">1</span></span><br><span class="line"><span class="keyword">var</span> b <span class="type">float64</span> = <span class="number">3.14</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (               <span class="comment">//也可以自动推导类型</span></span><br><span class="line">    a <span class="type">int</span> = <span class="number">1</span></span><br><span class="line">    b <span class="type">float64</span> = <span class="number">3.14</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> i <span class="type">int</span> = <span class="number">1</span></span><br><span class="line"><span class="keyword">const</span> j <span class="type">float64</span> = <span class="number">3.14</span></span><br><span class="line"><span class="keyword">const</span> (            <span class="comment">//可以自动类型推导</span></span><br><span class="line">    i = <span class="number">1</span></span><br><span class="line">    j = <span class="number">3.14</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><strong>iota枚举</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    a = <span class="literal">iota</span>  <span class="comment">//0</span></span><br><span class="line">    b = <span class="literal">iota</span>  <span class="comment">//1</span></span><br><span class="line">    c = <span class="literal">iota</span>  <span class="comment">//2</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//iota遇到const重置为0</span></span><br><span class="line"><span class="keyword">const</span> d = <span class="literal">iota</span> <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    a1 = <span class="literal">iota</span> <span class="comment">//0</span></span><br><span class="line">    a2, a3, a4 = <span class="literal">iota</span>, <span class="literal">iota</span>, <span class="literal">iota</span> <span class="comment">//a2=a3=a4=1</span></span><br><span class="line">    a5 = <span class="literal">iota</span>  <span class="comment">//2</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><strong>类型</strong></p></li><li><p><strong>bool</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a <span class="type">bool</span>  |    <span class="keyword">var</span> a <span class="type">bool</span> = <span class="literal">false</span>  |  c := <span class="literal">false</span></span><br><span class="line">a = <span class="literal">true</span>    |</span><br></pre></td></tr></table></figure></li><li><p>float32</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> f1 <span class="type">float32</span> |  f2 := <span class="number">3.14</span> <span class="comment">//自动推导类型为64，因为更准确</span></span><br><span class="line">f1 = <span class="number">3.14</span>      |</span><br></pre></td></tr></table></figure></li><li><p>字符</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ch <span class="type">byte</span>  = <span class="number">97</span><span class="comment">//字符类型</span></span><br><span class="line">fmt.printf(<span class="string">&quot;%c, %d\n&quot;</span>, ch, ch) <span class="comment">// a, 97</span></span><br><span class="line"></span><br><span class="line">ch = <span class="string">&#x27;A&#x27;</span></span><br><span class="line">fmt.printf(<span class="string">&quot;%c, %d\n&quot;</span>, ch, ch) <span class="comment">//A, 65</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;大小写相差32，小写大&#x27;</span></span><br><span class="line">fmt.printf(<span class="string">&quot;大写转小写%c\n&quot;</span>, <span class="string">&#x27;A&#x27;</span> + <span class="number">32</span>)</span><br><span class="line">fmt.printf(<span class="string">&quot;小写转大写%c\n&quot;</span>, <span class="string">&#x27;a&#x27;</span> - <span class="number">32</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>字符串</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str1 <span class="type">string</span> |  str2 := <span class="string">&quot;mike&quot;</span>  | <span class="built_in">len</span>(str2) <span class="comment">//获得str2的长度</span></span><br><span class="line">str1 = <span class="string">&quot;abc&quot;</span></span><br></pre></td></tr></table></figure></li><li><p>字符与字符串区别</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//字符为单引号                     </span></span><br><span class="line"><span class="keyword">var</span> ch <span class="type">byte</span> = <span class="string">&#x27;a&#x27;</span>   </span><br><span class="line"></span><br><span class="line"> <span class="comment">//字符串为双引号(且字符串 = 一个或多个字符 + &#x27;\0&#x27;)</span></span><br><span class="line"><span class="keyword">var</span> str1 <span class="type">string</span> = <span class="string">&quot;abc&quot;</span>  <span class="comment">// abc + &#x27;\0&#x27;</span></span><br><span class="line"></span><br><span class="line">str1[<span class="number">0</span>], str1[<span class="number">1</span>]可以直接对某一个字符进行修改 </span><br></pre></td></tr></table></figure></li><li><p>虚数</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> t <span class="type">complex128</span> = <span class="number">2.1</span> + <span class="number">3.14i</span></span><br><span class="line">t2 := <span class="number">3.3</span> + <span class="number">4.4i</span></span><br><span class="line"><span class="built_in">real</span>(t2), <span class="built_in">imag</span>(t2) <span class="comment">//获得实部和虚部</span></span><br></pre></td></tr></table></figure><p><strong>格式化输出</strong></p></li><li><p>%d（整形）</p></li><li>%c（字符）</li><li>%s（字符串）</li><li>%f（浮点）</li><li>%v（自动匹配）</li></ul><p><strong>输入</strong><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fmt.Scanf(%d, &amp;a)</span><br><span class="line"><span class="string">&#x27;或者&#x27;</span></span><br><span class="line">fmt.Scan(&amp;a)</span><br></pre></td></tr></table></figure><br><strong>类型转换</strong></p><ul><li>只能是兼容类型之间可以进行转换</li><li>bool和整形之间不能互相转换</li><li><p>字符和整形之间可以转换</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ch <span class="type">byte</span> = <span class="string">&#x27;a&#x27;</span></span><br><span class="line"><span class="keyword">var</span> t <span class="type">int</span></span><br><span class="line">t = <span class="type">int</span>(ch) <span class="comment">// t = 97</span></span><br></pre></td></tr></table></figure><p><strong>类型别名</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> bigint <span class="type">int64</span></span><br><span class="line"><span class="keyword">var</span> a bigint = <span class="number">65</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> (</span><br><span class="line">    long <span class="type">int64</span></span><br><span class="line">    char <span class="type">byte</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">var</span> b long = <span class="number">11</span></span><br><span class="line"><span class="keyword">var</span> ch char = <span class="string">&#x27;a&#x27;</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;b = %d, ch = %c&quot;</span>, b, ch)</span><br></pre></td></tr></table></figure><p><strong>运算符</strong></p></li><li><p>go中只有a++,没有++a</p></li><li>0&lt;= a &amp;&amp; a &lt;= 10（正确） 0 &lt;= a &lt;= 10（错误，因为go中bool和整形不兼容）</li></ul><p><strong>if-else</strong><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> s == <span class="string">&#x27;小呆鸟&#x27;</span> &#123;  <span class="comment">//左括号和If在同一行</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;hahaha&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> a := <span class="number">10</span>; a == <span class="number">10</span>&#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;a == 10&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> a := <span class="number">8</span>; a == <span class="number">8</span>&#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;a==8&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> a &gt; <span class="number">8</span>&#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;a &gt; 8&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;a &lt; 8&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><strong>switch语句</strong><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> num := <span class="number">2</span>; num&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">    fmt.Println(<span class="string">&quot;1&quot;</span>)</span><br><span class="line">        <span class="comment">//break   go语言默认包含break，可以不用写</span></span><br><span class="line">        <span class="comment">//fallthrough 不跳出switch语句，后面的无条件执行</span></span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>, <span class="number">6</span>, <span class="number">7</span>:</span><br><span class="line">    fmt.Println(<span class="string">&quot;2&quot;</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">    fmt.Println(<span class="string">&quot;3&quot;</span>)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    fmt.Println(<span class="string">&quot;xxx&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;或者&#x27;</span></span><br><span class="line"></span><br><span class="line">score := <span class="number">99</span></span><br><span class="line"><span class="keyword">switch</span> &#123;   <span class="comment">//可以没有条件</span></span><br><span class="line"><span class="keyword">case</span> score &gt; <span class="number">90</span>:</span><br><span class="line">      fmt.Println(<span class="string">&quot;优秀&quot;</span>)</span><br><span class="line"> <span class="keyword">case</span> score &lt; <span class="number">90</span>:</span><br><span class="line">      fmt.Println(<span class="string">&quot;一般&quot;</span>)   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><strong>for 和 range(数组，切片等用到，go没有while和do…while语句)</strong><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;for&#x27;</span></span><br><span class="line">sum := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt;= <span class="number">100</span>; i ++&#123;</span><br><span class="line">    sum = sum + i</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;range&#x27;</span></span><br><span class="line">str := <span class="string">&quot;abc&quot;</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(str); i ++ &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;str[%d] = %c\n&quot;</span>, i, str[i])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i, date := <span class="keyword">range</span> str &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;str[%d] = %c\n&quot;</span>, i, date)</span><br><span class="line">&#125;</span><br><span class="line"><span class="string">&#x27;等价&#x27;</span></span><br><span class="line"><span class="keyword">for</span> i, _ := <span class="keyword">range</span> str &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;str[%d] = %c\n&quot;</span>, i, str[i])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><strong>break和continue</strong><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">i := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">    i ++</span><br><span class="line">    time.sleep(time.Second)</span><br><span class="line">    <span class="keyword">if</span> i == <span class="number">5</span>&#123;</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">        <span class="comment">//continue</span></span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(<span class="string">&quot;i = &quot;</span>, i)</span><br><span class="line">        </span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> goland </category>
          
      </categories>
      
      
        <tags>
            
            <tag> goland </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>goland函数</title>
      <link href="/2022/04/27/post7/"/>
      <url>/2022/04/27/post7/</url>
      
        <content type="html"><![CDATA[<h1 id="二、函数"><a href="#二、函数" class="headerlink" title="二、函数"></a>二、函数</h1><ul><li><p>无参无返回值</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">MyFunc</span><span class="params">()</span></span>&#123;</span><br><span class="line">    a := <span class="number">666</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;a =&quot;</span>, a)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    MyFunc</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>有参无返回值</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">MyFunc</span><span class="params">(a <span class="type">int</span>)</span></span>&#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;a = &quot;</span>,a)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">MyFunc1</span><span class="params">(a <span class="type">int</span>, b <span class="type">int</span>)</span></span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">MyFunc2</span><span class="params">(a, b <span class="type">int</span>)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">MyFunc3</span><span class="params">(a, b <span class="type">int</span>, c <span class="type">float64</span>, e <span class="type">int</span>)</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    MyFunc(<span class="number">666</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>不定参数类型</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//...int 类型这样的类型， ...type不定参数类型</span></span><br><span class="line"><span class="comment">//注意：不定参数，必须放到形参中的最后一个参数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">MyFunc1</span><span class="params">(args ...<span class="type">int</span>)</span></span>&#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;len(args) = &quot;</span>, args)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">MyFunc2</span><span class="params">(a <span class="type">int</span>, args ...<span class="type">int</span>)</span></span>&#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;len(args) = &quot;</span>, args)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">MyFunc3</span><span class="params">(args ...<span class="type">int</span>, a <span class="type">int</span>)</span></span>&#123;      <span class="comment">//错误</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;len(args) = &quot;</span>, args)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    MyFunc1()</span><br><span class="line">    MyFunc1(<span class="number">666</span>)</span><br><span class="line">    MyFunc(<span class="number">11</span>, <span class="number">22</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>不定参数传递</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">myFunc</span><span class="params">(tmp ...<span class="type">int</span>)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span> _, data := <span class="keyword">range</span> tmp &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;data = &quot;</span>, data)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">myFunc2</span><span class="params">(tmp ...<span class="type">int</span>)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span> _, data := <span class="keyword">range</span> tmp &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;data = &quot;</span>, data)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">(args ...<span class="type">int</span>)</span></span>&#123;</span><br><span class="line">   </span><br><span class="line">myFunc(args...)      <span class="comment">//全部元素传递给myFunc</span></span><br><span class="line">myFunc2(args[:<span class="number">2</span>]...) <span class="comment">//args[0]~args[2]（包含0，不包含数字2）,传递过去</span></span><br><span class="line">&#125;                        <span class="comment">//[0, 2)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">test(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>无参数有一个返回值</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">myFunc01</span><span class="params">()</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">666</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">myFunc01</span><span class="params">()</span></span> (result <span class="type">int</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">666</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">myFunc01</span><span class="params">()</span></span> (result <span class="type">int</span>) &#123;</span><br><span class="line">    result = <span class="number">666</span></span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>无参数有多个返回值</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">myFunc01</span><span class="params">()</span></span> (<span class="type">int</span>, <span class="type">int</span>, <span class="type">int</span>)&#123; <span class="keyword">return</span> <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">myFunc02</span><span class="params">()</span></span> (a <span class="type">int</span>, b <span class="type">int</span>, c <span class="type">int</span>)&#123;</span><br><span class="line">    a, b, c = <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span></span><br><span class="line">    <span class="keyword">return</span> </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    a, b, c := myfunc02()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>有参有返回值的</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">MaxAndMin</span><span class="params">(a, b <span class="type">int</span>)</span></span> (max, min <span class="type">int</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> a &gt; b &#123;</span><br><span class="line">        max = a</span><br><span class="line">        min = b</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        max = b</span><br><span class="line">        min = a</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    max, min := MaxAndMin(<span class="number">10</span>, <span class="number">20</span>)</span><br><span class="line">    max, _ := MaxAndMin(<span class="number">10</span>, <span class="number">20</span>)   <span class="comment">//匿名变量丢弃某个返回值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>递归（结果：c = 1 b = 2 a = 3 main）</p></li></ul><p><img src="https://cdn.nlark.com/yuque/0/2023/png/29618862/1679390361802-32f2f9e6-66f9-4c86-b9c0-694ccfed051a.png#averageHue=%23fbfbfb&amp;clientId=ud8920060-c3f2-4&amp;from=paste&amp;height=351&amp;id=u52e6a0ab&amp;originHeight=527&amp;originWidth=1166&amp;originalType=binary&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;size=237608&amp;status=done&amp;style=none&amp;taskId=u3378062d-0525-4ce9-a8e8-e3018828dd3&amp;title=&amp;width=777.3333333333334" alt="1679390356039.png"><br /><img src="https://cdn.nlark.com/yuque/0/2023/png/29618862/1679390515290-f9393eca-2538-4679-b4a3-e6d400cc18d9.png#averageHue=%23fcfcfc&amp;clientId=ud8920060-c3f2-4&amp;from=paste&amp;height=351&amp;id=u20fa9b9f&amp;originHeight=527&amp;originWidth=1177&amp;originalType=binary&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;size=213825&amp;status=done&amp;style=none&amp;taskId=u25a19a16-83c3-4678-b8a8-f4ac1b61e96&amp;title=&amp;width=784.6666666666666" alt="1679390506371.png"><br><a name="rhNN3"></a></p>]]></content>
      
      
      <categories>
          
          <category> goland </category>
          
      </categories>
      
      
        <tags>
            
            <tag> goland </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统概述</title>
      <link href="/2022/04/26/post5/"/>
      <url>/2022/04/26/post5/</url>
      
        <content type="html"><![CDATA[<blockquote><p>💛本文摘要💛</p><p><strong><code>操作系统系列文章</code></strong><br><a href="https://blog.csdn.net/weixin_45043334/article/details/126274844">1. 操作系统—概述</a><br><a href="https://blog.csdn.net/weixin_45043334/article/details/126293098">2. 操作系统—中断、异常、系统调用</a><br><a href="https://blog.csdn.net/weixin_45043334/article/details/126353734">3. 操作系统—物理内存管理</a><br><a href="https://blog.csdn.net/weixin_45043334/article/details/126360202">4. 操作系统—非连续内存分配</a><br><a href="https://blog.csdn.net/weixin_45043334/article/details/126378112">5. 虚拟内存管理</a><br><a href="https://blog.csdn.net/weixin_45043334/article/details/126398876">6. 操作系统—虚拟内存管理技术页面置换算法</a><br><a href="https://blog.csdn.net/weixin_45043334/article/details/126426025">7. 进程管理</a><br><a href="https://blog.csdn.net/weixin_45043334/article/details/126451433">8. 调度算法</a><br><a href="https://blog.csdn.net/weixin_45043334/article/details/126477243">9. 同步与互斥</a><br><a href="https://blog.csdn.net/weixin_45043334/article/details/126533681">10. 信号量和管程</a><br><a href="https://blog.csdn.net/weixin_45043334/article/details/126624006">11. 死锁和进程通信</a><br><a href="https://blog.csdn.net/weixin_45043334/article/details/126652312">12. 文件系统管理</a></p></blockquote><h2 id="🐋1-介绍"><a href="#🐋1-介绍" class="headerlink" title="🐋1.介绍"></a>🐋1.介绍</h2><ul><li>基本概述及原理</li><li>操作系统介绍</li><li>中断及系统调用</li><li>内存管理</li><li>进程及线程</li><li>调度</li><li>同步</li><li>文件系统</li><li><p>I/O子系统</p><h2 id="🐋2-什么是操作系统"><a href="#🐋2-什么是操作系统" class="headerlink" title="🐋2. 什么是操作系统"></a>🐋2. 什么是操作系统</h2><p><code>用户角度：操作系统是一个控制软件</code></p></li><li><p>管理应用程序</p></li><li>为应用程序提供服务</li><li>杀死应用程序</li></ul><p><code>程序角度：操作系统是资源管理器</code></p><ul><li>管理外设、分配资源</li><li>抽象<ul><li>将CPU抽象成进程</li><li>将磁盘抽象成文件</li><li>将内存抽象成地址空间</li></ul></li></ul><p><img src="https://img-blog.csdnimg.cn/70430656a04e41788f72eca0872d03d7.png" alt="在这里插入图片描述"></p><h3 id="🐻2-1-操作系统层次"><a href="#🐻2-1-操作系统层次" class="headerlink" title="🐻2.1 操作系统层次"></a>🐻2.1 操作系统层次</h3><ul><li>位于硬件之上，应用程序之下。</li></ul><h3 id="🐻2-2-操作系统的界面和内核"><a href="#🐻2-2-操作系统的界面和内核" class="headerlink" title="🐻2.2 操作系统的界面和内核"></a>🐻2.2 操作系统的界面和内核</h3><ul><li>Linux Windows Android 的界面属于外壳(Shell) ，而不是内核(kernel)。操作系统研究的是内核，处于Shell之下。</li></ul><h3 id="🐻2-3-操作系统内部组件"><a href="#🐻2-3-操作系统内部组件" class="headerlink" title="🐻2.3 操作系统内部组件"></a>🐻2.3 操作系统内部组件</h3><ul><li>CPU调度器</li><li>物理内存管理</li><li>虚拟内存管理</li><li>文件系统管理</li><li>中断处理与设备驱动</li></ul><p><img src="https://img-blog.csdnimg.cn/f1a152b057074ddc8cb63e242a335222.png" alt="在这里插入图片描述"></p><p><strong>cpu:</strong> 主要是cpu的调度和进程线程的管理</p><p><strong>内存：</strong> 物理内存和虚拟内存，物理内存就是实际的内存，<code>虚拟内存为应用提供一个相对独立的空间（在有限的物理内存之上，虚拟出一个更大的，更安全的环境）</code></p><p><strong>文件：</strong> disk是以磁盘块作为一个读写的基本单位，访问比较底层不方便，于是在上面抽象成文件。</p><p><strong>中断处理：</strong> 它是直接与底层硬件交流</p><h3 id="🐻2-4操作系统特征"><a href="#🐻2-4操作系统特征" class="headerlink" title="🐻2.4操作系统特征"></a>🐻2.4操作系统特征</h3><ul><li><code>并发</code><ul><li>一段时间内运行多个进程（并行 : 一个时间点运行多个进程，一般要求有多个CPU)</li><li>需要OS管理和调度</li></ul></li><li><code>共享</code><ul><li>“同时”共享</li><li>互斥共享</li></ul></li><li><code>虚拟</code><ul><li>利用多道程序设计技术，让每一个用户觉得的有一个计算机专门为他服务</li></ul></li><li><code>异步</code><ul><li>程序是走走停停，而不是一直运行，<code>但是不管怎么走，只要运行环境相同，os要保证运行的结果也相同</code></li></ul></li></ul><h2 id="🐋3-操作系统历史"><a href="#🐋3-操作系统历史" class="headerlink" title="🐋3. 操作系统历史"></a>🐋3. 操作系统历史</h2><ol><li>早起计算机使用纸带传输程序和数据，os只起到加载作用</li><li><p>批处理阶段（一个程序一个程序的运行，每次都需要从外面导入程序）<br><img src="https://img-blog.csdnimg.cn/fde74b67bc9447e4bdc7d7bf55234b63.png" alt="在这里插入图片描述"></p></li><li><p>CPU执行多个程序。此时不需要将要跑的程序，从磁盘放到内存中，大大减少IO的开销（直接全部都放到内存中）<br><img src="https://img-blog.csdnimg.cn/cb79d79ae0e746ccbdaeeeaf9e475d2a.png" alt="在这里插入图片描述"></p></li><li>当一个程序运行阶段，可能要进行IO操作，此时时间非常长，这时就可以运行另一个程序，当程序1完成IO操作后，就进行中断，停止程序25，继续进行程序1</li></ol><p><img src="https://img-blog.csdnimg.cn/91dfef316f9d48a6b419acc491524a22.png" alt="在这里插入图片描述"></p><ol><li>提高交互性，上述的操作不需要人参与，交互性差，此时出现<code>分时系统</code>（通过分时使得不同的程序都有时间去执行工作。），目前计算机是1/1000秒产生一次分时。<code>（而分时主要靠时钟定期产生中断）</code></li></ol><p><img src="https://img-blog.csdnimg.cn/9646aacbec274d6c9e3303cbf9f48dee.png" alt="在这里插入图片描述"></p><ol><li>多核CPU</li><li>分布式操作系统<br><img src="https://img-blog.csdnimg.cn/d09de21a423241898bf6a98ef0690a90.png" alt="在这里插入图片描述"></li></ol><h2 id="🐋4-操作系统结构"><a href="#🐋4-操作系统结构" class="headerlink" title="🐋4. 操作系统结构"></a>🐋4. 操作系统结构</h2><p><strong>MS-DOS</strong></p><ul><li>不分模块的单体内核（<code>单体意味着通过函数调用实现（紧耦合）</code>）</li></ul><p><strong>微内核</strong></p><ul><li>尽可能把内核功能移动到用户空间<code>（在操作系统内核中放基本功能（松耦合），其他的文件系统，内存管理等都放在外面以进程形式存在，进程与进程之间通过内核消息传递进制进行通信）</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker概述</title>
      <link href="/2022/04/25/post4/"/>
      <url>/2022/04/25/post4/</url>
      
        <content type="html"><![CDATA[<blockquote><p>💛本文摘要💛<br>Docker系列文章：<br>一、<a href="https://blog.csdn.net/weixin_45043334/article/details/125243499">Docker概述</a><br>二、<a href="https://blog.csdn.net/weixin_45043334/article/details/125243542">Docker安装大全</a><br>三、<a href="https://blog.csdn.net/weixin_45043334/article/details/125243581">Docker 命令大全</a><br>四、<a href="https://blog.csdn.net/weixin_45043334/article/details/125262867">Docker容器部署</a><br>五、<a href="https://blog.csdn.net/weixin_45043334/article/details/125263703">Docker镜像详解</a><br>六、<a href="https://blog.csdn.net/weixin_45043334/article/details/125264727">Docker容器卷详解</a><br>七、 <a href="https://blog.csdn.net/weixin_45043334/article/details/125283158">Dockerfile详解</a><br>八、<a href="https://blog.csdn.net/weixin_45043334/article/details/125304543">Docker网路模式详解</a><br>笔记总结：<a href="https://www.bilibili.com/video/BV1og4y1q7M4?p=40&amp;vd_source=620a01017393bc61d7394b3dc716212d">https://www.bilibili.com/video/BV1og4y1q7M4</a><br>可面试可复习</p><h1 id="docker-概述"><a href="#docker-概述" class="headerlink" title="docker 概述"></a>docker 概述</h1><h2 id="🐳1-Docker-概述"><a href="#🐳1-Docker-概述" class="headerlink" title="🐳1. Docker 概述"></a>🐳1. Docker 概述</h2></blockquote><p>Docker 是一个基于go语言开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的<code>镜像</code>中，然后发布到任何流行的 <code>Linux</code>或<code>Window</code>操作系统的机器上，也可以实现<code>虚拟化</code>。容器是完全使用<code>沙箱</code>机制，相互之间不会有任何接口。</p><p><strong>一个完整的Docker有以下几个部分组成：</strong></p><ul><li><p>DockerClient客户端</p></li><li><p>Docker Daemon守护进程</p></li><li><p>Docker Image镜像</p></li><li><p>DockerContainer容器 </p></li></ul><h2 id="🐳2-Docker的出现"><a href="#🐳2-Docker的出现" class="headerlink" title="🐳2. Docker的出现"></a>🐳2. Docker的出现</h2><p>一款产品：开发—&gt;上线 俩套环境，应用配置！</p><p><strong>开发与运维的爱恨纠缠</strong>：我开发好的程序，放到别人的电脑上，就是运行不了（各种问题，要么缺少配置，要么缺少依赖，要么缺少库），可能还会遇到，版本更新，导致服务不可用！对于运维人来说，巨大考验。</p><p><strong>环境配置是一件非常头疼的事</strong>：</p><ul><li><p>每一个集群都要部署环境（redis、ES、Hadoop）</p></li><li><p>发布一个项目(jar+(Redis + MySQL + jdk + ES)),项目不能带上环境打包。</p></li><li><p>在服务器配置的一个应用环境Redis、MySQL、jdk、ES、Hadoop,配置麻烦，不能跨平台。</p></li></ul><p><img src="https://img-blog.csdnimg.cn/dda6ca47b4d242dc865746269a0379ea.png" alt="在这里插入图片描述"></p><h3 id="🐙Docker作用"><a href="#🐙Docker作用" class="headerlink" title="🐙Docker作用"></a>🐙Docker作用</h3><p>Docker为了解决上述问题</p><p>java — apk —发布（应用商店）— 小呆鸟使用apk — 安装即可</p><p>java —jar(环境) —- 打包项目带上环境（镜像）—- （Docker仓库：商店）— 下载我们发布的镜像 — 直接运行即可。</p><p><img src="https://img-blog.csdnimg.cn/aaafb15a9de64a49b7ad2028821e095f.png" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/8699fcd5329f4db4925dbbb024d698cc.png" alt="在这里插入图片描述"></p><h3 id="🐙Docker思想"><a href="#🐙Docker思想" class="headerlink" title="🐙Docker思想"></a>🐙Docker思想</h3><ul><li>它来自于集装箱！</li><li>隔离：Docker的核心思想！将每个软件及依赖打包装箱，每一个箱子都是互相隔离的。</li><li>在一条船上，有俩个箱子，一个是水果，一个是生化武器。docker就是使得这俩个箱子隔离，互不干扰。</li></ul><h3 id="🐙Docker-VS-虚拟机"><a href="#🐙Docker-VS-虚拟机" class="headerlink" title="🐙Docker VS 虚拟机"></a>🐙Docker VS 虚拟机</h3><ul><li>虚拟机：在windows 中装一个Vmware,通过这个软件可以虚拟出来一台或者多台电脑！笨重！</li><li>虚拟机属于虚拟化技术，Docker容器技术，也是一种虚拟化技术</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vmware :linux centos原生镜像(虚拟出一台电脑) 隔离，需要开启多个虚拟机！    几个G   几分钟</span><br><span class="line">docker :隔离，镜像（最核心环境 4m + jdk + mysql）十分小巧，运行镜像就可以！ 几个M或者KB 秒级</span><br></pre></td></tr></table></figure><h2 id="🐳3-Docker能做什么"><a href="#🐳3-Docker能做什么" class="headerlink" title="🐳3. Docker能做什么"></a>🐳3. Docker能做什么</h2><h3 id="🐙虚拟机技术"><a href="#🐙虚拟机技术" class="headerlink" title="🐙虚拟机技术"></a>🐙虚拟机技术</h3><p><img src="https://img-blog.csdnimg.cn/56fa1259d672483ab7d6e40f7825d834.png" alt="在这里插入图片描述"></p><p><strong>虚拟机技术缺点：</strong></p><ol><li>资源占用十分多（一个虚拟机占用20G）</li><li>冗余步骤多</li><li>启动非常慢</li></ol><h3 id="🐙Docker容器化技术"><a href="#🐙Docker容器化技术" class="headerlink" title="🐙Docker容器化技术"></a>🐙Docker容器化技术</h3><p><code>容器化技术不是模拟一个完整的操作系统</code>：例如你打开了一个虚拟机，里面装有linux系统，打开后，里面会有一些自带的浏览器，一些插件，但是docker里面什么也没有。</p><p><img src="https://img-blog.csdnimg.cn/4c2b8d67a8974eda93c8fa563faf4c49.png" alt="在这里插入图片描述"></p><h3 id="🐙Docker-和虚拟机技术的不同"><a href="#🐙Docker-和虚拟机技术的不同" class="headerlink" title="🐙Docker 和虚拟机技术的不同"></a>🐙Docker 和虚拟机技术的不同</h3><ul><li>传统的虚拟机，虚拟机一个硬件，运行一个完整的操作系统，然后再这个系统上安装和运行软件。</li><li>容器内的应用直接运行在宿主主机，容器是没有自己的内核的，也没有虚拟我们的硬件，所以轻便</li><li>每个容器是相互隔离，每个容器内部都有一个属于自己的文件系统，互不影响。</li></ul><h3 id="🐙DevOps-开发、运维"><a href="#🐙DevOps-开发、运维" class="headerlink" title="🐙DevOps(开发、运维)"></a>🐙DevOps(开发、运维)</h3><p><strong>应用更快速的交付和部署</strong></p><ul><li><p>传统： 一堆帮助文档，安装程序</p></li><li><p>Docker: 打包镜像发布测试，一键运行</p></li></ul><p><strong>更便捷的升级和扩缩容</strong></p><ul><li><p>使用了Docker之后，我们的部署应用就和搭积木一样！项目打包为一个镜像，扩展 服务器A ! 服务器B</p></li><li><p>传统 ：我要升级APP（redia, mysql, tomcat），此时我要把mysql,redis等APP需要的软件，都要升级</p></li><li>Docker: 我只需要把这个镜像升级一下。(把（redia, mysql, tomcat）做成一个镜像)。</li></ul><p><strong>更简单的系统运维</strong></p><ul><li>在容器化之后，我们的开发，测试环境都是高度一致的</li></ul><p><strong>更高效的计算资源利用</strong></p><ul><li>Docker 是内核级别的虚拟化，可以在一个物理机上运行很多容器实例！ 服务器的性能可以极大提高</li></ul><h2 id="🐳4-Docker名词概念"><a href="#🐳4-Docker名词概念" class="headerlink" title="🐳4. Docker名词概念"></a>🐳4. Docker名词概念</h2><p><img src="https://img-blog.csdnimg.cn/b83c64a2df8847468430e6e78500d37c.png" alt="在这里插入图片描述"></p><h3 id="🐙镜像-image"><a href="#🐙镜像-image" class="headerlink" title="🐙镜像(image):"></a>🐙镜像(image):</h3><p>docker镜像就好比一个模板(class类)，可以通过这个模板来创建容器服务(根据class类，来创建对象)， tomcat镜像==&gt;  run ==&gt; tomcat01容器 （提供服务）。</p><h3 id="🐙容器：-container"><a href="#🐙容器：-container" class="headerlink" title="🐙容器：(container)"></a>🐙容器：(container)</h3><p>Docker利用容器技术，独立运行一个或者一组应用，通过镜像来创建</p><p>启动、停止、删除、基本命令！</p><h3 id="🐙仓库-repository"><a href="#🐙仓库-repository" class="headerlink" title="🐙仓库(repository):"></a>🐙仓库(repository):</h3><p>仓库就是存放镜像的地方！</p><p>仓库分为公有仓库和私有仓库！</p><p>Docker Hub(默认是国外的)</p><p>阿里云等都有容器服务器（配置镜像加速！）</p><p><strong>流程</strong>:用客户端来启动Docker里面的一个容器，这个容器要去服务器上下载。</p>]]></content>
      
      
      <categories>
          
          <category> 云原生 </category>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 云原生 </tag>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c++字符串、向量和数组</title>
      <link href="/2022/04/24/post3/"/>
      <url>/2022/04/24/post3/</url>
      
        <content type="html"><![CDATA[<blockquote><p>💛本文摘要💛</p><p>&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;</p><p><strong><code>c++  系列文章</code></strong></p><p><a href="https://blog.csdn.net/weixin_45043334/article/details/125380065">第2章 变量和基本类型</a><br><a href="https://blog.csdn.net/weixin_45043334/article/details/125402340">第3章 字符串、向量和数组</a><br><a href="https://blog.csdn.net/weixin_45043334/article/details/125449009">第4章 表达式</a><br><a href="https://blog.csdn.net/weixin_45043334/article/details/125647293">第5章 语句</a><br><a href="https://blog.csdn.net/weixin_45043334/article/details/125751253">第6章 函数</a><br><a href="https://blog.csdn.net/weixin_45043334/article/details/125850838">第8章 IO库</a><br><a href="https://blog.csdn.net/weixin_45043334/article/details/125947865">第9章 顺序容器</a><br><a href="https://blog.csdn.net/weixin_45043334/article/details/126002739">第10章 泛型算法</a><br><a href="https://blog.csdn.net/weixin_45043334/article/details/126246260">第11章 关联容器</a><br><a href="https://blog.csdn.net/weixin_45043334/article/details/126297355">第12章 动态内存</a><br><a href="https://blog.csdn.net/weixin_45043334/article/details/126394732">第13章 拷贝控制</a><br><a href="https://blog.csdn.net/weixin_45043334/article/details/126679427">第 14章 重载运算符</a><br><a href="https://blog.csdn.net/weixin_45043334/article/details/126728175?spm=1001.2014.3001.5502">第15章 面向对象程序设计</a><br><a href="https://blog.csdn.net/weixin_45043334/article/details/126808177">第 16章 模板与泛型编程</a></p><h1 id="🍇第3章-字符串、向量和数组"><a href="#🍇第3章-字符串、向量和数组" class="headerlink" title="🍇第3章 字符串、向量和数组"></a>🍇第3章 字符串、向量和数组</h1><p>String、vector是俩种最重要的标准库类型，String支持<code>可变长字符串</code>,vector支持<code>可变长的集合</code></p></blockquote><p>迭代器是一种与 string 和 vector 配套的标准库类型。常用于访问string中的字符或vector中的元素</p><p>内置数组是一种基础的类型，string和vector都是对它的某种抽象。</p><h2 id="🍌3-1-命名空间的-using-声明"><a href="#🍌3-1-命名空间的-using-声明" class="headerlink" title="🍌3.1 命名空间的 using 声明"></a>🍌3.1 命名空间的 using 声明</h2><ul><li>使用某个命名空间：例如 using std::cin表示使用命名空间std中的名字cin。</li><li>头文件中不应该包含using声明。这样使用了该头文件的源码也会使用这个声明，对于某些程序来说，可能会名字冲突，带来风险。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">using <span class="built_in">std</span>::<span class="built_in">cin</span>;</span><br></pre></td></tr></table></figure></li></ul><h2 id="🍌3-2-标准库类型string"><a href="#🍌3-2-标准库类型string" class="headerlink" title="🍌3.2 标准库类型string"></a>🍌3.2 标准库类型string</h2><ul><li>标准库类型string表示可变长的字符序列。</li><li>string定义在命名空间std中。<code>(包含头文件)</code></li><li>string对象：不同于字符串字面值。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line">using <span class="built_in">std</span>::<span class="built_in">string</span></span><br></pre></td></tr></table></figure><h3 id="🍑3-2-1-定义和初始化string对象"><a href="#🍑3-2-1-定义和初始化string对象" class="headerlink" title="🍑3.2.1 定义和初始化string对象"></a>🍑3.2.1 定义和初始化string对象</h3><p>string 默认初始化是一个空字符串<br>初始化<code>string</code>对象的方式：</p><div class="table-container"><table><thead><tr><th>初始化方式</th><th>解释</th></tr></thead><tbody><tr><td>string s1</td><td>默认初始化，s1 是个空字符串</td></tr><tr><td>string s2(s1)</td><td>s2 是 s1 的副本</td></tr><tr><td>string s2 = s1</td><td>等价于 s2( s1 )，s2 是 s1 的副本</td></tr><tr><td>string s3(“value”)</td><td>s3 是字面值 “value” 的副本，除了字面值最后的那个空字符外</td></tr><tr><td>string s3 = “value”</td><td>等价于 s3(“value”)，s3 是字面值 “value” 的副本</td></tr><tr><td>string s4(n, ‘c’)</td><td>把 s4 初始化为由连续 n 个字符 c 组成的串</td></tr></tbody></table></div><p>注意：</p><ul><li>在进行拷贝操作时，是不包含最后一个空字符串的</li><li>使用字符串字面值或字符数组初始化 string 对象时，string 对象中是不包含末尾的空字符的，它会将字符数组中末尾的空字符去掉。</li></ul><p><strong>初始化方式</strong></p><ul><li>拷贝初始化</li><li>直接初始化</li><li>列表初始化<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> s5 = <span class="string">&quot;hello&quot;</span>;           <span class="comment">//拷贝初始化</span></span><br><span class="line"><span class="built_in">string</span> <span class="title function_">s6</span><span class="params">(<span class="string">&quot;hello&quot;</span>)</span>;            <span class="comment">//直接初始化</span></span><br><span class="line"><span class="built_in">string</span> s7&#123;hello&#125;;              <span class="comment">//列表初始化</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="🍑3-2-2-string对象上的操作"><a href="#🍑3-2-2-string对象上的操作" class="headerlink" title="🍑3.2.2 string对象上的操作"></a>🍑3.2.2 string对象上的操作</h3><p><strong>string 常用操作</strong><br>|    <strong>string 常用操作</strong>             |         |<br>| —————————— | —————————————————————————————— |<br>| getline(is, s)     | 从is中读取一行赋给s，返回is       (is 是输入流)                     |<br>| s.empty()          | s 为空返回true，否则返回false                           |<br>| s.size()        | 返回 s 中字符的个数                                          |<br>| s[n]              | 返回 s 中第 n 个字符的引用，位置 n 从0计起                   |<br>| s1+s2              | 返回 s1 和 s2 连接后的结果                                   |<br>| s1=s2              | 用 s2 的副本代替 s1 中原来的字符                             |<br>| s1==s2            | 如果 s1 和 s2 中所含的字符完全一样，则它们相等；string对象的相等性判断对字母的大小写敏感 |<br>| s1!=s2            | 同上                                                         |<br>| &lt;, &lt;=, &gt;, &gt;= | 利用字符在字典中的顺序进行比较，且对字母的大小写敏感（对第一个不相同的位置进行比较） |</p><p><code>注意</code>:</p><ul><li>通过<code>cin &gt;&gt; string</code>,在读取string对象时，string对象会自动忽略开头的空白（空格、换行符、等）并从第一个真正的字符串开始读，知道遇见下一个空白为止，因此不能使用 <code>cin 读取句子</code>，但是可以<code>读取单词</code>；</li><li>字符串字面值与 string 是两种不同的类型<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> s;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; s;             <span class="comment">//输入hello world</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; s &lt;&lt; <span class="built_in">endl</span>;    <span class="comment">//输出为hello</span></span><br><span class="line"> </span><br></pre></td></tr></table></figure></li></ul><p><strong>读写string对象</strong></p><p>使用<code>cin</code> 和 <code>cout</code>来读写string对象</p><p><strong>使用getline 函数读取一行</strong></p><ul><li><code>getline()</code>函数定义在<code>头文件string</code>中</li><li>getline()参数是一个输入流和一个string对象，函数从给定的输入流中读取内容，知道遇到换行符位置（<code>注意是换行符和上面空白字符不一样</code>）</li><li>读取到文件末尾结束<br><code>注意</code>:getline 会将换行符也读入，但是不将换行符存入 string 对象。触发 getline() 函数返回的那个换行符实际上被丢弃掉了。得到的string对象中不包含换行符。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> s;                <span class="comment">//读取到文件末尾结束</span></span><br><span class="line"><span class="keyword">while</span>(getline(<span class="built_in">cin</span>, s))   <span class="comment">//输入为hello world</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; s &lt;&lt; <span class="built_in">endl</span>;     <span class="comment">//输出为hello world</span></span><br></pre></td></tr></table></figure></li></ul><p><strong>string::size_type 类型</strong></p><ul><li>string 中的size() 返回值类型是<code>string:: size_type</code></li><li>string::size_type是一个无符号值，能够存下任何string对象的大小，所以用于存放string类的size函数返回值的变量，都应该是string::size_type类型的</li><li>c++11规定允许使用<code>auto</code>和 <code>declltype</code>来获取此类型</li><li>在具体使用时，通过作用域操作符来表明 size_type 是在类 string 中定义的。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> len = s.size();<span class="comment">// len 的类型是 string::size_type</span></span><br></pre></td></tr></table></figure></li></ul><p><code>注意：</code>在一条表达式中已经有了size()函数，就不要使用int了，这样可以避免混用int 和 unsigned可能会带来问题。</p><p><strong>俩个string对象相加</strong></p><ul><li>俩个string对象相加得到一个新的string对象，其内容是把左侧的运算符对象与右侧的运算符对象串接而成<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> s1 = <span class="string">&quot;hello,&quot;</span>;</span><br><span class="line"><span class="built_in">string</span> s2 = <span class="string">&quot;world&quot;</span>;</span><br><span class="line"><span class="built_in">string</span> s3 = s1 + s2;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; s3 &lt;&lt; <span class="built_in">endl</span>;   <span class="comment">//hello,world</span></span><br></pre></td></tr></table></figure></li></ul><p><strong>字面值和string对象相加</strong></p><ul><li><code>切记字面值和string是不一样的</code></li><li>字面值分为：字符字面值和字符串字面值</li></ul><p><strong>俩个string对象相加</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> s1 = <span class="string">&quot;hello,&quot;</span>;</span><br><span class="line"><span class="built_in">string</span> s2 = <span class="string">&quot;world&quot;</span>;</span><br><span class="line"><span class="built_in">string</span> s3 = s1 + s2;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; s3 &lt;&lt; <span class="built_in">endl</span>;   <span class="comment">//hello,world</span></span><br></pre></td></tr></table></figure></p><p><strong>string对象和字符字面值相加</strong></p><ul><li>当把string对象和字符字面值混在一起的时候，必须保证每个加法运算（+）的俩侧的运算对象<code>至少有一个是string</code><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> s4 = s1 + <span class="string">&quot;,&quot;</span>               <span class="comment">//正确，左侧为string对象，右侧为字符字面值</span></span><br><span class="line"><span class="built_in">string</span> s5 = <span class="string">&quot;hello&quot;</span> + <span class="string">&quot;,&quot;</span>          <span class="comment">//错误，左右俩侧都是字符字面值</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> s6 = s1 + <span class="string">&quot;,&quot;</span> + <span class="string">&quot;world&quot;</span>     <span class="comment">//正确</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> s7 = <span class="string">&quot;hello&quot;</span> + <span class="string">&quot;,&quot;</span> + s1     <span class="comment">//错误，俩个字面值不能相加</span></span><br><span class="line"><span class="comment">//等价于string s7 = (&quot;hello&quot; + &quot;,&quot;) + s1</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="🍑3-2-3-处理string对象中的字符"><a href="#🍑3-2-3-处理string对象中的字符" class="headerlink" title="🍑3.2.3 处理string对象中的字符"></a>🍑3.2.3 处理string对象中的字符</h3><p>cctype 头文件中有下列标准库函数来处理 string 中的字符。<br>| cctype头文件中的函数            |                   解释                                   |<br>| ——————- | —————————————————————————————— |<br>| <code>isalnum(c)</code>  | 当<code>c</code>是字母或数字时为真                                      |<br>| <code>isalpha(c)</code>  | 当<code>c</code>是字母时为真                                            |<br>| <code>iscntrl(c)</code>  | 当<code>c</code>是控制字符时为真                                        |<br>| <code>isdigit(c)</code>  | 当<code>c</code>是数字时为真                                            |<br>| <code>isgraph(c)</code>  | 当<code>c</code>不是空格但可以打印时为真                                |<br>| <code>islower(c)</code>  | 当<code>c</code>是小写字母时为真                                        |<br>| <code>isprint(c)</code>  | 当<code>c</code>是可打印字符时为真                                      |<br>| <code>ispunct(c)</code>  | 当<code>c</code>是标点符号时为真                                        |<br>| <code>isspace(c)</code>  | 当<code>c</code>是空白时为真（空格、横向制表符、纵向制表符、回车符、换行符、进纸符） |<br>| <code>isupper(c)</code>  | 当<code>c</code>是大写字母时为真                                        |<br>| <code>isxdigit(c)</code> | 当<code>c</code>是十六进制数字时为真                                    |<br>| <code>tolower(c)</code>  | 当<code>c</code>是大写字母，输出对应的小写字母；否则原样输出<code>c</code>         |<br>| <code>toupper(c)</code>  | 当<code>c</code>是小写字母，输出对应的大写字母；否则原样输出<code>c</code>         |</p><p><code>建议</code>：使用 c++ 版本的标准库头文件，即 cname 而非 name.h 类型的头文件。cname 头文件中的名字都从属于命名空间 std；</p><p><strong>范围for循环</strong></p><ul><li>for (auto c : str)</li><li>for (auto &amp;c : str)  </li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> <span class="title function_">str</span><span class="params">(<span class="string">&quot;hello world&quot;</span>)</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> c:str)         <span class="comment">// 对于str中的每个字符</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; c &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">// 输出当前字符，后面紧跟一个换行符 hello world</span></span><br></pre></td></tr></table></figure><ul><li>当要<code>改变 string 对象中的值</code>时，需要把循环变量定义成<code>引用类型</code>。必须通过显示添加 &amp; 符号来声明引用类型。</li><li>不能在范围 for 语句中改变所遍历序列的大小。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> &amp;c:s)</span><br><span class="line">    c = <span class="built_in">toupper</span>(c);     <span class="comment">// 小写转换为大写</span></span><br></pre></td></tr></table></figure></li></ul><p><strong>访问string中的某一个字符，有俩种方式 1. 可以通过[ ]， 2.可以通过迭代器</strong></p><ul><li>s[0] 表示第一个字符</li><li>s[size() - 1] 表示最后一个字符</li><li>string对象的下标是从 0 开始到 size() - 1 结束</li><li>索引必须大于等于 0 小于 size，使用索引前最好用 if(!s.empty()) 判断一下字符串是否为空。</li><li>任何表达式只要是整型值就可以作为索引。索引是无符号类型 size_type；</li></ul><h2 id="🍌3-3-标准库类型-vector"><a href="#🍌3-3-标准库类型-vector" class="headerlink" title="🍌3.3 标准库类型 vector"></a>🍌3.3 标准库类型 vector</h2><ul><li>vector 是一个<code>类模板</code>而非类型，vector<int>是一个类型。</li><li>vector同时也是一个<code>容器</code>，可以容纳各种数据类型</li><li>本身是一个类模板，但是可以实例化出一个类</li></ul><h3 id="🍑3-3-1-定义和初始化vector对象"><a href="#🍑3-3-1-定义和初始化vector对象" class="headerlink" title="🍑3.3.1 定义和初始化vector对象"></a>🍑3.3.1 定义和初始化vector对象</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span> &lt;<span class="type">int</span>&gt;  v1;                 <span class="comment">//vector默认初始化是一个0.</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title function_">v2</span><span class="params">(v1)</span>;            <span class="comment">// v2=v1</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; v2 = v1;           <span class="comment">//等价于v2(v1)</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title function_">v3</span><span class="params">(<span class="number">10</span>,<span class="string">&quot;dainian&quot;</span>)</span>;  <span class="comment">// 10个string</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title function_">v4</span><span class="params">(<span class="number">10</span>)</span>;            <span class="comment">// 10个空string</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; v5&#123;<span class="string">&quot;a&quot;</span>,<span class="string">&quot;hahah&quot;</span>&#125;;    <span class="comment">// 列表初始化</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; v5 = &#123;<span class="string">&quot;a&quot;</span>,<span class="string">&quot;hahah&quot;</span>&#125;; <span class="comment">//等价上面</span></span><br></pre></td></tr></table></figure><p><strong>列表初始化</strong></p><ul><li>使用一对<code>&#123;&#125;</code>来表示列表初始化，初始化过程会尽量把花括号内的值当作一个初始值列表来处理。</li><li>如果花括号内的值不能用来列表初始化，比如对一个 string 的 vector 初始化，但是花括号内的值为整型<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; v &#123;<span class="number">10</span>&#125;;              <span class="comment">// v 有 10 个默认初始化的元素</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; v &#123;<span class="number">10</span>, <span class="string">&quot;hello&quot;</span>&#125;;  <span class="comment">// v 有 10 个值为 &quot;hi&quot; 的元素</span></span><br></pre></td></tr></table></figure><strong>值初始化</strong></li></ul><p>如果vector 对象的元素是内置类型，比如int 则元素初始值为0，如果是类类型，则由类默认初始化。</p><h3 id="🍑3-3-2-像vector对象中添加元素"><a href="#🍑3-3-2-像vector对象中添加元素" class="headerlink" title="🍑3.3.2 像vector对象中添加元素"></a>🍑3.3.2 像vector对象中添加元素</h3><ul><li>v.push_back(e) 在尾部增加元素。</li><li>为了可以使得vector高效增长，通常先定义一个空 vector，然后在添加元素会更快速。</li><li>如果插入的vector中的初始值值都是一样的此时初始化时确定大小与值会更快，如果初始值值不一样，即使已知大小，最好也先定义一个空的 vector，再添加元素。</li></ul><h3 id="🍑3-3-3-其他vector操作"><a href="#🍑3-3-3-其他vector操作" class="headerlink" title="🍑3.3.3 其他vector操作"></a>🍑3.3.3 其他vector操作</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">v.size();            <span class="comment">//返回v中元素的个数</span></span><br><span class="line">v.empty();           <span class="comment">//如果v不含有任何元素，返回真；否则返回假</span></span><br><span class="line">v.push_back(t);      <span class="comment">//向v的尾端添加一个值为t的元素</span></span><br><span class="line">v[n]                 <span class="comment">//返回v中第n个位置上元素的引用</span></span><br><span class="line">v1 = v2 <span class="comment">//用v2中的元素拷贝替换v1中的元素</span></span><br><span class="line">v1 = &#123;a,b,c...&#125;      <span class="comment">//用列表中元素的拷贝替换v1中的元素</span></span><br><span class="line">v1 == v2             <span class="comment">//v1和v2相等当且仅当它们的元素数量相同且对应位置的元素值都相同</span></span><br><span class="line">v1 != v2</span><br><span class="line">&lt;,&lt;=,&gt;, &gt;=         <span class="comment">//以字典顺序进行比较</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>可以用范围 for 语句处理 vector 序列的元素，范围for语句内不应该改变其遍历序列的大小。</li><li>vector对象（以及string对象）的下标运算符，只能对确知已存在的元素执行下标操作<code>(只能访问元素，或者更改已经存在的元素)</code>，但是<code>不能用于添加元素。</code></li></ul><h2 id="🍌3-4-迭代器介绍"><a href="#🍌3-4-迭代器介绍" class="headerlink" title="🍌3.4 迭代器介绍"></a>🍌3.4 迭代器介绍</h2><ul><li>所有标准库容器都可以使用迭代器，但是只有少数几种才同时支持下标操作，<code>如果是容器，尽量都采用迭代器进行操作</code></li><li>类似于指针类型，迭代器也提供了对对象的间接访问。(可以访问某个元素，也可以移动迭代器，<code>好比指针</code>)</li><li>迭代器分为有效和无效。</li></ul><h3 id="🍑3-4-1-使用迭代器"><a href="#🍑3-4-1-使用迭代器" class="headerlink" title="🍑3.4.1 使用迭代器"></a>🍑3.4.1 使用迭代器</h3><ul><li>begin 返回指向第一个元素的迭代器</li><li>end 返回指向最后一个元素的下一位的迭代器（通常被称为尾后迭代器）<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> b = v.begin(), e = v.end()    <span class="comment">//返回的是iterator类型</span></span><br><span class="line"><span class="keyword">auto</span> c = v.cbegin(), f = v.cend()   <span class="comment">//返回的是const_iterator类型</span></span><br></pre></td></tr></table></figure>注意：如果容器为空，则begin和end返回的是同一个迭代器，都是尾后迭代器</li></ul><p><strong>迭代器运算符</strong><br>| 运算符           | 解释                                   |<br>| ———————— | ——————————————————— |<br>| <em>iter          | 返回迭代器iter所指向的<strong>元素的引用</strong> |<br>| iter-&gt;mem      | 等价于(</em>iter).mem                    |<br>| ++iter         | 令iter指示容器中的下一个元素         |<br>| - -iter         | 令iter指示容器中的上一个元素         |<br>| iter1 == iter2 | 判断两个迭代器是否相等                 |<br>| iter1 != iter2 | 判断两个迭代器是否不相等               |</p><p><strong>迭代器类型</strong></p><p>迭代器分为俩种类型:</p><ul><li>terator </li><li>const_iterator</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;::iterator it;       <span class="comment">//it能读写</span></span><br><span class="line"><span class="built_in">string</span>::iterator it;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;::const_iterator it; <span class="comment">//it只能读</span></span><br><span class="line"><span class="built_in">string</span>::const_iterator;</span><br></pre></td></tr></table></figure><p><strong>begin和end返回值类型</strong></p><ul><li>begin 和 end返回值具体类型由对象是否是常量来决定，如果对象是常量则，begin和end返回const_iterator，否则相反。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; v;</span><br><span class="line"><span class="type">const</span> <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; v1;</span><br><span class="line"><span class="keyword">auto</span> it = v.begin();  <span class="comment">//it类型是iterator</span></span><br><span class="line"><span class="keyword">auto</span> it1 = v1.begin(); <span class="comment">//it1类型为const_iterator</span></span><br></pre></td></tr></table></figure><p><strong>注意:凡是使用了迭代器进行循环，都不要向迭代器所属的容器中添加或者删除元素，可以更改元素，都则，迭代器不知道指向哪个元素，迭代器会失效</strong></p><p> <strong>迭代器运算</strong><br> string 和 vector支持的迭代运算。注意不能将俩个迭代器相加。<br> <code>vector</code>和<code>string</code>迭代器支持的运算：</p><div class="table-container"><table><thead><tr><th>运算符</th><th>解释</th></tr></thead><tbody><tr><td>iter + n</td><td>迭代器加上一个整数值仍得到一个迭代器，迭代器指示的新位置和原来相比向前移动了若干个元素。结果迭代器或者指示容器内的一个元素，或者指示容器尾元素的下一位置。</td></tr><tr><td>iter - n</td><td>迭代器减去一个证书仍得到一个迭代器，迭代器指示的新位置比原来向后移动了若干个元素。结果迭代器或者指向容器内的一个元素，或者指示容器尾元素的下一位置。</td></tr><tr><td>iter1 += n</td><td>迭代器加法的复合赋值语句，将<code>iter1</code>加n的结果赋给<code>iter1</code></td></tr><tr><td>iter1 -= n</td><td>迭代器减法的复合赋值语句，将<code>iter2</code>减n的加过赋给<code>iter1</code></td></tr><tr><td>iter1 - iter2</td><td>两个迭代器相减的结果是它们之间的距离，也就是说，将运算符右侧的迭代器向前移动差值个元素后得到左侧的迭代器。参与运算的两个迭代器必须指向的是同一个容器中的元素或者尾元素的下一位置。</td></tr><tr><td>&gt;、&gt;=、&lt;、&lt;=</td><td>迭代器的关系运算符，如果某迭代器        </td></tr></tbody></table></div><ul><li>difference_type：保证足够大以存储任何两个迭代器对象间的距离，可正可负。</li><li>迭代器只有相减，没有相加。<h2 id="🍌3-5-数组"><a href="#🍌3-5-数组" class="headerlink" title="🍌3.5 数组"></a>🍌3.5 数组</h2></li><li>数组的大小，长度固定，不可以变，相当于vector的低级版    </li></ul><h3 id="🍑3-5-1-定义和初始化内置数组"><a href="#🍑3-5-1-定义和初始化内置数组" class="headerlink" title="🍑3.5.1 定义和初始化内置数组"></a>🍑3.5.1 定义和初始化内置数组</h3><ul><li>数组的维度必须是个常量表达式<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">0</span>];                    <span class="comment">//数组的维度必须是个常量表达式</span></span><br><span class="line"><span class="type">unsigned</span> cnt = <span class="number">42</span>            <span class="comment">//不是常量表达式</span></span><br><span class="line">constexpr <span class="type">unsigned</span> cnt = <span class="number">42</span>; <span class="comment">//是常量表达式</span></span><br><span class="line"><span class="built_in">string</span> strs[get_size()];     <span class="comment">//当get_size()是constexpr时，是常量表达式</span></span><br></pre></td></tr></table></figure></li><li>数组和vector的元素必须是对象，不能是引用</li><li>数组不能用auto关键由初始值列表推断类型</li></ul><p><strong>字符数组的特殊性</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> a1[] = &#123;<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;+&#x27;</span>, <span class="string">&#x27;+&#x27;</span> &#125;;   <span class="comment">//列表初始化，没有空字符，维度是3</span></span><br><span class="line"><span class="type">char</span> a2[] = <span class="string">&quot;c ++&quot;</span>;            <span class="comment">//有空字符串，维度是4；</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> a4[<span class="number">3</span>] = <span class="string">&quot;c++&quot;</span>;      <span class="comment">//错误，没有空间存放空字符</span></span><br></pre></td></tr></table></figure></p><p>不能用数组为另一个数组赋值或拷贝。可以按元素一个一个拷贝，但不能直接拷贝整个数组。</p><p><strong>理解复杂的数组声明</strong></p><p>因为数组本身是一个对象，所以允许定义数组的指针以及数组的引用。</p><p><code>从数组的名字开始右内向外的顺序比较好理解</code><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *ptr[<span class="number">10</span>];           <span class="comment">// ptrs是一个含有10个整型指针的数组</span></span><br><span class="line"><span class="type">int</span> (*ptr)[<span class="number">10</span>] = &amp;arr;  <span class="comment">// ptrs是一个指针，指向一个含有10个整数的数组</span></span><br><span class="line"><span class="type">int</span> (&amp;ptr)[<span class="number">10</span>] = &amp;arr;  <span class="comment">// ptrs是一个引用，引用一个含有10个整数的数组</span></span><br></pre></td></tr></table></figure><br>例如：</p><ul><li>先读（），<em>ptr是一个指针，在往右看，这个指针指向一个数组，在往左看，这个数组是 int 型的， 所以int `(</em>ptr)[10] = &amp;arr`;  ptrs是一个指针，指向一个含有10个整数的数组</li></ul><h3 id="🍑3-5-2-访问数组元素"><a href="#🍑3-5-2-访问数组元素" class="headerlink" title="🍑3.5.2 访问数组元素"></a>🍑3.5.2 访问数组元素</h3><ul><li>数组的元素可以使用范围<code>for语句</code>或者<code>下标运算符</code>来进行访问</li><li>在使用数组下标时候，通常定义为<code>size_t类型</code>(是一种无符号类型，他被设计的足够大以便能表示内存中任意对象的大小)</li></ul><p><strong>数组相比vector的缺点是什么</strong></p><ul><li>数组的大小是确定的。</li><li>不能随意增加元素。</li><li>不允许拷贝和赋值。<br>数组不能直接拷贝，而是需要每个元素拷贝。而vector可以直接拷贝<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//数组需要每个元素进行拷贝</span></span><br><span class="line">   <span class="type">int</span> arr[<span class="number">10</span>];</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) arr[i] = i;</span><br><span class="line">   <span class="type">int</span> arr2[<span class="number">10</span>];</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) arr2[i] = arr[i];</span><br><span class="line">   </span><br><span class="line">   <span class="comment">//vector可以直接拷贝</span></span><br><span class="line">   <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; <span class="title function_">v</span><span class="params">(<span class="number">10</span>)</span>;</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i != <span class="number">10</span>; ++i) v[i] = arr[i];</span><br><span class="line">   <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; <span class="title function_">v2</span><span class="params">(v)</span>;</span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">auto</span> i : v2) <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br></pre></td></tr></table></figure></li></ul><h3 id="🍑3-5-3-指针和数组"><a href="#🍑3-5-3-指针和数组" class="headerlink" title="🍑3.5.3 指针和数组"></a>🍑3.5.3 指针和数组</h3><ul><li>在大多数情况，使用数组类型的对象其实是使用一个指向该数组首元素的指针</li><li>标准库类型（如 string、vector 等）的下标都是无符号类型，而数组内置的下标没有这个要求。</li><li>指向数组元素的指针等价于 vector 中的迭代器</li><li>指针访问数组：在表达式中使用数组名时，名字会自动转换成指向数组的第一个元素的指针。</li><li>使用数组时，编译器一般会把它转换成指针。</li></ul><h3 id="🍑3-5-4-c风格字符串"><a href="#🍑3-5-4-c风格字符串" class="headerlink" title="🍑3.5.4 c风格字符串"></a>🍑3.5.4 c风格字符串</h3><ul><li>c++是由c继承过来的c风格字符串</li><li>c 风格字符串<code>不是一种类型，而是一种写法</code>，是为了表达和使用字符串而形成的一种约定俗成的写法。</li><li>按此习惯书写的字符串存放在字符数组中并以<code>空字符（&#39;\0&#39;）</code>结束。</li><li>c++ 支持 c 风格字符串，但是最好不要使用，极易引发程序漏洞,对大多数应用来说，使用标准库 string比使用C风格字符串更安全、更高效。</li></ul><div class="table-container"><table><thead><tr><th>函数</th><th>介绍</th></tr></thead><tbody><tr><td>strlen(p1)</td><td>返回<code>p1</code>的长度，空字符不计算在内</td></tr><tr><td>strcmp(p1, p2)</td><td>比较<code>p1</code>和<code>p2</code>的相等性。如果<code>p1==p2</code>，返回0；如果<code>p1&gt;p2</code>，返回一个正值；如果<code>p1&lt;p2</code>，返回一个负值。</td></tr><tr><td>strcat(p1, p2)</td><td>将<code>p2</code>附加到<code>p1</code>之后，返回<code>p1</code></td></tr><tr><td>strcpy(p1, p2)</td><td>将<code>p2</code>拷贝给<code>p1</code>，返回<code>p1</code>                     </td></tr></tbody></table></div><ul><li>上述表中所列的函数不负责验证其字符串参数</li><li>传入参数的指针必须指向以空字符结束的数组。必须确保数组足够大。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> ca[] = &#123;<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>&#125;   <span class="comment">//不以空字符结束</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">strlen</span>(ca) &lt;&lt; <span class="built_in">endl</span>;      <span class="comment">//错误：ca没有以空字符结束</span></span><br></pre></td></tr></table></figure><code>对于 string，可以使用 s = s1 + s2，s1 &gt; s2 等加和与比较，而 c 风格字符串不行，因为他们实际上是指针。</code></li></ul><h3 id="🍑3-5-5与旧代码的接口"><a href="#🍑3-5-5与旧代码的接口" class="headerlink" title="🍑3.5.5与旧代码的接口"></a>🍑3.5.5与旧代码的接口</h3><p><strong>string对象和C风格字符串的混用</strong></p><ul><li><p>可以使用字符串字面值来初始化 string 对象或与 string 对象加和，所有可以用字符串字面值的地方都可以使用以空字符结束的字符数组来代替。</p></li><li><p>反过来不能使用 string 对象初始化字符数组，必须要用 <strong>c_str()</strong> 函数将 string 对象转化为 c 风格字符串</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> <span class="title function_">s</span> <span class="params">(<span class="string">&quot;hello world&quot;</span>)</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *str = s;          <span class="comment">//错误，不能用string对象初始化char* </span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* cp = s.c_str();  <span class="comment">// s.c_str() 返回一个指向以空字符结束的字符数组的指针。              </span></span><br></pre></td></tr></table></figure><p>​                </p><p><strong>使用数组初始化 vector 对象</strong></p><ul><li>不允许使用一个数组为另一个内置类型的数组赋值</li><li>可以使用数组来初始化 vector 对象，用两个指针来表明范围（左闭合区间）</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr[] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;; </span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; <span class="title function_">ivec</span><span class="params">(begin(arr), end(arr))</span>;              </span><br></pre></td></tr></table></figure><p>​<br><strong>建议不要使用 c 风格字符串和内置数值，都使用标准库容器</strong></p><h2 id="🍌3-6-多维数组"><a href="#🍌3-6-多维数组" class="headerlink" title="🍌3.6 多维数组"></a>🍌3.6 多维数组</h2><p>严格来说 C++ 中没有多维数组，那实际是数组的数组。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr[<span class="number">20</span>][<span class="number">30</span>][<span class="number">40</span>]   <span class="comment">//将所有元素初始化为 0</span></span><br></pre></td></tr></table></figure></p><p><strong>多维数组的初始化</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//显示初始化所有元素</span></span><br><span class="line"><span class="type">int</span> a[<span class="number">3</span>][<span class="number">4</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>&#125;</span><br><span class="line"><span class="type">int</span> a[<span class="number">3</span>][<span class="number">4</span>] = &#123;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;,&#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;,&#123;<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;,&#123;<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>&#125;&#125;  <span class="comment">//与上面等价</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//显示初始化部分元素</span></span><br><span class="line"><span class="type">int</span> a[<span class="number">3</span>][<span class="number">4</span>] = &#123;&#123;<span class="number">0</span>&#125;,&#123;<span class="number">1</span>&#125;,&#123;<span class="number">2</span>&#125;&#125;;  <span class="comment">//只是初始化了每一行的第一个元素</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></p><p><strong>多维数组的下标引用</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr[<span class="number">3</span>][<span class="number">4</span>];</span><br><span class="line">arr[<span class="number">0</span>];<span class="comment">//这是一个有四个元素的一维数组</span></span><br><span class="line">arr[<span class="number">0</span>][<span class="number">0</span>];<span class="comment">//第一行第一列的元素</span></span><br></pre></td></tr></table></figure></p><p><strong>使用范围 for 语句处理多维数组</strong></p><ul><li>c ++11中可以使用范围 for 语句处理多维数组。</li><li><code>注意范围 for 语句中改变元素值要显示使用 &amp; 符号声明为引用类型。</code></li><li><code>注意使用范围 for 循环处理多维数组时，除了最内层的循环外，其他所有循环的控制变量都应该是引用类型。</code></li><li>因为如果不声明为引用类型，编译器会自动将控制变量转换为指向数组首元素的指针，就不能在内层继续使用范围 for 循环处理该控制变量了。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">constexpr <span class="type">size_t</span> rowCnt = <span class="number">3</span>, colCnt = <span class="number">4</span>;</span><br><span class="line"><span class="type">int</span> ia [rowCnt][colCnt];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span>&amp; row : arr)          <span class="comment">//给每一行赋值</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> col : row)       <span class="comment">//给每一列进行赋值，例如先赋值[0][0],[0][1],[0][2]</span></span><br></pre></td></tr></table></figure><p>输出 arr 的元素有四种方法</p><ul><li>范围 for 语句-不使用类型别名</li><li>范围 for 语句-使用类型别名</li><li>普通 for 循环</li><li>指针<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 范围 for 语句-不使用类型别名</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">const</span> <span class="type">int</span> (&amp;row)[<span class="number">4</span>] : arr)</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> col : row)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; col &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 范围 for 语句-使用类型别名</span></span><br><span class="line">using int_array = <span class="type">int</span>[<span class="number">4</span>];</span><br><span class="line"><span class="keyword">for</span> (int_array &amp;p : ia)</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> q : p)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; q &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 普通 for 循环</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i != <span class="number">3</span>; ++i)</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> j = <span class="number">0</span>; j != <span class="number">4</span>; ++j)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; arr[i][j] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指针</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> (*row)[<span class="number">4</span>] = arr; row != arr + <span class="number">3</span>; ++row)</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> *col = *row; col != *row + <span class="number">4</span>; ++col)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *col &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><strong>指针vs引用</strong></li><li>引用总是指向某个对象，定义引用时没有初始化是错的。</li><li>给引用赋值，修改的是该引用所关联的对象的值，而不是让引用和另一个对象相关联</li></ul><p><strong>动态数组</strong></p><ul><li>使用 <code>new</code>和 <code>delete</code>表达和c中<code>malloc</code>和<code>free</code>类似的功能，即在堆（自由存储区）中分配存储空间。</li><li>定义： <code>int *pia = new int[10];</code>10可以被一个变量替代。</li><li>释放： <code>delete [] pia;</code>，注意不要忘记[]。</li></ul>]]></content>
      
      
      <categories>
          
          <category> c++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>shell脚本编程</title>
      <link href="/2022/04/23/post2/"/>
      <url>/2022/04/23/post2/</url>
      
        <content type="html"><![CDATA[<h3 id="第1章-Shell概述"><a href="#第1章-Shell概述" class="headerlink" title="第1章 Shell概述"></a>第1章 Shell概述</h3><ul><li>shell是一个<a href="https://so.csdn.net/so/search?q=命令行&amp;spm=1001.2101.3001.7020">命令行</a>解释器，它接收应用程序/用户命令，然后调用操作系统内核</li></ul><h3 id="第2章-Shell-解析器"><a href="#第2章-Shell-解析器" class="headerlink" title="第2章 Shell 解析器"></a>第2章 Shell 解析器</h3><ul><li><p>linux 提供的Shell 解析器有很多，最常用的俩个解析器为：sh和bash。</p></li><li><p>Centos默认的解析器是bash</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@zjh home]<span class="meta"># echo $SHELL</span></span><br><span class="line">/bin/bash</span><br></pre></td></tr></table></figure></li></ul><h3 id="第3章-Shell脚本入门"><a href="#第3章-Shell脚本入门" class="headerlink" title="第3章 Shell脚本入门"></a>第3章 Shell脚本入门</h3><ul><li><p><strong>脚本格式</strong></p><p>脚本以#!/bin/bash 开头（指定解析器）</p></li><li><p><strong>第一个Shell 脚本：helloworld</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># 创建脚本</span><br><span class="line">[root@zjh home]<span class="meta"># cat helloworld.sh </span></span><br><span class="line">#!/bin/bash</span><br><span class="line">echo <span class="string">&quot;hello zjh&quot;</span></span><br><span class="line"></span><br><span class="line"># 执行脚本方式<span class="number">1</span></span><br><span class="line">[root@zjh home]<span class="meta"># bash helloworld.sh </span></span><br><span class="line">hello zjh</span><br><span class="line"></span><br><span class="line"># 执行脚本方式<span class="number">2</span></span><br><span class="line">[root@zjh home]# ./helloworld.sh</span><br><span class="line">-bash: ./helloworld.sh: 权限不够</span><br></pre></td></tr></table></figure><p><strong>方式1，本质是bash解析器帮你执行脚本，所以脚本本身不需要执行权限；</strong></p><p><strong>方式2，本质是脚本自己需要执行，所以需要执行权限</strong></p></li></ul><ul><li><p><strong>第二个Shell 脚本：多命令处理</strong></p><p>需求 ：在linux家目录下创建一个bangzhang.txt并在文件中写入”I IOVE YOU”字符.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@zjh home]<span class="meta"># touch batch.sh</span></span><br><span class="line">[root@zjh home]<span class="meta"># vim batch.sh</span></span><br><span class="line"></span><br><span class="line">#!/bin/bash</span><br><span class="line">cd /home/linux/</span><br><span class="line">touch banzhang.txt</span><br><span class="line">echo <span class="string">&quot;I LOVE YOU&quot;</span> &gt;&gt; banzhang.txt</span><br></pre></td></tr></table></figure></li></ul><h3 id="第4章-Shell中的变量"><a href="#第4章-Shell中的变量" class="headerlink" title="第4章 Shell中的变量"></a>第4章 Shell中的变量</h3><h4 id="4-1-系统变量"><a href="#4-1-系统变量" class="headerlink" title="4.1 系统变量"></a>4.1 系统变量</h4><ul><li><p>常用系统变量 $HOME $PWD $SHELL $USER</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@zjh home]<span class="meta"># echo $HOME</span></span><br><span class="line">/home/linux</span><br><span class="line">[root@zjh home]<span class="meta"># echo $PWD</span></span><br><span class="line">/home/linux/datas</span><br><span class="line">[root@zjh home]<span class="meta"># echo $SHELL</span></span><br><span class="line">/bin/bash</span><br><span class="line">[root@zjh home]<span class="meta"># echo $USER</span></span><br><span class="line">linux</span><br></pre></td></tr></table></figure></li></ul><h4 id="4-2自定义变量"><a href="#4-2自定义变量" class="headerlink" title="4.2自定义变量"></a>4.2自定义变量</h4><ul><li><p><strong>1.基本语法</strong></p><p>定义变量：变量=值 <strong>等号两边不能留有空格</strong></p><p>撤销变量：unset 变量</p><p>输出变量：echo $变量</p><p>声明静态变量： readonly 变量，==注意：不能unset==</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[root@zjh home]# A=<span class="number">1</span></span><br><span class="line">[root@zjh home]<span class="meta"># echo $A</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line">[root@zjh home]<span class="meta"># unset A</span></span><br><span class="line">    </span><br><span class="line"><span class="meta"># readonly 变量，注意：不能unset</span></span><br><span class="line">[root@zjh home]<span class="meta"># readonly B=2</span></span><br><span class="line">[root@zjh home]<span class="meta"># echo $B</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line">    </span><br><span class="line">[root@zjh home]# B=<span class="number">9</span></span><br><span class="line">-bash : B: readonly variable</span><br><span class="line">    </span><br><span class="line">    </span><br></pre></td></tr></table></figure></li></ul><ul><li><p><strong>2.变量定义规则</strong></p><ol><li><p>变量名称可以由字母，数字和下划线组成，不能以数字开头，==环境变量名建议大写==</p></li><li><p>==等号两侧不能有空格==</p></li><li><p>在bash中，变量默认类型都是字符串类型，无法直接进行数值运算</p></li><li><p>变量的值如果有空格，需要使用双引号或单引号括起来</p></li></ol></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@zjh home]# D=<span class="string">&quot;A B C&quot;</span></span><br><span class="line">[root@zjh home]<span class="meta"># echo $D</span></span><br><span class="line">A B C</span><br><span class="line">    </span><br><span class="line">[root@zjh home]# C=<span class="number">1</span>+<span class="number">2</span></span><br><span class="line">[root@zjh home]<span class="meta"># echo $c</span></span><br><span class="line"><span class="number">1</span>+<span class="number">2</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>可把变量提升为全局变量，可供其他shell程序使用:<br>export 变量</li></ul><h4 id="4-3-特殊变量：-n"><a href="#4-3-特殊变量：-n" class="headerlink" title="4.3 特殊变量：$n"></a>4.3 特殊变量：$n</h4><ul><li>$n——n为数字，$0 代表脚本名称，10以内参数用$1-$9表示，10以上需要用大括号${10}.</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">echo <span class="string">&quot;$0&quot;</span> <span class="string">&quot;$1&quot;</span> <span class="string">&quot;$2&quot;</span> <span class="string">&quot;$3&quot;</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@zjh home]<span class="meta"># sh parameter.sh</span></span><br><span class="line">parameter.sh</span><br><span class="line">  </span><br><span class="line">[root@zjh home]<span class="meta"># sh parameter.sh 10 lal 20</span></span><br><span class="line">parameter.sh <span class="number">10</span> lal <span class="number">20</span></span><br></pre></td></tr></table></figure><h4 id="4-4-特殊变量："><a href="#4-4-特殊变量：" class="headerlink" title="4.4 特殊变量：$"></a>4.4 特殊变量：$</h4><ul><li>$#——获取所有输入参数个数，常用于循环</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@zjh home]<span class="meta"># vim parameter.sh</span></span><br><span class="line">#!/bin/bash</span><br><span class="line">echo <span class="string">&quot;$0&quot;</span> <span class="string">&quot;$1&quot;</span> <span class="string">&quot;$2&quot;</span></span><br><span class="line">echo $#</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@zjh home]<span class="meta"># bash parameter.sh</span></span><br><span class="line">parameter.sh</span><br><span class="line"><span class="number">0</span></span><br><span class="line">[root@zjh home]<span class="meta"># bash parameter.sh 10 lala 20</span></span><br><span class="line">parameter.sh <span class="number">10</span> lala <span class="number">20</span></span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure><h4 id="4-5-特殊变量：-和"><a href="#4-5-特殊变量：-和" class="headerlink" title="4.5 特殊变量：$* 和$@"></a>4.5 特殊变量：$* 和$@</h4><ul><li><p>$* ——代表命令行中所有的参数，把所有参数看成一个整体</p></li><li><p>$@ ——也代表命令行中所有的参数，不过把每个参数区分对待</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@zjh home]<span class="meta"># vim parameter.sh</span></span><br><span class="line">echo <span class="string">&quot;$0&quot;</span> <span class="string">&quot;$1&quot;</span> <span class="string">&quot;$2&quot;</span> <span class="string">&quot;$3&quot;</span></span><br><span class="line">echo $<span class="meta">#</span></span><br><span class="line"><span class="meta">echo $*</span></span><br><span class="line">echo #@</span><br></pre></td></tr></table></figure>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@zjh home]<span class="meta"># sh parameter.sh 1 2 3</span></span><br><span class="line">parameter.sh <span class="number">1</span> <span class="number">2</span> <span class="number">3</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span></span><br></pre></td></tr></table></figure><h4 id="4-6-特殊变量：-？"><a href="#4-6-特殊变量：-？" class="headerlink" title="4.6 特殊变量：$？"></a>4.6 特殊变量：$？</h4><ul><li><p>$?——最后一个执行的命令的返回状态。如果这个变量的值为0，则最后一个命令正确执行</p><p>​            如果这个值为非0（具体哪一个数，由命令自己来决定），则证明上一个命令执行不正确</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">[root@zjh home]<span class="meta"># sh parameter.sh 1 2 3</span></span><br><span class="line">parameter.sh <span class="number">1</span> <span class="number">2</span> <span class="number">3</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span></span><br><span class="line">    </span><br><span class="line">[root@zjh home]# $?                          执行失败返回非<span class="number">0</span></span><br><span class="line">-bash:<span class="number">0</span> : command <span class="keyword">not</span> found</span><br><span class="line">[root@zjh home]<span class="meta">#  echo $?</span></span><br><span class="line"><span class="number">127</span></span><br><span class="line">    </span><br><span class="line">[root@zjh home]<span class="meta">#  sh parameter.sh 1 2 3       执行成功返回0</span></span><br><span class="line">parameter.sh <span class="number">1</span> <span class="number">2</span> <span class="number">3</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span></span><br><span class="line">    </span><br><span class="line">[root@zjh home]<span class="meta"># echo $?</span></span><br><span class="line"><span class="number">0</span></span><br></pre></td></tr></table></figure><h3 id="第5章-运算符"><a href="#第5章-运算符" class="headerlink" title="第5章 运算符"></a>第5章 运算符</h3><h4 id="5-1-基本语法"><a href="#5-1-基本语法" class="headerlink" title="5.1 基本语法"></a>5.1 基本语法</h4><ul><li>$((运算式))  或者  $[运算式]</li><li>expr +. -, *, /, %  加，减，乘，除，取余<br>  ==注意：expr运算符间要有空格==</li></ul><h4 id="5-2-实例实操"><a href="#5-2-实例实操" class="headerlink" title="5.2  实例实操"></a>5.2  实例实操</h4><p>计算3+2的值</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@zjh home]<span class="meta"># expr 2 + 3</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line">[root@zjh home]<span class="meta"># expr 2+3</span></span><br><span class="line">error</span><br></pre></td></tr></table></figure><p>计算（2+3）x4的值</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@zjh home]<span class="meta"># expr `expr 2 + 3` \* 4</span></span><br><span class="line"><span class="number">20</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@zjh home]<span class="meta">#  a=$[(2+3)*4]</span></span><br><span class="line">[root@zjh home]<span class="meta">#  echo $a</span></span><br><span class="line"><span class="number">20</span></span><br></pre></td></tr></table></figure><h3 id="第6章条件判断"><a href="#第6章条件判断" class="headerlink" title="第6章条件判断"></a>第6章条件判断</h3><h4 id="6-1基本语法"><a href="#6-1基本语法" class="headerlink" title="6.1基本语法"></a>6.1基本语法</h4><p>[ condition ] ==(注意 condition前后要有空格)==</p><p>注意：条件非空即为true,  [atguigu] 返回 true, []返回false</p><h4 id="6-2常用条件判断"><a href="#6-2常用条件判断" class="headerlink" title="6.2常用条件判断"></a>6.2常用条件判断</h4><div class="table-container"><table><thead><tr><th style="text-align:center">符号</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">-lt</td><td style="text-align:center">(less than)        小于</td></tr><tr><td style="text-align:center">-le</td><td style="text-align:center">(less equal)      小于等于</td></tr><tr><td style="text-align:center">-eq</td><td style="text-align:center">(equal)              等于</td></tr><tr><td style="text-align:center">-gt</td><td style="text-align:center">(greater than)  大于</td></tr><tr><td style="text-align:center">-ge</td><td style="text-align:center">(greater equal) 大于等于</td></tr><tr><td style="text-align:center">-ne</td><td style="text-align:center">(no eqeual)       不等于</td></tr></tbody></table></div><h5 id="文件权限判断"><a href="#文件权限判断" class="headerlink" title="文件权限判断"></a>文件权限判断</h5><ul><li>-r 有读的权限</li><li>-w 有写的权限</li><li>-x 有执行的权限</li></ul><h5 id="文件类型判断"><a href="#文件类型判断" class="headerlink" title="文件类型判断"></a>文件类型判断</h5><ul><li>-f 文件存在并且是一个常规文件  (file)</li><li>-e 文件存在                                   (exixtence)</li><li>-d 文件存在病是一个目录            (directory)</li></ul><h4 id="6-3-案例实操"><a href="#6-3-案例实操" class="headerlink" title="6.3 案例实操"></a>6.3 案例实操</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"># 判断<span class="number">23</span>是否大于<span class="number">2</span></span><br><span class="line">[root@zjh home]# $ [ <span class="number">23</span> -gt <span class="number">2</span> ]</span><br><span class="line">[root@zjh home]<span class="meta"># echo $?</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"></span><br><span class="line">[root@zjh home]# $ [ <span class="number">23</span> -le <span class="number">2</span> ]   </span><br><span class="line">[root@zjh home]<span class="meta"># echo $?           #返回值非0说明上一条指令执行错误，也就是[ 23 -le 2 ] </span></span><br><span class="line"><span class="number">1</span>                                  #是错误的</span><br><span class="line">    </span><br><span class="line"># 判断helloworld.sh是否有写入权限</span><br><span class="line">[root@zjh home]#  [ -w hellowrld.sh ]</span><br><span class="line">[root@zjh home]<span class="meta">#  echo $?</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"></span><br><span class="line"># 判断目录中文件是否存在</span><br><span class="line">[root@zjh home]#  [ -e /home/linux/datas ]</span><br><span class="line">[root@zjh home]<span class="meta">#  echo $?</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">#多条件判断</span><br><span class="line">[root@zjh home]# [ condition ] &amp;&amp; echo OK || echo notok </span><br><span class="line">OK</span><br><span class="line">[root@zjh home]# [ condition ] &amp;&amp; [] || echo notol</span><br><span class="line">notok</span><br></pre></td></tr></table></figure><h3 id="第7章-流程控制（重点）"><a href="#第7章-流程控制（重点）" class="headerlink" title="第7章 流程控制（重点）"></a>第7章 流程控制（重点）</h3><h4 id="7-1-if语句"><a href="#7-1-if语句" class="headerlink" title="7.1 if语句"></a>7.1 if语句</h4><ul><li><p>==注意事项==：[ 条件判断 ]，中括号和条件判断之间必须有空格。</p></li><li><p>if 后要有空格</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[root@zjh home]<span class="meta"># cat <span class="keyword">if</span>.sh</span></span><br><span class="line">#!/bin/bash</span><br><span class="line"><span class="keyword">if</span> [ $<span class="number">1</span> -eq <span class="number">1</span> ]</span><br><span class="line">then</span><br><span class="line">echo <span class="string">&quot;我最帅&quot;</span></span><br><span class="line">elif [ $<span class="number">1</span> -eq <span class="number">2</span> ]</span><br><span class="line">then</span><br><span class="line">echo <span class="string">&quot;我最好看&quot;</span></span><br><span class="line">fi</span><br><span class="line">    </span><br><span class="line">[root@zjh home]<span class="meta"># bash <span class="keyword">if</span>.sh 2</span></span><br><span class="line">我最好看</span><br></pre></td></tr></table></figure><h4 id="7-2-case语句"><a href="#7-2-case语句" class="headerlink" title="7.2 case语句"></a>7.2 case语句</h4><p><strong>注意事项</strong>：</p><ul><li>case 行尾必须为单词”in”, 每一个模式匹配必须以右括号“）”结束。</li><li>双分号“；；” 表示命令序列结束，相当于java中的break.</li><li>最后的“*）” 表示默认模式，相当于java中的default.</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[root@zjh home]<span class="meta"># cat case.sh</span></span><br><span class="line">#!/bin/bash</span><br><span class="line"><span class="keyword">case</span> $<span class="number">1</span> in</span><br><span class="line"><span class="number">1</span>)</span><br><span class="line">echo <span class="string">&quot;班长&quot;</span></span><br><span class="line">;;</span><br><span class="line"><span class="number">2</span>)</span><br><span class="line">echo <span class="string">&quot;学委&quot;</span></span><br><span class="line">;;</span><br><span class="line"><span class="number">3</span>)</span><br><span class="line">echo <span class="string">&quot;体委&quot;</span></span><br><span class="line">;;</span><br><span class="line">*) </span><br><span class="line">    exho <span class="string">&quot;人妖&quot;</span></span><br><span class="line">esac</span><br><span class="line">[root@zjh home]<span class="meta"># bash case.sh 4</span></span><br><span class="line">人妖</span><br></pre></td></tr></table></figure><h4 id="7-3-for循环"><a href="#7-3-for循环" class="headerlink" title="7.3 for循环"></a>7.3 for循环</h4><h5 id="语法1"><a href="#语法1" class="headerlink" title="语法1"></a>语法1</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@zjh home]<span class="meta"># cat for.sh</span></span><br><span class="line">#!/bin/bash</span><br><span class="line">s=<span class="number">0</span></span><br><span class="line"><span class="keyword">for</span>((i=<span class="number">1</span>;i&lt;=<span class="number">100</span>;i++))</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">s=$[$s+$i]</span><br><span class="line">done</span><br><span class="line">echo $s</span><br><span class="line">[root@zjh home]<span class="meta"># bash for.sh</span></span><br><span class="line"><span class="number">5050</span></span><br></pre></td></tr></table></figure><h5 id="语法2"><a href="#语法2" class="headerlink" title="语法2"></a>语法2</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[root@zjh home]<span class="meta"># cat for2.sh</span></span><br><span class="line">#!/bin/bash</span><br><span class="line"><span class="keyword">for</span> i in $*</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">echo $i</span><br><span class="line">done</span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> i in $@</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    echo $j</span><br><span class="line">done</span><br><span class="line">    </span><br><span class="line">[root@zjh home]<span class="meta"># bash for2.sh 1 2              <span class="comment">//看不出什么区别</span></span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[root@zjh home]<span class="meta"># cat for2.sh</span></span><br><span class="line">#!/bin/bash</span><br><span class="line"><span class="keyword">for</span> i in <span class="string">&quot;$*&quot;</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">echo $i</span><br><span class="line">done</span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> i in <span class="string">&quot;$@&quot;</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    echo $j</span><br><span class="line">done</span><br><span class="line">    </span><br><span class="line">[root@zjh home]<span class="meta"># bash for2.sh 1 2             <span class="comment">//能看出明显区别</span></span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span>                                           <span class="comment">//$* 是把输入的看成一个整体全部赋给i</span></span><br><span class="line"><span class="number">1</span>                                             <span class="comment">//$@ 是把输入分开传送，依次循环赋给j</span></span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure><h4 id="7-4-while-循环"><a href="#7-4-while-循环" class="headerlink" title="7.4 while 循环"></a>7.4 while 循环</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[root@zjh home]<span class="meta"># cat while.sh</span></span><br><span class="line">#!/bin/bash</span><br><span class="line">s=<span class="number">0</span></span><br><span class="line">i=<span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> [ $i -le <span class="number">100</span> ]    <span class="comment">//i是变量，我们这里使用的是i的值i的值为$i</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">s=$[$s + $i]</span><br><span class="line">i=$[$i + <span class="number">1</span>]</span><br><span class="line">done</span><br><span class="line">echo $s</span><br><span class="line"></span><br><span class="line">[root@zjh home]<span class="meta"># bash while.sh</span></span><br><span class="line"><span class="number">5050</span></span><br></pre></td></tr></table></figure><h3 id="第8章-read读取控制台输入"><a href="#第8章-read读取控制台输入" class="headerlink" title="第8章 read读取控制台输入"></a>第8章 read读取控制台输入</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">read</span>(选项)(参数)</span><br></pre></td></tr></table></figure><ul><li>-p 指定读取值时的提示符</li><li>-t 指定读取值时等待的时间（秒）</li></ul><p>参数：</p><p>变量：指定读取值得变量名</p><p><strong>实际上就是把选项输入的值，赋给变量（参数）</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># 提示<span class="number">7</span>秒内，读取控制台输入的名称</span><br><span class="line">[root@zjh home]<span class="meta"># cat read.sh</span></span><br><span class="line">#!/bin/bash</span><br><span class="line">read -t <span class="number">7</span> -p <span class="string">&quot;input your name&quot;</span> NAME</span><br><span class="line">echo $NAME</span><br><span class="line">    </span><br><span class="line">[root@zjh home]<span class="meta"># bash read.sh            <span class="comment">//如果7秒没有输入自动结束</span></span></span><br><span class="line">[root@zjh home]<span class="meta"># bash read.sh</span></span><br><span class="line">input your name   zjh</span><br><span class="line">zjh</span><br></pre></td></tr></table></figure><h3 id="第9章-函数"><a href="#第9章-函数" class="headerlink" title="第9章 函数"></a>第9章 函数</h3><h4 id="9-1-系统函数"><a href="#9-1-系统函数" class="headerlink" title="9.1 系统函数"></a>9.1 系统函数</h4><ul><li><p><strong>basename 基本语法</strong></p><p>basename[string / pathname] [suffix] ——basename命令会删掉所有的前缀包括最后一个（’/‘）字符，然后将字符串显示出来。</p><p><strong>选项：</strong></p><p>suffix 为后缀，如果suffix被指定了，basename会将pathname或string中的suffix去掉</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 方式<span class="number">1</span></span><br><span class="line">[root@zjh home]<span class="meta"># basename /home/linux/banzhang.txt</span></span><br><span class="line">banzhang.txt</span><br><span class="line"></span><br><span class="line"># 方式<span class="number">2</span></span><br><span class="line">[root@zjh home]<span class="meta"># basename /home/linux/banzhang.txt .txt</span></span><br><span class="line">banzhang</span><br></pre></td></tr></table></figure></li><li><p><strong>dirname基本语法</strong></p><p>dirname 文件绝对路径——从给定的包含绝对路径的文件名中去除文件名（非目录的部分），然后返回剩下的路径（目录的部分）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@zjh home]<span class="meta"># dirname /home/linux/banzhang.txt</span></span><br><span class="line">/home/linux</span><br></pre></td></tr></table></figure></li></ul><h4 id="9-2-自定义函数"><a href="#9-2-自定义函数" class="headerlink" title="9.2 自定义函数"></a>9.2 自定义函数</h4><ul><li>```c++<h1 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h1>[function] funname[()]     //[function] 选择项可写，可不写<br>{<pre><code>Action;[return int;]</code></pre>}<br>funname<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- **经验技巧**</span><br><span class="line"></span><br><span class="line">  - 必须在调用函数之前，先声明函数，shell脚本是逐步运行。不会像其他语言一样先编译。</span><br><span class="line"></span><br><span class="line">  - 函数返回值，只能通过$?系统变量获得，可以显示加：return 返回，如果不加，将以最后一条命令运行结果，作为返回值。return后跟数值n(0-255).</span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">```c++</span><br><span class="line"># DESC 计算输入两个参数的值</span><br><span class="line">[root@zjh home]# cat sum.sh</span><br><span class="line">#!/bin/bash</span><br><span class="line">function sum()&#123;</span><br><span class="line">s=0;</span><br><span class="line">s=$[$1 + $2]</span><br><span class="line">echo $s</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">read -p &quot;input your sum1:&quot; P1</span><br><span class="line">read -p &quot;input your sum2:&quot; P2</span><br><span class="line">sum $P1 $P2</span><br><span class="line">    </span><br><span class="line">[root@zjh home]# bash sum.sh</span><br><span class="line">input your sum1:1</span><br><span class="line">input your sum2:2</span><br><span class="line">3</span><br></pre></td></tr></table></figure></li></ul><h3 id="第10章-Shell工具（重点）"><a href="#第10章-Shell工具（重点）" class="headerlink" title="第10章 Shell工具（重点）"></a>第10章 Shell工具（重点）</h3><h4 id="10-1-cut"><a href="#10-1-cut" class="headerlink" title="10.1 cut"></a>10.1 cut</h4><p>cut命令从文件的每一行剪切字节，字符和字段并将这些字节，字符和字段输出。<br>cut [选项参数] filename</p><p>说明：默认分隔符是制表符</p><ul><li>-f 列号，提取第几列</li><li>-d 分隔符，按照指定分隔符分隔列</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># DESC 切割cut.txt第一列</span><br><span class="line">[root@zjh home]<span class="meta"># cat cut.txt</span></span><br><span class="line">dong shen</span><br><span class="line">guan zhen</span><br><span class="line">wo wo</span><br><span class="line">lai lai</span><br><span class="line">le le</span><br><span class="line">[root@zjh home]<span class="meta">#cut -d <span class="string">&quot; &quot;</span> -f 1 cut.txt</span></span><br><span class="line">dong</span><br><span class="line">guan</span><br><span class="line">wo</span><br><span class="line">lai</span><br><span class="line">le</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#在cut.txt文件中切割出guan</span><br><span class="line">[root@zjh home]<span class="meta"># cat cut.txt</span></span><br><span class="line">dong shen</span><br><span class="line">guan zhen</span><br><span class="line">wo wo</span><br><span class="line">lai lai</span><br><span class="line">le le</span><br><span class="line">[root@zjh home]<span class="meta"># cat cut.txt | grep guan</span></span><br><span class="line">guan zhen</span><br><span class="line">[root@zjh home]<span class="meta"># cat cut.txt | grep guan | cut -d <span class="string">&quot; &quot;</span> -f 1</span></span><br><span class="line">guan</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#选取系统PATH变量值，第<span class="number">2</span>个“：”开始后的所有路径</span><br><span class="line">[root@zjh home]<span class="meta"># echo $PATH</span></span><br><span class="line">/usr/lib64/qt<span class="number">-3.3</span>/bin:/usr/local/bin:/bin:/usr/bin:/usr/local/sbin:/</span><br><span class="line">usr/sbin:/sbin:/home/atguigu/bin</span><br><span class="line"></span><br><span class="line">[root@zjh home]<span class="meta"># echo $PATH | cut -d : -f 3-              <span class="comment">//不加-表示第三列，加=表示第三列之后</span></span></span><br><span class="line">/usr/bin:/usr/local/sbin:/usr/sbin:/sbin:/home/atguigu/bin</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#切割ifconfig后打印IP地址</span><br><span class="line">[root@zjh ~]<span class="meta"># ifconfig ens33</span></span><br><span class="line">ens33: flags=<span class="number">4163</span>&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu <span class="number">1500</span></span><br><span class="line">        inet:<span class="number">192.168</span><span class="number">.56</span><span class="number">.137</span>  netmask:<span class="number">255.255</span><span class="number">.255</span><span class="number">.0</span>  broadcast:<span class="number">192.168</span><span class="number">.56</span><span class="number">.255</span></span><br><span class="line">        inet6 fe80::<span class="number">5</span>da3:<span class="number">53</span>d8:<span class="number">5</span>d87:<span class="number">598</span>c  prefixlen <span class="number">64</span>  scopeid <span class="number">0x20</span>&lt;link&gt;</span><br><span class="line">        ether <span class="number">00</span>:<span class="number">0</span>c:<span class="number">29</span>:ad:<span class="number">3</span>d:<span class="number">0f</span>  txqueuelen <span class="number">1000</span>  (Ethernet)</span><br><span class="line">        RX packets <span class="number">1818</span>  bytes <span class="number">139153</span> (<span class="number">135.8</span> KiB)</span><br><span class="line">        RX errors <span class="number">0</span>  dropped <span class="number">0</span>  overruns <span class="number">0</span>  frame <span class="number">0</span></span><br><span class="line">        TX packets <span class="number">301</span>  bytes <span class="number">28358</span> (<span class="number">27.6</span> KiB)</span><br><span class="line">        TX errors <span class="number">0</span>  dropped <span class="number">0</span> overruns <span class="number">0</span>  carrier <span class="number">0</span>  collisions <span class="number">0</span></span><br><span class="line"></span><br><span class="line">[root@zjh ~]<span class="meta"># ifconfig ens33 | grep inet</span></span><br><span class="line">        inet:<span class="number">192.168</span><span class="number">.56</span><span class="number">.137</span>  netmask:<span class="number">255.255</span><span class="number">.255</span><span class="number">.0</span>  broadcast:<span class="number">192.168</span><span class="number">.56</span><span class="number">.255</span></span><br><span class="line">            </span><br><span class="line">[root@zjh ~]<span class="meta"># ifconfig ens33 | grep inet | cut -d : -f 2       </span></span><br><span class="line"><span class="number">192.168</span><span class="number">.56</span><span class="number">.137</span> netmask</span><br><span class="line"></span><br><span class="line">[root@zjh ~]<span class="meta"># ifconfig ens33 | grep inet | cut -d : -f 2 | cut -d <span class="string">&quot; &quot;</span> -f 1</span></span><br><span class="line"><span class="number">192.168</span><span class="number">.56</span><span class="number">.137</span></span><br></pre></td></tr></table></figure><h4 id="10-2-sed"><a href="#10-2-sed" class="headerlink" title="10.2 sed"></a>10.2 sed</h4><p><strong>1. 基本用法</strong></p><ul><li>sed是一种<strong>流编辑器</strong>，它一次处理一行内容，处理时，把当前处理的行存储在临时缓冲区中，成为“模式空间”,接着sed命令处理缓冲区中的内容，处理完成后，把缓冲区的内容送往屏幕，接着处理下一行，这样不断重复，知道文件末尾，<strong>文件内容并没有改变</strong>，除非你使用重定向存储输出。</li></ul><p><strong>2.选项参数说明</strong></p><ul><li><p>sed [选项参数]   ‘command’   filename</p><ul><li>-e     直接在指令列模式上进行sed的动作编辑</li></ul></li></ul><p><strong>3. 命令功能描述</strong></p><ul><li><p>a      新增，a的后面可以接字符串，在下一行出现</p></li><li><p>d      删除</p></li><li><p>s      查找并替换</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># DESC 在第二行后增加mei nv字符</span><br><span class="line">[root@zjh ~]<span class="meta"># sed  <span class="string">&quot;2a mei nv&quot;</span> sed.txt   <span class="comment">//2a表示第二行</span></span></span><br><span class="line">dong zhen                                <span class="comment">//单个一个需求命令的话，不需要-e，后面再说</span></span><br><span class="line">guan zhen</span><br><span class="line">mei nv</span><br><span class="line">wo wo</span><br><span class="line">lai lai</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#删除set.txt文件所有包含wo的行</span><br><span class="line">[root@zjh ~]# sed &#x27;/wo/d&#x27; sed.txt</span><br><span class="line">dong zhen                                </span><br><span class="line">guan zhen</span><br><span class="line"></span><br><span class="line">lai lai</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#将sed.txt文件中wo替换为ni</span><br><span class="line">[root@zjh ~]<span class="meta"># sed  <span class="string">&quot;s/wo/ni/g&quot;</span> sed.txt     g代表全局变量，把所有的wo替换为ni</span></span><br><span class="line">dong zhen                               </span><br><span class="line">guan zhen</span><br><span class="line">ni ni</span><br><span class="line">lai lai</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#将sed.txt文件中的第二行删除并将wo替换成ni</span><br><span class="line">[root@zjh ~]<span class="meta"># sed -e <span class="string">&quot;2d&quot;</span> -e <span class="string">&quot;s/wo/ni/g&quot;</span>  sed.txt</span></span><br><span class="line">dong zhen                               </span><br><span class="line">ni ni</span><br><span class="line">lai lai</span><br></pre></td></tr></table></figure><h4 id="10-3-awk"><a href="#10-3-awk" class="headerlink" title="10.3 awk"></a>10.3 awk</h4><p>awk 一个强大文件分析工具，把文件逐行的读入，以空格为默认分隔符将每行切片，切开的部分再进行分析处理。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk [选项参数] <span class="string">&#x27;pattern1 &#123;action1&#125; pattern2&#123;action2&#125;..&#x27;</span> filename</span><br></pre></td></tr></table></figure><ul><li>-F 指定输入文件分隔符</li><li>-v 赋值一个用户定义变量</li></ul><h4 id="10-4-sort"><a href="#10-4-sort" class="headerlink" title="10.4 sort"></a>10.4 sort</h4><p>sort 命令是在Linux里非常有用，它将文件进行排序，并将排序结果标准输出</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sort [选项] (参数)</span><br></pre></td></tr></table></figure><div class="table-container"><table><thead><tr><th style="text-align:center">参数</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">-n</td><td style="text-align:center">依照数值大小排序</td></tr><tr><td style="text-align:center">-r</td><td style="text-align:center">以相反的顺序排序</td></tr><tr><td style="text-align:center">-t</td><td style="text-align:center">设置排序时使用的分隔字符</td></tr><tr><td style="text-align:center">-k</td><td style="text-align:center">指定需要排序的列</td></tr></tbody></table></div><p>hen</p><p>lai lai<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">```c++</span><br><span class="line">#将sed.txt文件中wo替换为ni</span><br><span class="line">[root@zjh ~]# sed  &quot;s/wo/ni/g&quot; sed.txt     g代表全局变量，把所有的wo替换为ni</span><br><span class="line">dong zhen                               </span><br><span class="line">guan zhen</span><br><span class="line">ni ni</span><br><span class="line">lai lai</span><br></pre></td></tr></table></figure></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#将sed.txt文件中的第二行删除并将wo替换成ni</span><br><span class="line">[root@zjh ~]<span class="meta"># sed -e <span class="string">&quot;2d&quot;</span> -e <span class="string">&quot;s/wo/ni/g&quot;</span>  sed.txt</span></span><br><span class="line">dong zhen                               </span><br><span class="line">ni ni</span><br><span class="line">lai lai</span><br></pre></td></tr></table></figure><h4 id="10-3-awk-1"><a href="#10-3-awk-1" class="headerlink" title="10.3 awk"></a>10.3 awk</h4><p>awk 一个强大文件分析工具，把文件逐行的读入，以空格为默认分隔符将每行切片，切开的部分再进行分析处理。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk [选项参数] <span class="string">&#x27;pattern1 &#123;action1&#125; pattern2&#123;action2&#125;..&#x27;</span> filename</span><br></pre></td></tr></table></figure><ul><li>-F 指定输入文件分隔符</li><li>-v 赋值一个用户定义变量</li></ul><h4 id="10-4-sort-1"><a href="#10-4-sort-1" class="headerlink" title="10.4 sort"></a>10.4 sort</h4><p>sort 命令是在Linux里非常有用，它将文件进行排序，并将排序结果标准输出</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sort [选项] (参数)</span><br></pre></td></tr></table></figure><div class="table-container"><table><thead><tr><th style="text-align:center">参数</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">-n</td><td style="text-align:center">依照数值大小排序</td></tr><tr><td style="text-align:center">-r</td><td style="text-align:center">以相反的顺序排序</td></tr><tr><td style="text-align:center">-t</td><td style="text-align:center">设置排序时使用的分隔字符</td></tr><tr><td style="text-align:center">-k</td><td style="text-align:center">指定需要排序的列</td></tr></tbody></table></div>]]></content>
      
      
      <categories>
          
          <category> shell </category>
          
      </categories>
      
      
        <tags>
            
            <tag> shell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c++变量和基本类型</title>
      <link href="/2022/04/22/post1/"/>
      <url>/2022/04/22/post1/</url>
      
        <content type="html"><![CDATA[<blockquote><p>💛本文摘要💛</p><p><strong><code>c++  系列文章</code></strong></p><p><a href="https://blog.csdn.net/weixin_45043334/article/details/125380065">第2章 变量和基本类型</a><br><a href="https://blog.csdn.net/weixin_45043334/article/details/125402340">第3章 字符串、向量和数组</a><br><a href="https://blog.csdn.net/weixin_45043334/article/details/125449009">第4章 表达式</a><br><a href="https://blog.csdn.net/weixin_45043334/article/details/125647293">第5章 语句</a><br><a href="https://blog.csdn.net/weixin_45043334/article/details/125751253">第6章 函数</a><br><a href="https://blog.csdn.net/weixin_45043334/article/details/125850838">第8章 IO库</a><br><a href="https://blog.csdn.net/weixin_45043334/article/details/125947865">第9章 顺序容器</a><br><a href="https://blog.csdn.net/weixin_45043334/article/details/126002739">第10章 泛型算法</a><br><a href="https://blog.csdn.net/weixin_45043334/article/details/126246260">第11章 关联容器</a><br><a href="https://blog.csdn.net/weixin_45043334/article/details/126297355">第12章 动态内存</a><br><a href="https://blog.csdn.net/weixin_45043334/article/details/126394732">第13章 拷贝控制</a><br><a href="https://blog.csdn.net/weixin_45043334/article/details/126679427">第 14章 重载运算符</a><br><a href="https://blog.csdn.net/weixin_45043334/article/details/126728175?spm=1001.2014.3001.5502">第15章 面向对象程序设计</a><br><a href="https://blog.csdn.net/weixin_45043334/article/details/126808177">第 16章 模板与泛型编程</a></p></blockquote><h1 id="🍪第2章-变量和基本类型"><a href="#🍪第2章-变量和基本类型" class="headerlink" title="🍪第2章 变量和基本类型"></a>🍪第2章 变量和基本类型</h1><p>概述 c ++定义了几种基本的内置类型（如字符、整型、浮点数等），同时提供自动以数据类型的机制。</p><h2 id="🍮2-1-基本内置类型"><a href="#🍮2-1-基本内置类型" class="headerlink" title="🍮2.1 基本内置类型"></a>🍮2.1 基本内置类型</h2><p>基本内置类型包括算数类型和空类型。算数类型包括字符、整型数、浮点数和布尔值。</p><h3 id="🍭2-1-1-算术类型"><a href="#🍭2-1-1-算术类型" class="headerlink" title="🍭2.1.1 算术类型"></a>🍭2.1.1 算术类型</h3><div class="table-container"><table><thead><tr><th>类型</th><th>含义</th><th>最小尺寸</th></tr></thead><tbody><tr><td><code>bool</code></td><td>布尔类型</td><td>8bits</td></tr><tr><td><code>char</code></td><td>字符</td><td>8bits</td></tr><tr><td><code>wchar_t</code></td><td>宽字符</td><td>16bits</td></tr><tr><td><code>char16_t</code></td><td>Unicode字符</td><td>16bits</td></tr><tr><td><code>char32_t</code></td><td>Unicode字符</td><td>32bits</td></tr><tr><td><code>short</code></td><td>短整型</td><td>16bits</td></tr><tr><td><code>int</code></td><td>整型</td><td>16bits (在32位机器中是32bits)</td></tr><tr><td><code>long</code></td><td>长整型</td><td>32bits</td></tr><tr><td><code>long long</code></td><td>长整型</td><td>64bits （是在C++11中新定义的）</td></tr><tr><td><code>float</code></td><td>单精度浮点数</td><td>6位有效数字</td></tr><tr><td><code>double</code></td><td>双精度浮点数</td><td>10位有效数字</td></tr><tr><td><code>long double</code></td><td>扩展精度浮点数</td><td>10位有效数字</td></tr></tbody></table></div><p><strong>类型选择</strong></p><ol><li>当明确知道数值不为负时，选用无符号类型</li><li>在实际应用中，一般选用<code>int 类型</code>，如果大的话选用<code>long long</code>类型，一般short与 long不用</li><li>算术运算符，不要使用<code>char</code>和<code>bool</code>.因为char类型在一些机器上有符号，而到了另外机械就无符号。如果需要使用char，就指明是<code>signed char</code>或者<code>unsigned char</code></li><li>浮点数用<code>double</code>,因为float精度可能不够。long double没必要，消耗内存。<h3 id="🍭2-1-2-类型转换"><a href="#🍭2-1-2-类型转换" class="headerlink" title="🍭2.1.2 类型转换"></a>🍭2.1.2 类型转换</h3><strong>概述几种类型转换：</strong></li><li>非布尔值赋给布尔型，初始值为0则结果为false，否则为true。</li><li>浮点数转换为整数，结果<code>仅保留小数点前面的部分。</code></li><li>给无符号类型赋值时，如果超出它的表示范围，则<code>结果是初始值对无符号类型表示数值总数取模后的余数</code>,例如-1 赋给 8 位 unsigned char 的结果是 255。</li><li>给带符号类型赋值超出它的表达式，结果是<code>未定义</code>的，程序可能会崩掉<br>建议：尽量避免无法预知和依赖实际环境的行为</li></ol><p><strong>取模与取余区别：</strong><br><code>取余运算在取c值时，向0方向舍入，而取模运算在取c时，向负无穷方向舍入</code></p><ol><li>求整数商：c = [a / b]</li><li>计算模： r = a - c  * b;<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 举例 那题目当中的-1 举例</span><br><span class="line">-1 MOD 256</span><br><span class="line">第一步求商：</span><br><span class="line">c = [a / b] = -1 / 256 = -1 //结果为-0.0039,向负无穷取整为1</span><br><span class="line">第二步求模：</span><br><span class="line">r = a - c * b  =  (-1) - (-1) * 256  = 255</span><br><span class="line"></span><br><span class="line">//或者这样理解</span><br><span class="line"></span><br><span class="line">计算机在存储-1时是存储的-1的补码，对于8位unsigned char来说-1的原码为1000 0001，它的反码为（符号位不变，其他位置取反）1111 1110,则补码为（补码= 反码+1），1111 1111，换成十进制整数为255</span><br><span class="line"></span><br></pre></td></tr></table></figure><strong>含有无符号的整数</strong></li><li>一个表达式中既有无符号数又有int值时，int会被转换成无符号数。</li><li>无符号减无符号数，结果还是无符号数，如果是负值就等于取模后的值</li></ol><p><code>总结：无符号参与运算时，结果肯定不是负数，如果是负数则需要对结果取模</code></p><h3 id="🍭2-1-3-字面值常量"><a href="#🍭2-1-3-字面值常量" class="headerlink" title="🍭2.1.3 字面值常量"></a>🍭2.1.3 字面值常量</h3><p><strong>整型和浮点型字面值</strong><br><code>整型字面值中 0 开头的整数是 8 进制，0x 开头的整数是十六进制。</code></p><p>浮点型字面值可以用小数或科学计数法表示，科学计数法中的指数部分用 E 或 e 标识。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3.1415926</span>   <span class="number">0.</span>  <span class="number">0e0</span>  <span class="number">.001</span>  <span class="number">3.14159E2</span></span><br></pre></td></tr></table></figure><br><strong>字符和字符串字面值</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;c&#x27;</span>            字符字面值</span><br><span class="line"><span class="string">&quot;Hell world&quot;</span>   字符串字面值比实际值多<span class="number">1</span>，因为它的最后多一个<span class="string">&#x27;\0&#x27;</span>（空字符）</span><br><span class="line">               hello world被看做一个整体，只要字符串字面值位置仅有空格、缩进、换行符分隔，就看做一个整体</span><br></pre></td></tr></table></figure><br><strong>转义序列</strong></p><div class="table-container"><table><thead><tr><th>换行符：\n</th><th>横向制表符：\t</th><th>报警符：\a</th></tr></thead><tbody><tr><td>纵向制表符：\v</td><td>退格符：\b</td><td><strong>双引号：\“</strong></td></tr><tr><td><strong>反斜线：\\</strong></td><td><strong>单引号：\‘</strong></td><td><strong>问号：\?</strong></td></tr><tr><td>回车符：\r</td><td>进纸符：\f</td></tr></tbody></table></div><p><strong>布尔字面值和指针字面值</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">true</span> <span class="literal">false</span>    是布尔类型的字面值</span><br><span class="line">nullptr       是指针字面值</span><br></pre></td></tr></table></figure></p><h2 id="🍮2-2-变量"><a href="#🍮2-2-变量" class="headerlink" title="🍮2.2 变量"></a>🍮2.2 变量</h2><p>变量 ：提供一个具名的、可供程序操作的存储空间<br>对象  ：一块能存储数据并具有某种类型的内存<br><code>对于c++,而言变量和对象可以互换使用</code></p><h3 id="🍭2-2-1-变量的定义"><a href="#🍭2-2-1-变量的定义" class="headerlink" title="🍭2.2.1 变量的定义"></a>🍭2.2.1 变量的定义</h3><p><strong>初始化</strong></p><p>对象在创建的过程中就获得了一个值，此时这个对象被初始化。</p><p><code>初始化和赋值的区别：</code></p><ul><li>初始化不是赋值，初始化是创建一个变量时赋予其一个初始值</li><li>赋值是把对象的当前值擦除，而以一个新值来代替。</li></ul><p><strong>列表初始化</strong><br>用一对{ }来表示列表初始化<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">0</span>; </span><br><span class="line"><span class="type">int</span> i = &#123;<span class="number">0</span>&#125;; </span><br><span class="line"><span class="type">int</span> i &#123;<span class="number">0</span>&#125;; </span><br><span class="line"><span class="type">int</span> <span class="title function_">i</span> <span class="params">(<span class="number">0</span>)</span>;</span><br></pre></td></tr></table></figure><br><code>特点</code>:如果使用列表初始化，且初始值存在，丢失情况，则编译器会报错<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="type">double</span> ld = <span class="number">3.141592</span>；</span><br><span class="line"><span class="type">int</span> a&#123;ld&#125;；                <span class="comment">//错误，信息丢失，精度问题，转换失败</span></span><br><span class="line"><span class="type">int</span> c(ld), d=ld;           <span class="comment">//正确</span></span><br></pre></td></tr></table></figure></p><p><strong>默认初始化</strong></p><ul><li>定义在函数体内的内置类型的对象没有初始化，则其值为未定义。</li><li>定义在函数体外的内置类型的对象没有初始化，则其值为0（string为空，int型为0）</li></ul><p>全局变量没有初始化，系统会自动初始化为0，局部变量没有初始化，未定义，会报错。<br><code>建议初始化每一个内置类型的变量。</code></p><h3 id="🍭2-2-2-变量声明和定义"><a href="#🍭2-2-2-变量声明和定义" class="headerlink" title="🍭2.2.2 变量声明和定义"></a>🍭2.2.2 变量声明和定义</h3><p>声明：使得名字让程序知道     (不申请存储空间)<br>定义：创建与名字关联的实体（也就是初始化，需要申请存储空间）</p><p><code>要声明一个变量加 extern，声明变量不能赋值。</code><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">int</span> i;     <span class="comment">// 声明 i</span></span><br><span class="line"><span class="type">int</span> j;            <span class="comment">// 声明并定义j；</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> i = <span class="number">1</span>; <span class="comment">// 定义 i，初始化抵消了 extern 的作用。</span></span><br></pre></td></tr></table></figure><br>变量能且只能被定义一次，但是可以被多次声明<br><code>c++是静态类型语言，其含义是在编译阶段检查类型。</code></p><h3 id="🍭2-2-3-标识符"><a href="#🍭2-2-3-标识符" class="headerlink" title="🍭2.2.3 标识符"></a>🍭2.2.3 标识符</h3><p><code>标识符组成：字母、数字、下划线。不能以数字开头，对大小写敏感。标识符的长度没有限制。</code></p><p>变量命名规范：</p><ul><li>标识符要体现其实际含义。</li><li>变量名一般用小写字母，index,不要使用Index或INDEX</li><li>用户自定义的类型一般以大写字母开头。Sales_item</li><li>包含多个单词的标识符，使用驼峰命名法或使用下划线连接不同单词。</li><li>对于嵌套作用域，可以在内层作用域中重新定义外层作用域已有的名字，但是最好不要这样做。<h3 id="🍭2-2-4-名字作用域"><a href="#🍭2-2-4-名字作用域" class="headerlink" title="🍭2.2.4 名字作用域"></a>🍭2.2.4 名字作用域</h3></li><li>第一次使用变量时再定义它。</li><li>嵌套作用域，作用域一旦声明了，那么它所嵌套的所有作用域中都能访问该名字，允许在内层作用域中重新定义外层已有的作用域</li></ul><p><code>实际就是：局部变量覆盖全局变量</code></p><h2 id="🍮2-3-复合类型"><a href="#🍮2-3-复合类型" class="headerlink" title="🍮2.3 复合类型"></a>🍮2.3 复合类型</h2><p>复合类型是基于其他类型定义的类型，例如<code>指针和引用</code></p><h3 id="🍭2-3-1-引用"><a href="#🍭2-3-1-引用" class="headerlink" title="🍭2.3.1 引用"></a>🍭2.3.1 引用</h3><p><code>引用就是给对象起别名</code></p><p><strong>引用的本质就是指针常量，指针常量就是指针所指对象的值可以变，但是指针所指的对象不可以变，因此他和一个对象绑定好后，通过引用来改变值，但是不可以在重新绑定到另一个对象上</strong></p><p><strong>引用总结</strong></p><ul><li><code>引用必须初始化</code></li><li><code>引用的初始值必须是一个对象，不能是字面值，如果想要是字面值需要加const</code></li><li><code>引用不是对象，所以不能定义引用的引用，也不能定义引用的指针</code></li><li>对引用的所有操作都对与之绑定的对象的操作</li><li><code>引用必须绑定一个对象上，且不能重新绑定到另一个对象上</code></li><li>引用的类型与绑定的类型要匹配</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">0</span>；</span><br><span class="line"><span class="type">int</span> &amp;r = i;</span><br></pre></td></tr></table></figure><h3 id="🍭2-3-2-指针"><a href="#🍭2-3-2-指针" class="headerlink" title="🍭2.3.2 指针"></a>🍭2.3.2 指针</h3><p><code>在块作用域内，指针如果没有被初始化，值将不确定。</code><br>指针类型被用于指定它所指向的对象的类型，二者要匹配<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="type">double</span> *dp = &amp;i;   <span class="comment">// 错误</span></span><br><span class="line"><span class="type">int</span> *ip = i;       <span class="comment">// 错误，但 int *ip = 0; 是正确的</span></span><br><span class="line"><span class="type">int</span> *p = &amp;i;       <span class="comment">//正确</span></span><br></pre></td></tr></table></figure><br><strong><code>指针与引用区别</code></strong></p><ul><li>指针是一个对象而引用不是</li><li>指针可以重定向，引用不可以；</li><li>有指向指针的指针，没有指向引用的引用；</li><li>指针不需要在定义时赋初值而引用需要。</li><li>不能定义指向引用的指针。可以定义指向指针的引用。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *p; </span><br><span class="line"><span class="type">int</span>* &amp;r = p;      <span class="comment">// r是对指针p的引用（指针的引用）</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> &amp;r = i;</span><br><span class="line"><span class="type">int</span>&amp; *p = &amp;r      <span class="comment">//指向引用的指针，错误的，因为r不是对象，没有地址。</span></span><br></pre></td></tr></table></figure><p>利用解引用符（<em>）可以访问指针指向的对象。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">42</span>;</span><br><span class="line"><span class="type">int</span> *p = &amp;i;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *p &lt;&lt;<span class="built_in">endl</span>;  结果为<span class="number">42</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><br><em>*空指针</em></em><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *p = nullptr; <span class="comment">// 推荐这种</span></span><br><span class="line"><span class="type">int</span> *p = <span class="number">0</span>; </span><br><span class="line"><span class="type">int</span> *p = <span class="literal">NULL</span>;    <span class="comment">// NULL 是在头文件 cstdlib 中定义的预处理变量，值为 0。</span></span><br></pre></td></tr></table></figure><br><code>建议初始化所有指针</code></p><p><strong>赋值和指针</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">42</span>;</span><br><span class="line"><span class="type">int</span>  *p = &amp;i;</span><br><span class="line">*p = <span class="number">30</span>;</span><br></pre></td></tr></table></figure><br>说明：</p><ul><li>指针所指的对象变了（i 的值变了）</li><li>指针本身并没有变化 （i 的地址没变），<code>指针指的是地址，而不是值</code></li></ul><p><strong>void*指针</strong><br>void* 指针是特殊的指针类型，可以存放任意对象的地址。它的用处比较有限。(不使用)</p><h3 id="🍭2-3-3-理解复合类型的声明"><a href="#🍭2-3-3-理解复合类型的声明" class="headerlink" title="🍭2.3.3 理解复合类型的声明"></a>🍭2.3.3 理解复合类型的声明</h3><p>一条声明语句是由一个基本数据类型和后面的声明符列表组成的。</p><p>引用符 &amp; 和指针符 <em> 都是类型说明符，类型说明符是声明符的一部分。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">1024</span>, *p = &amp;i, &amp;r = i;</span><br><span class="line"><span class="type">int</span> *p, p2;   <span class="comment">//p是指向int的指针，p2是int</span></span><br></pre></td></tr></table></figure><br><em>*指向指针的指针</em></em><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i  = <span class="number">1024</span>;</span><br><span class="line"><span class="type">int</span> *p = &amp;i;      <span class="comment">//p指向一个int 型数</span></span><br><span class="line"><span class="type">int</span> **p1 = &amp;p;    <span class="comment">//p1指向一个int 型指针</span></span><br></pre></td></tr></table></figure><br><img src="https://img-blog.csdnimg.cn/9910119c45a6472a87272c28931eaab0.png" alt="在这里插入图片描述"></p><p><strong>指向指针的引用</strong></p><p><code>引用本身不是一个对象，所以没有指向引用的指针,但是指针是对象，存在对指针的引用</code><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i =  <span class="number">42</span>;</span><br><span class="line"><span class="type">int</span> *p ;       <span class="comment">//p是int型指针</span></span><br><span class="line"><span class="type">int</span> *&amp;r = p;  <span class="comment">//指向指针的引用</span></span><br><span class="line"></span><br><span class="line">-------------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> &amp;r = i;</span><br><span class="line"><span class="type">int</span>&amp; *p = &amp;r      <span class="comment">//指向引用的指针，错误的，因为r不是对象，没有地址。</span></span><br></pre></td></tr></table></figure><br>想要理解r的类型到底是什么，可以<code>从右往左读</code>，离变量最近的符号（本例中是&amp;r符号）<code>，因此r是一个</code>引用<code>，声明符以外的部分可以确定</code>r引用的类型<code>是什么。本例中</code>&amp;左边是*<code>，所以r引用的是一个</code>指针`</p><h2 id="🍮2-4-const限定符"><a href="#🍮2-4-const限定符" class="headerlink" title="🍮2.4 const限定符"></a>🍮2.4 const限定符</h2><ul><li><code>const对象必须初始化</code>，因为const对象一旦创建，其值不能改变</li><li>const指向的对象，不能改变，但是仍然可以和int一样，进行<code>运算</code></li><li>默认情况下，const对象<code>只在文件内有效</code></li><li>如果想要在不同文件中<code>共享const</code>，必须在定义变量之前添加<code>exten关键字</code></li></ul><h3 id="🍭2-4-1-const的引用"><a href="#🍭2-4-1-const的引用" class="headerlink" title="🍭2.4.1 const的引用"></a>🍭2.4.1 const的引用</h3><ul><li><code>引用必须初始化</code>，因此常量引用也必须初始化。</li><li>常量引用是对 const 的引用，对象可以是<code>常量</code>也可以是<code>非常量</code></li><li>不能用非常量引用指向一个常量对象。可以用常量引用指向一个非常量对象。</li><li>引用的类型必须与其所引用对象的类型一致，<code>有俩种情况特殊，下面详细说</code></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">42</span>;           <span class="comment">//非常量</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> j  = <span class="number">42</span>;    <span class="comment">//常量</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;p  = i;   <span class="comment">//正确</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;p  = j;   <span class="comment">//正确,常量引用的对象既可以是常量也可以是非常量 </span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;p =  <span class="number">10</span>;  <span class="comment">//正确</span></span><br><span class="line"><span class="type">int</span> &amp;p = <span class="number">10</span>;         <span class="comment">//错误      </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//非常量引用不能指向常量对象</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> p = <span class="number">66</span>;</span><br><span class="line"><span class="type">int</span> &amp;r = p;         <span class="comment">//错误</span></span><br></pre></td></tr></table></figure><p><strong>引用的类型必须与其所引用对象的类型一致，<code>有俩种情况特殊，下面详细说</code></strong></p><ol><li>初始化常量引用时允许用任意表达式作为初始值（包括常量表达式），只要该表达式结果可以转换为引用的类型。</li><li>当用常量引用绑定一个非常量对象时，不能通过引用改变引用对象的值，但是可以通过其他方式改变值。常量指针也一样。</li></ol><p><strong>举例</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> val = <span class="number">3.1415</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;p = val;   <span class="comment">//正确</span></span><br></pre></td></tr></table></figure><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i  =<span class="number">42</span>;</span><br><span class="line"><span class="type">int</span> &amp;r1 = i;         <span class="comment">//引用r1绑定对象i</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;r2 = i;  <span class="comment">//常量引用r2 绑定i,此时不允许通过r2来修改i的值，但是可以用r1来修改i 的值</span></span><br><span class="line"></span><br><span class="line">r1 = <span class="number">0</span>;     <span class="comment">//正确，i 的值修改为0</span></span><br><span class="line">r2 = <span class="number">0</span>;    <span class="comment">//错误</span></span><br></pre></td></tr></table></figure></p><h3 id="🍭2-4-2-指针和const"><a href="#🍭2-4-2-指针和const" class="headerlink" title="🍭2.4.2 指针和const"></a>🍭2.4.2 指针和const</h3><ul><li>指向常量的指针和指向常量的引用用法相似，既可以指向常量，也可以指向非常量，如果指向非常量，那莫这个非常量对象的值不可以不可以通过指针，来改变，可以通过其他途径改变。</li></ul><p><strong>指针常量与常量指针区别</strong></p><ul><li>指针常量：指针所指的对象值<code>可以变</code>，但是指针所指的<code>地址不可以变</code>    int * const p = &amp;r</li><li>常量指针：指针所指的对象的值<code>不可以变</code>，但是指针所指的<code>地址可以变</code> const int * p = &amp;r</li></ul><h3 id="🍭2-4-3-顶层const"><a href="#🍭2-4-3-顶层const" class="headerlink" title="🍭2.4.3 顶层const"></a>🍭2.4.3 顶层const</h3><ul><li><code>顶层const表示指针常量</code>，指针本身是一个常量，地址不能变，但是值可以修改。</li><li><code>底层const表示常量指针</code>， 指针所指的值是一个常量，不可以修改，但是地址可以变。</li><li>顶层const的指针，表示该指针是const对象，因此必须初始化，而底层const不需要初始化。</li><li><code>顶层const对任意数据类型都适用，但是底层const只用于引用和指针</code></li></ul><p><strong>指针类型既可以是顶层 const 也可以是底层 const，因为引用只能是底层 const，常量引用为底层 const，不存在顶层 const 的引用。</strong><br><br/><br><strong>怎么区分是顶层const还是底层const,最简单的方法</strong></p><ul><li>对于指针和引用来说，顶层const在右边，底层const在左边。对于其他类型来说，全部都是顶层cosnt.(<code>记住就能理解了</code>)<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span>* <span class="type">const</span> p1 = p2; <span class="comment">// 从右向左读，右侧const是顶层const，表明p3是一个常量，左侧const是底层const，表明指针所指的对象是一个常量</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span>* p3 = &amp;c;       <span class="comment">// 这是一个底层const，允许改变 p2 的值（常量指针）----const在左边为底层</span></span><br><span class="line"><span class="type">int</span>* <span class="type">const</span> p4 = &amp;i;       <span class="comment">// 这是一个顶层const，不能改变 p1 的值（指针常量）----cosnt在右边为顶层</span></span><br></pre></td></tr></table></figure></li></ul><p>执行对象的拷贝操作时，不能将底层 const 拷贝给非常量，反之可以，非常量将会转化为常量。</p><h3 id="🍭2-4-4-constexpr和常量表达式"><a href="#🍭2-4-4-constexpr和常量表达式" class="headerlink" title="🍭2.4.4 constexpr和常量表达式"></a>🍭2.4.4 constexpr和常量表达式</h3><p><code>常量表达式是指值不会改变并且在编译过程就能得到计算结果的表达式。</code><br><code>字面值属于常量表达式，由常量表达式初始化的 const 对象也是常量表达式。</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> i = <span class="number">32</span>              <span class="comment">//常量表达式</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> j = i + <span class="number">1</span>           <span class="comment">// 常量表达式</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> sum = get_size()    <span class="comment">//不是常量表达式，尽管 sum 是常量，但它的具体值等到运行时才知道。</span></span><br></pre></td></tr></table></figure><p><strong>constexpr变量</strong></p><ul><li>在一个复杂的系统中，很难分辨一个初始值到底是不是常量表达式，此时通过把变量声明为<code>constexpr</code>类型，使得编译器自动帮我们验证。</li><li><code>由 constexpr 声明的变量一定是常量不能是普通函数，必须用常量表达式初始化。</code></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">constexpr <span class="type">int</span> sz = size(); <span class="comment">//只有当 size() 是一个 constexpr 函数时这才是一条正确的声明语句。</span></span><br><span class="line">constexpr <span class="type">int</span> mf = <span class="number">20</span>;     <span class="comment">//常量表达式</span></span><br><span class="line">constexpr <span class="type">int</span> limit = mf + <span class="number">1</span>;   <span class="comment">// mf + 1是常量表达式</span></span><br></pre></td></tr></table></figure><p><strong>字面值类型</strong></p><ul><li>算术类型、引用、指针都属于字面值类型，自定义类则不属于。</li><li>cosntexpr 指针的初始值必须是<code>nullptr 或 0 或存储于固定地址的对象</code>。</li><li>函数体之外的对象和静态变量的地址都是固定不变的.,可以用constexpr初始化，而函数体内的变量不能用contexpr.</li></ul><p><strong>指针和constexpr</strong></p><p><code>contexpr所定义的对象都是顶层const</code>，仅对指针有效<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> *p = nullptr;     <span class="comment">// p 是一个指向整型常量的指针(指针常量)底层const</span></span><br><span class="line">constexpr <span class="type">int</span> *q = nullptr; <span class="comment">// q 是一个指向整数的常量指针(常量指针)定义成了顶层const</span></span><br></pre></td></tr></table></figure></p><p><strong>const与constexpr区别</strong></p><ul><li>constexpr限定了变量是编译器常量，即变量在编译过程中就可以得到结果。</li><li>const 未区分是编译器常量还是运行期常量。即 const 变量可以在运行期间初始化，只不过是初始化后的值就不能再改变了。</li><li>constexpr 变量是真正的“常量”，而 const 现在一般只用来表示 “只读”。</li></ul><h2 id="🍮2-5-处理类型"><a href="#🍮2-5-处理类型" class="headerlink" title="🍮2.5 处理类型"></a>🍮2.5 处理类型</h2><h3 id="🍭2-5-1-类型别名"><a href="#🍭2-5-1-类型别名" class="headerlink" title="🍭2.5.1 类型别名"></a>🍭2.5.1 类型别名</h3><p>目前有俩种方法来定义类型别名</p><ul><li>typedef</li><li>using<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> wages;  <span class="comment">// 使用 typedef 关键字</span></span><br><span class="line">using wages = <span class="type">int</span>;  <span class="comment">// 使用 using 关键字进行别名声明</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> wages base, *p; <span class="comment">// base 是 double 的别名，p 是 double* 的别名。</span></span><br></pre></td></tr></table></figure></li></ul><p><strong>指针、常量和类型别名</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">char</span>* pstring; </span><br><span class="line"><span class="type">const</span> pstring cstr = <span class="number">0</span>; <span class="comment">// 注意：const 是一个指向 char 的常量指针。不能采用直接替换的方式将其理解为 const char* cstr = 0，这是错误的。</span></span><br></pre></td></tr></table></figure></p><h3 id="🍭2-5-2-auto类型说明符"><a href="#🍭2-5-2-auto类型说明符" class="headerlink" title="🍭2.5.2 auto类型说明符"></a>🍭2.5.2 auto类型说明符</h3><ul><li>auto让编译器自动帮你识别，表达式所属的类型</li><li>但是与int 不同的是，auto让编译器通过初始值来推算变量的类型，所以<code>auto 必须要有初始值</code></li><li>auto 可以在一条语句中声明多个变量，但是多个变量必须是同一个基本数据类型（整型与整型指针和整型引用算一个类型）。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> vall, sum;</span><br><span class="line"><span class="keyword">auto</span> item = vall + sum  <span class="comment">//自动推断为int类型</span></span><br></pre></td></tr></table></figure><p><strong>复合类型、常量和auto</strong></p><p><strong>编译器推断出的 auto 类型有时和初始值并不一样，编译器会进行适当的调整：</strong></p><ul><li>auto 根据引用来推断类型时会以引用对象的类型作为 auto 的类型。</li><li>auto 一般会忽略掉顶层 const，因此对于非指针类型的常量对象，auto 推断出的结果是不含 const 的。如果希望 auto 是一个顶层 const，需要明确指出。</li><li>auto 会保留底层 const。</li></ul><p><code>概括一下就是 auto 会忽略引用与顶层 const。</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> ci = <span class="number">1</span>, cr = ci;</span><br><span class="line"><span class="keyword">auto</span> b = ci;       <span class="comment">// b 是一个普通的 int。</span></span><br><span class="line"><span class="keyword">auto</span> c = cr;       <span class="comment">// c 是一个普通的 int。</span></span><br><span class="line"><span class="type">const</span> <span class="keyword">auto</span> d = ci; <span class="comment">// d 是一个 const int</span></span><br><span class="line"><span class="keyword">auto</span> &amp;e = ci;      <span class="comment">// e 是一个常量引用（常量引用是底层 const）。注意这个微妙的地方。</span></span><br><span class="line"><span class="keyword">auto</span> f = &amp;ci;      <span class="comment">// f 是一个 const int*（位于左边的 const 是底层 const）</span></span><br></pre></td></tr></table></figure><p>int 与 int *、int &amp; 是一个基本数据类型，而 const int 与 int 不是一种类型。<br>用 auto 定义引用时，必须用 &amp; 指明要定义的是引用。</p><h3 id="🍭2-5-3-decltype类型指示符"><a href="#🍭2-5-3-decltype类型指示符" class="headerlink" title="🍭2.5.3 decltype类型指示符"></a>🍭2.5.3 decltype类型指示符</h3><ul><li>希望从表达式的类型推断出要定义的变量的类型。但是不需要进行初始化时，可以使用decltype。</li><li>如果如果 decltype 使用的表达式是一个变量，则它返回<code>该变量的类型（包括顶层 const 和引用在内）。</code></li><li>decltype与auto不同，decltype不会忽略引用和顶层const</li><li>引用从来都是作为对象的别名出现，只有在 decltype 处是例外。</li></ul><p><code>当获得的对象类型是引用时，必须初始化</code><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> ci = <span class="number">0</span>, &amp;cj = ci;</span><br><span class="line">decltype(ci) x = <span class="number">0</span>;  <span class="comment">// x 的类型是 const int</span></span><br><span class="line">decltype(cj) y = x;  <span class="comment">// y 的类型是 const int&amp;</span></span><br><span class="line">decltype(cj) z;      <span class="comment">//错误 z 是一个引用，必须初始化</span></span><br></pre></td></tr></table></figure></p><p><strong>decltype和引用</strong></p><ul><li>如果decltype使用的表达式不是一个变量，则decltype返回表达式结果对应的类型</li><li>如果表达式的内容是解引用操作，那么decltype将得到引用类型</li><li>decltype((variable))—-双层括号的结果永远是引用<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">6</span>, &amp;r = i, *p;</span><br><span class="line">decltype(r+<span class="number">0</span>) b;      <span class="comment">// b 的类型是 int，因为 r+0 的结果类型是 int。</span></span><br><span class="line">decltype(*p) c = i;   <span class="comment">// c 的类型是 int&amp;。</span></span><br><span class="line">decltype((i)) d = i;  <span class="comment">// d 的类型是 int&amp;。</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="🍮2-6-自定义数据结构"><a href="#🍮2-6-自定义数据结构" class="headerlink" title="🍮2.6 自定义数据结构"></a>🍮2.6 自定义数据结构</h2><h3 id="🍭2-6-1-定义Sales-data类型"><a href="#🍭2-6-1-定义Sales-data类型" class="headerlink" title="🍭2.6.1 定义Sales_data类型"></a>🍭2.6.1 定义Sales_data类型</h3><p><code>struct+类名+类体+分号。类体可以为空。</code><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Sales_data</span>&#123;</span>&#125;;      <span class="comment">//结尾注意有分号</span></span><br><span class="line"></span><br><span class="line">对象定义有俩种方式</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Sales_data</span>&#123;</span>&#125; students;   <span class="comment">//方式1</span></span><br><span class="line">Sales_data students;            <span class="comment">//方式2</span></span><br></pre></td></tr></table></figure></p><p><code>定义类时可以给数据成员提供类内初始值以进行初始化。没有类内初始值的成员则被默认初始化。</code><br><code>类内初始值可以放在花括号中或等号的右边，不能使用圆括号。</code></p><h3 id="🍭2-6-2-使用Sales-data类（没东西，暂时省略hhh）"><a href="#🍭2-6-2-使用Sales-data类（没东西，暂时省略hhh）" class="headerlink" title="🍭2.6.2 使用Sales_data类（没东西，暂时省略hhh）"></a>🍭2.6.2 使用Sales_data类（没东西，暂时省略hhh）</h3><h3 id="🍭2-6-3-编写自己的头文件"><a href="#🍭2-6-3-编写自己的头文件" class="headerlink" title="🍭2.6.3 编写自己的头文件"></a>🍭2.6.3 编写自己的头文件</h3><ul><li>类通常定义在头文件中，类所在头文件的名字应与类的名字一样。</li><li>头文件通常定义那些只能被定义一次的实体，比如类、const、constexpr 等。</li><li>头文件一旦改变，相关的源文件必须重新编译以获取更新过的声明。</li></ul><p><strong>预处理器概述</strong></p><p>确保头文件多次包含仍能安全工作的常用技术是预处理器。</p><p><code>预处理变量有两种状态：已定义和未定义。一般把预处理变量的名字全部大写。</code></p><p><code>整个程序中的预处理变量包括头文件保护符必须唯一，通常基于头文件中类的名字来构建保护符的名字，以确保其唯一性。</code></p><p>c++ 中包含三个头文件保护符：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- <span class="meta">#<span class="keyword">define</span>：把一个名字设定为预处理变量`</span></span><br><span class="line">- <span class="meta">#<span class="keyword">ifdef</span>  :当且仅当变量已定义时为真。`</span></span><br><span class="line">- <span class="meta">#<span class="keyword">ifndef</span>：当且仅当变量已定义时为真，一旦检查结果为真，则执行后续操作直到遇到 #<span class="keyword">endif</span> 为止</span></span><br><span class="line">- <span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><br>预处理变量无视作用域的规则，作用范围是文件内</p>]]></content>
      
      
      <categories>
          
          <category> c++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
